<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>🏎️ Race Module v1 – Brake Envelope + Pit Envelope + Telemetry Zoom + Data Output</title>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg-dark: #0a0a0f;
      --bg-panel: #12151c;
      --bg-card: #1a1e28;
      --accent-red: #e94560;
      --accent-cyan: #00d4ff;
      --accent-green: #00ff88;
      --accent-yellow: #ffd700;
      --text-primary: #ffffff;
      --text-secondary: #8892a0;
      --border: rgba(255, 255, 255, 0.1);
    }

    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg-dark);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      user-select: none;
    }

    .app { display: grid; grid-template-rows: auto 1fr auto; height: 100vh; }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: var(--bg-panel);
      border-bottom: 1px solid var(--border);
      gap: 16px;
    }

    .logo { font-size: 16px; font-weight: 900; color: var(--accent-cyan); }

    .timer {
      font-size: 24px;
      font-weight: 900;
      font-family: 'Consolas', monospace;
      letter-spacing: 2px;
      white-space: nowrap;
    }

    .status {
      font-size: 12px;
      color: var(--text-secondary);
      text-align: right;
      min-width: 260px;
      line-height: 1.25;
      white-space: pre-line;
    }

    .canvas-container { position: relative; background: var(--bg-dark); overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; }

    .zoom-info {
      position: absolute;
      bottom: 12px;
      left: 12px;
      background: rgba(0, 0, 0, 0.7);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 11px;
      font-family: 'Consolas', monospace;
      border: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(8px);
    }

    .car-info {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(0, 0, 0, 0.85);
      padding: 16px;
      border-radius: 10px;
      min-width: 320px;
      border: 1px solid var(--border);
      backdrop-filter: blur(8px);
    }

    .info-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--accent-cyan);
      margin-bottom: 12px;
      font-weight: 900;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      font-size: 12px;
      gap: 18px;
    }

    .info-row span:first-child { color: var(--text-secondary); white-space: nowrap; }
    .info-row span:last-child { font-family: 'Consolas', monospace; font-weight: 800; white-space: nowrap; }

    .footer {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      padding: 12px 20px;
      background: var(--bg-panel);
      border-top: 1px solid var(--border);
      flex-wrap: wrap;
    }

    .btn {
      padding: 8px 16px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--bg-card);
      color: var(--text-primary);
      font-size: 12px;
      font-weight: 900;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .btn:hover { background: #252a36; }
    .btn.primary { background: var(--accent-green); color: #000; border-color: var(--accent-green); }
    .btn.primary:hover { background: #00cc66; }

    .btn.warn { background: rgba(255, 215, 0, 0.12); border-color: rgba(255, 215, 0, 0.35); }
    .btn.warn:hover { background: rgba(255, 215, 0, 0.18); }

    .btn.danger { background: rgba(233, 69, 96, 0.12); border-color: rgba(233, 69, 96, 0.35); }
    .btn.danger:hover { background: rgba(233, 69, 96, 0.18); }

    .btn:disabled { opacity: 0.45; cursor: not-allowed; }

    .speed-group {
      display: flex;
      gap: 2px;
      background: var(--bg-card);
      padding: 4px;
      border-radius: 10px;
      border: 1px solid var(--border);
    }

    .speed-btn {
      padding: 6px 10px;
      border: none;
      border-radius: 8px;
      background: transparent;
      color: var(--text-secondary);
      font-size: 11px;
      font-weight: 900;
      cursor: pointer;
      transition: all 0.1s;
    }

    .speed-btn:hover { color: var(--text-primary); }
    .speed-btn.active { background: var(--accent-cyan); color: #000; }

    .lap-display {
      font-size: 14px;
      font-weight: 900;
      font-family: 'Consolas', monospace;
      padding: 0 10px;
      white-space: nowrap;
    }

    .lap-display span { color: var(--text-secondary); }

    /* ─────────────────────────────────────────────
       Modal
    ───────────────────────────────────────────── */
    .modal {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0, 0, 0, 0.65);
      z-index: 50;
    }
    .modal.open { display: grid; }

    .modal-card {
      width: min(1100px, calc(100vw - 28px));
      max-height: calc(100vh - 28px);
      overflow: hidden;
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: 0 20px 80px rgba(0, 0, 0, 0.55);
      display: grid;
      grid-template-rows: auto auto 1fr auto;
    }

    .modal-head {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
      gap: 12px;
    }
    .modal-title { font-weight: 900; letter-spacing: 0.2px; color: var(--accent-cyan); }

    .modal-controls {
      padding: 12px 16px;
      display: flex;
      gap: 14px;
      align-items: end;
      border-bottom: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.02);
      flex-wrap: wrap;
    }

    .select-group { display: flex; flex-direction: column; gap: 6px; min-width: 220px; }
    .select-group label {
      font-size: 11px;
      color: var(--text-secondary);
      letter-spacing: 0.4px;
      text-transform: uppercase;
      font-weight: 900;
    }

    select, input[type="number"] {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 9px 10px;
      color: var(--text-primary);
      outline: none;
      font-weight: 900;
    }

    .legend {
      margin-left: auto;
      font-size: 12px;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .legend .pill {
      display: inline-grid;
      place-items: center;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
      font-weight: 900;
      color: rgba(255,255,255,0.9);
    }

    #telemetryCanvas {
      width: 100%;
      height: 100%;
      background:
        radial-gradient(80% 80% at 20% 0%, rgba(0, 212, 255, 0.08), transparent 55%),
        radial-gradient(70% 70% at 90% 20%, rgba(255, 215, 0, 0.06), transparent 55%),
        var(--bg-dark);
      cursor: grab;
    }
    #telemetryCanvas.dragging { cursor: grabbing; }

    .modal-foot {
      padding: 12px 16px;
      border-top: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .modal-foot .hint { color: var(--text-secondary); font-size: 12px; }

    /* Setup modal grid */
    .setup-grid {
      padding: 14px 16px;
      display: grid;
      grid-template-columns: repeat(3, minmax(220px, 1fr));
      gap: 12px;
      overflow: auto;
      background: rgba(255,255,255,0.02);
    }
    @media (max-width: 980px) { .setup-grid { grid-template-columns: repeat(2, minmax(220px, 1fr)); } }
    @media (max-width: 680px) { .setup-grid { grid-template-columns: 1fr; } }

    .field {
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      display: grid;
      gap: 8px;
    }

    .field .lbl {
      font-size: 11px;
      color: var(--text-secondary);
      letter-spacing: 0.4px;
      text-transform: uppercase;
      font-weight: 900;
    }
    .field .row { display: flex; gap: 10px; align-items: center; }
    .field .row input { width: 100%; }
    .field .unit { color: var(--text-secondary); font-weight: 900; font-size: 12px; min-width: 44px; text-align: right; }

    pre#dataOut {
      white-space: pre;
      font: 12px Consolas, monospace;
      color: rgba(255,255,255,0.92);
    }

    /* ─────────────────────────────────────────────
       F1-Style Live Timing Panel
    ───────────────────────────────────────────── */
    .live-timing {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(0, 0, 0, 0.92);
      border: 1px solid var(--border);
      border-radius: 8px;
      min-width: 320px;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
      backdrop-filter: blur(12px);
      font-family: 'Consolas', 'Monaco', monospace;
      z-index: 10;
    }

    .live-timing-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      background: linear-gradient(90deg, #e10600 0%, #15151e 100%);
      border-radius: 7px 7px 0 0;
      font-weight: 900;
      font-size: 11px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .live-timing-header select {
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 4px;
      color: white;
      font-size: 10px;
      padding: 4px 8px;
      font-weight: 700;
    }

    .timing-row {
      display: grid;
      grid-template-columns: 24px 28px 1fr 42px 48px 60px 48px 68px;
      gap: 3px;
      padding: 5px 6px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      font-size: 11px;
      align-items: center;
      transition: background 0.2s;
    }
    .timing-spd { font-size:10px; text-align:right; color:#adf; font-variant-numeric:tabular-nums; }
    .timing-tire-fuel { display:flex; align-items:center; gap:3px; font-size:9px; }
    .timing-tire-badge {
      display:inline-flex; align-items:center; gap:1px;
      padding:1px 3px; border-radius:3px; font-weight:800; font-size:9px; line-height:1;
    }
    .timing-tire-bar, .timing-fuel-bar {
      width:18px; height:8px; border-radius:2px; background:rgba(255,255,255,0.1); position:relative; overflow:hidden;
    }
    .timing-tire-bar-fill, .timing-fuel-bar-fill {
      position:absolute; left:0; top:0; height:100%; border-radius:2px; transition:width 0.3s;
    }

    .timing-row:hover { background: rgba(255,255,255,0.05); }
    .timing-row.selected { background: rgba(0, 212, 255, 0.15); border-left: 3px solid var(--accent-cyan); }
    .timing-row.leader { background: rgba(255, 215, 0, 0.08); }

    .timing-slip {
      font-size: 9px;
      font-weight: 700;
      text-align: center;
      padding: 2px 4px;
      border-radius: 3px;
    }
    .timing-slip.drag-bonus { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
    .timing-slip.dirty-air { background: rgba(255, 100, 100, 0.2); color: #ff6464; }
    .timing-slip.neutral { color: rgba(255,255,255,0.4); }

    .timing-pos {
      font-weight: 900;
      font-size: 13px;
      text-align: center;
    }
    .timing-pos.p1 { color: #ffd700; }
    .timing-pos.p2 { color: #c0c0c0; }
    .timing-pos.p3 { color: #cd7f32; }

    .timing-number {
      background: var(--car-color, #e94560);
      color: white;
      font-weight: 900;
      font-size: 10px;
      text-align: center;
      border-radius: 3px;
      padding: 2px 0;
    }

    .timing-name {
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .timing-gap {
      text-align: right;
      font-weight: 600;
      color: var(--text-secondary);
    }
    .timing-gap.leader { color: var(--accent-green); }
    .timing-gap.interval { color: #ff8800; }

    .timing-int {
      text-align: right;
      font-weight: 600;
      font-size: 10px;
      color: #aaa;
    }
    .timing-int.interval { color: #ff8800; }
    .timing-int.drs { color: #00ff88; font-weight: 900; }

    .timing-last {
      text-align: right;
      font-weight: 700;
    }
    .timing-last.purple { color: #a855f7; }
    .timing-last.green { color: var(--accent-green); }
    .timing-last.yellow { color: #ffd700; }

    .car-selector {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: rgba(0, 212, 255, 0.1);
      border-top: 1px solid var(--border);
      border-radius: 0 0 7px 7px;
    }

    .car-selector label {
      font-size: 10px;
      color: var(--accent-cyan);
      font-weight: 900;
      letter-spacing: 0.5px;
    }

    .car-selector select {
      flex: 1;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: white;
      padding: 6px 10px;
      font-weight: 700;
      font-size: 11px;
    }

    /* ─────────────────────────────────────────────
       F1-Style Sector Times Display
    ───────────────────────────────────────────── */
    .timing-sectors {
      display: flex;
      gap: 4px;
      padding: 4px 10px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }

    .sector-time {
      flex: 1;
      text-align: center;
      font-size: 10px;
      font-weight: 700;
      padding: 3px 0;
      border-radius: 3px;
      font-family: 'Consolas', monospace;
    }
    .sector-time.s1 { border-left: 3px solid #ff3366; }
    .sector-time.s2 { border-left: 3px solid #00ff88; }
    .sector-time.s3 { border-left: 3px solid #00aaff; }
    
    .sector-time.purple { background: rgba(168, 85, 247, 0.3); color: #a855f7; }
    .sector-time.green { background: rgba(0, 255, 136, 0.15); color: #00ff88; }
    .sector-time.yellow { background: rgba(255, 215, 0, 0.15); color: #ffd700; }
    .sector-time.white { color: rgba(255,255,255,0.8); }

    /* Timing row expanded with sectors */
    .timing-row-expanded {
      background: rgba(0,0,0,0.4);
      padding: 6px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .timing-row-expanded .sector-mini {
      display: inline-block;
      width: 55px;
      text-align: center;
      font-size: 9px;
      font-weight: 700;
      margin-right: 4px;
      padding: 2px 4px;
      border-radius: 2px;
    }

    /* Full F1 Timing Modal */
    .f1-timing-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.95);
      display: none;
      z-index: 1000;
      overflow-y: auto;
    }
    .f1-timing-modal.open { display: block; }

    .f1-timing-content {
      max-width: 1000px;
      margin: 20px auto;
      padding: 20px;
    }

    .f1-timing-header-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      background: linear-gradient(90deg, #e10600 0%, #15151e 50%);
      border-radius: 8px 8px 0 0;
      border-bottom: 3px solid #e10600;
    }

    .f1-timing-title {
      font-size: 18px;
      font-weight: 900;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .f1-timing-close {
      background: rgba(255,255,255,0.1);
      border: none;
      color: white;
      font-size: 24px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.2s;
    }
    .f1-timing-close:hover { background: rgba(255,255,255,0.2); }

    .f1-timing-table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(21, 21, 30, 0.98);
      border-radius: 0 0 8px 8px;
      overflow: hidden;
    }

    .f1-timing-table th {
      background: rgba(0,0,0,0.5);
      padding: 12px 8px;
      text-align: left;
      font-size: 10px;
      font-weight: 900;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.6);
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .f1-timing-table td {
      padding: 10px 8px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      font-size: 12px;
    }

    .f1-timing-table tr:hover { background: rgba(255,255,255,0.03); }
    .f1-timing-table tr.selected { background: rgba(0, 212, 255, 0.1); }

    .f1-pos {
      font-weight: 900;
      font-size: 16px;
      text-align: center;
      width: 30px;
    }
    .f1-pos.gold { color: #ffd700; }
    .f1-pos.silver { color: #c0c0c0; }
    .f1-pos.bronze { color: #cd7f32; }

    .f1-driver {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .f1-number {
      display: inline-block;
      width: 32px;
      height: 24px;
      line-height: 24px;
      text-align: center;
      background: var(--car-color, #e94560);
      color: white;
      font-weight: 900;
      font-size: 11px;
      border-radius: 4px;
    }

    .f1-name {
      font-weight: 700;
      font-size: 13px;
    }

    .f1-team {
      font-size: 10px;
      color: rgba(255,255,255,0.5);
      margin-top: 2px;
    }

    .f1-time {
      font-family: 'Consolas', 'Monaco', monospace;
      font-weight: 700;
      font-size: 13px;
      text-align: right;
    }
    .f1-time.leader { color: #ffd700; }
    .f1-time.fastest { color: #a855f7; }

    .f1-gap {
      font-family: 'Consolas', monospace;
      font-weight: 600;
      font-size: 12px;
      text-align: right;
      color: rgba(255,255,255,0.7);
    }
    .f1-gap.positive { color: #ff6b6b; }

    .f1-sector {
      font-family: 'Consolas', monospace;
      font-weight: 700;
      font-size: 11px;
      text-align: center;
      padding: 4px 8px;
      border-radius: 3px;
      min-width: 60px;
    }
    .f1-sector.purple { background: rgba(168, 85, 247, 0.25); color: #a855f7; }
    .f1-sector.green { background: rgba(0, 255, 136, 0.15); color: #00ff88; }
    .f1-sector.yellow { background: rgba(255, 215, 0, 0.15); color: #ffd700; }
    .f1-sector.white { color: rgba(255,255,255,0.7); }

    .f1-tire {
      display: inline-block;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      text-align: center;
      line-height: 24px;
      font-size: 10px;
      font-weight: 900;
    }
    .f1-tire.soft { background: #e10600; color: white; }
    .f1-tire.medium { background: #ffd700; color: black; }
    .f1-tire.hard { background: #f0f0f0; color: black; }

    .f1-laps {
      text-align: center;
      font-weight: 600;
      color: rgba(255,255,255,0.6);
    }

    /* ═══ LOADING SCREEN ═══ */
    .loading-screen {
      position: fixed; inset: 0; z-index: 20000;
      background: linear-gradient(135deg, #0a0a0f 0%, #0d1520 40%, #0a0f1a 100%);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #fff; overflow: hidden;
      transition: opacity 0.6s ease;
    }
    .loading-screen.fade-out { opacity: 0; pointer-events: none; }
    .loading-screen.hidden { display: none; }
    .loading-logo {
      font-size: 64px; margin-bottom: 8px;
      animation: loadPulse 2s ease-in-out infinite;
    }
    @keyframes loadPulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.1)} }
    .loading-title {
      font-size: 28px; font-weight: 900; letter-spacing: 3px;
      color: var(--accent-cyan); margin-bottom: 4px;
      text-shadow: 0 0 20px rgba(0,212,255,0.4);
    }
    .loading-subtitle {
      font-size: 13px; color: #667; margin-bottom: 36px; letter-spacing: 1px;
    }
    .loading-bars {
      display: flex; flex-direction: column; gap: 14px;
      width: 340px;
    }
    .loading-bar-group { display: flex; flex-direction: column; gap: 4px; }
    .loading-bar-label {
      font-size: 11px; color: #889; display: flex;
      justify-content: space-between;
    }
    .loading-bar-track {
      height: 6px; border-radius: 3px; background: rgba(255,255,255,0.06);
      overflow: hidden; position: relative;
    }
    .loading-bar-fill {
      height: 100%; border-radius: 3px; width: 0%;
      transition: width 0.3s cubic-bezier(0.4,0,0.2,1);
    }
    .loading-bar-fill.bar-physics { background: linear-gradient(90deg, #00d4ff, #00ffaa); }
    .loading-bar-fill.bar-assets  { background: linear-gradient(90deg, #ff8800, #ffd700); }
    .loading-bar-fill.bar-grid    { background: linear-gradient(90deg, #e94560, #ff6b8a); }
    .loading-hint {
      margin-top: 32px; font-size: 11px; color: #445;
      font-style: italic; text-align: center; max-width: 300px;
    }
    .loading-glow {
      position: absolute; bottom: -80px; left: 50%; transform: translateX(-50%);
      width: 500px; height: 200px; border-radius: 50%;
      background: radial-gradient(ellipse, rgba(0,212,255,0.08) 0%, transparent 70%);
      pointer-events: none;
    }

    /* ═══ MAIN MENU ═══ */
    .main-menu {
      position: fixed; inset: 0; z-index: 15000;
      background: linear-gradient(160deg, #0a0a0f 0%, #0d1520 50%, #0a0f1a 100%);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #fff;
    }
    .main-menu.hidden { display: none; }
    .mm-logo { font-size: 56px; margin-bottom: 6px; }
    .mm-title {
      font-size: 32px; font-weight: 900; letter-spacing: 4px;
      color: var(--accent-cyan); margin-bottom: 2px;
      text-shadow: 0 0 24px rgba(0,212,255,0.3);
    }
    .mm-sub { font-size: 12px; color: #556; margin-bottom: 48px; letter-spacing: 1px; }
    .mm-buttons {
      display: flex; flex-direction: column; gap: 16px; width: 360px;
    }
    .mm-btn {
      display: flex; align-items: center; gap: 14px;
      padding: 18px 24px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.03);
      cursor: pointer; transition: all 0.25s ease;
      text-align: left;
    }
    .mm-btn:hover {
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.15);
      transform: translateX(4px);
    }
    .mm-btn-icon { font-size: 28px; flex-shrink: 0; }
    .mm-btn-text { display: flex; flex-direction: column; }
    .mm-btn-label { font-size: 16px; font-weight: 700; color: #fff; }
    .mm-btn-hint { font-size: 11px; color: #667; margin-top: 2px; }
    .mm-btn.primary { border-color: rgba(0,212,255,0.25); background: rgba(0,212,255,0.06); }
    .mm-btn.primary:hover { background: rgba(0,212,255,0.12); border-color: rgba(0,212,255,0.4); }
    .mm-version {
      position: absolute; bottom: 20px; font-size: 11px; color: #334; letter-spacing: 1px;
    }

    /* ═══ CAR/DRIVER EDITOR ═══ */
    .car-editor-overlay {
      position: fixed; inset: 0; z-index: 16000;
      background: #0a0d13;
      display: flex; flex-direction: column;
      overflow: hidden;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #e0e0e0;
    }
    .car-editor-overlay.hidden { display: none; }
    .ce-header {
      width: 100%; padding: 10px 20px; box-sizing: border-box;
      background: #151820; border-bottom: 1px solid #2a2e3a;
      display: flex; align-items: center; gap: 14px; flex-shrink: 0;
    }
    .ce-header .ce-title { font-size: 16px; font-weight: 700; color: #fff; }
    .ce-header button {
      padding: 5px 14px; border: 1px solid #444; border-radius: 4px;
      font-size: 12px; font-weight: 600; cursor: pointer;
      background: #222; color: #ccc; transition: background 0.15s;
    }
    .ce-header button:hover { background: #333; }
    .ce-header button.ce-save { background: #2e7d32; color: #fff; border-color: #2e7d32; }
    .ce-header button.ce-save:hover { background: #1b5e20; }
    .ce-header button.ce-reset { background: #b71c1c; color: #fff; border-color: #b71c1c; }
    .ce-header button.ce-reset:hover { background: #8b0000; }
    .ce-grid {
      flex: 1; overflow-y: auto; padding: 12px 16px;
      display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 12px; align-content: start;
    }
    .ce-card {
      background: #151820; border: 1px solid #2a2e3a; border-radius: 8px;
      padding: 12px; position: relative;
    }
    .ce-card-header {
      display: flex; align-items: center; gap: 8px; margin-bottom: 10px;
      padding-bottom: 8px; border-bottom: 1px solid #222;
    }
    .ce-car-swatch {
      width: 24px; height: 24px; border-radius: 4px; border: 1px solid #444;
    }
    .ce-car-number {
      font-size: 18px; font-weight: 900; color: #fff;
      font-family: 'Consolas', monospace;
    }
    .ce-car-team { font-size: 12px; color: #889; flex: 1; }
    .ce-driver-name {
      background: #1a1e28; border: 1px solid #333; border-radius: 3px;
      color: #fff; padding: 3px 6px; font-size: 12px; width: 100%;
      box-sizing: border-box; margin-bottom: 8px;
    }
    .ce-driver-name:focus { border-color: #1a73e8; outline: none; }
    .ce-section-label {
      font-size: 10px; font-weight: 700; color: #556; text-transform: uppercase;
      letter-spacing: 1px; margin: 8px 0 4px;
    }
    .ce-field {
      display: flex; align-items: center; gap: 6px; margin-bottom: 4px;
    }
    .ce-field label {
      font-size: 11px; color: #889; width: 80px; flex-shrink: 0;
    }
    .ce-field input {
      background: #1a1e28; border: 1px solid #333; border-radius: 3px;
      color: #ddd; padding: 3px 5px; font-size: 11px; flex: 1;
      box-sizing: border-box; width: 0;
    }
    .ce-field input:focus { border-color: #1a73e8; outline: none; }
    .ce-field .ce-unit { font-size: 10px; color: #556; width: 34px; }
    .ce-skill-row {
      display: flex; align-items: center; gap: 6px; margin-bottom: 3px;
    }
    .ce-skill-row label { font-size: 11px; color: #889; width: 80px; flex-shrink: 0; }
    .ce-skill-row input[type=range] {
      flex: 1; accent-color: var(--accent-cyan); height: 4px;
    }
    .ce-skill-row .ce-skill-val {
      font-size: 11px; font-weight: 700; width: 28px; text-align: right;
      font-family: 'Consolas', monospace;
    }

    /* ═══ TRACK EDITOR OVERLAY ═══ */
    .track-editor-overlay {
      position: fixed; inset: 0;
      z-index: 10000;
      background: #0a0d13;
      display: flex; flex-direction: column;
      align-items: center; justify-content: flex-start;
      overflow: hidden;
      padding: 0;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #e0e0e0;
    }
    .track-editor-overlay.hidden { display: none; }

    /* ── Editor header ── */
    .te-header {
      width: 100%; padding: 10px 20px; box-sizing: border-box;
      background: #151820; border-bottom: 1px solid #2a2e3a;
      display: flex; align-items: center; gap: 14px;
      flex-shrink: 0;
    }
    .te-header .te-title {
      font-size: 16px; font-weight: 700; color: #fff; white-space: nowrap;
    }
    .te-header button {
      padding: 5px 14px; border: 1px solid #444; border-radius: 4px;
      font-size: 12px; font-weight: 600; cursor: pointer;
      background: #222; color: #ccc; transition: background 0.15s;
    }
    .te-header button:hover { background: #333; }
    .te-header button.te-primary { background: #1a73e8; color: #fff; border-color: #1a73e8; }
    .te-header button.te-primary:hover { background: #1565c0; }
    .te-header button.te-success { background: #2e7d32; color: #fff; border-color: #2e7d32; }
    .te-header button.te-success:hover { background: #1b5e20; }
    .te-header .te-sep { width: 1px; height: 22px; background: #333; flex-shrink: 0; }

    /* ── Info bar (stats) ── */
    .te-info {
      width: 100%; padding: 6px 20px; box-sizing: border-box;
      background: #111318; border-bottom: 1px solid #222;
      display: flex; gap: 18px; flex-shrink: 0; font-size: 12px;
    }
    .te-info .te-stat {
      padding: 3px 8px; border-radius: 3px;
      background: rgba(255,255,255,0.04); color: #888; white-space: nowrap;
    }
    .te-info .te-stat.ok   { color: #69f0ae; background: rgba(50,255,100,0.08); }
    .te-info .te-stat.warn { color: #ff6b6b; background: rgba(255,50,50,0.08); }

    /* ── Editor body: table + preview side by side ── */
    .te-body {
      flex: 1; width: 100%; display: flex; overflow: hidden;
    }

    /* ── Segment table ── */
    .te-table-wrap {
      flex: 1; overflow-y: auto; padding: 10px 16px; min-width: 0;
    }
    .te-table {
      width: 100%; border-collapse: collapse; font-size: 12px;
    }
    .te-table th {
      position: sticky; top: 0; background: #151820;
      padding: 6px 6px; text-align: left; font-weight: 600;
      color: #888; border-bottom: 1px solid #333; z-index: 1;
    }
    .te-table td {
      padding: 4px 4px; border-bottom: 1px solid #1e2230;
    }
    .te-table input, .te-table select {
      background: #1a1e28; border: 1px solid #333; border-radius: 3px;
      color: #ddd; padding: 3px 5px; font-size: 12px; width: 100%;
      box-sizing: border-box;
    }
    .te-table input:focus, .te-table select:focus {
      border-color: #1a73e8; outline: none;
    }
    .te-table .te-del-btn {
      background: none; border: none; color: #666; cursor: pointer;
      font-size: 14px; padding: 2px 6px;
    }
    .te-table .te-del-btn:hover { color: #ff5555; }
    .te-table .te-add-btn {
      background: #1a73e8; border: none; color: #fff; cursor: pointer;
      font-size: 16px; padding: 2px 10px; border-radius: 3px; margin-top: 6px;
    }

    /* ── Preview canvas ── */
    .te-preview-wrap {
      width: 420px; flex-shrink: 0; border-left: 1px solid #2a2e3a;
      display: flex; flex-direction: column; align-items: center;
      background: #0d1017; padding: 8px;
    }
    .te-preview-wrap canvas {
      width: 400px; height: 380px; background: #0a0d13;
      border: 1px solid #222; border-radius: 4px;
    }
    .te-preview-label {
      font-size: 11px; color: #555; margin-top: 4px;
    }

    /* ═══ MINIMAP OVERLAY ═══ */
    #minimapCanvas {
      position: absolute; bottom: 12px; left: 12px;
      width: 180px; height: 180px;
      background: rgba(10,12,20,0.82);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      z-index: 60;
      pointer-events: none;
      box-shadow: 0 2px 16px rgba(0,0,0,0.5);
    }

    /* ═══ PARTICLE OVERLAY ═══ */
    #particleCanvas {
      position: fixed; inset: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 200;
    }

    /* ═══ TIMING ROW POSITION ANIMATIONS ═══ */
    .timing-row {
      transition: transform 0.4s cubic-bezier(.4,0,.2,1), background 0.3s ease;
    }
    .timing-row.pos-up {
      animation: posUp 0.5s ease;
    }
    .timing-row.pos-down {
      animation: posDown 0.5s ease;
    }
    @keyframes posUp {
      0%   { transform: translateY(28px); background: rgba(0,255,100,0.12); }
      100% { transform: translateY(0); background: transparent; }
    }
    @keyframes posDown {
      0%   { transform: translateY(-28px); background: rgba(255,60,60,0.10); }
      100% { transform: translateY(0); background: transparent; }
    }

    /* ═══ OVERTAKE FLASH ═══ */
    .overtake-flash {
      animation: overtakeGlow 0.7s ease;
    }
    @keyframes overtakeGlow {
      0%   { box-shadow: inset 0 0 20px rgba(0,200,100,0.4); }
      100% { box-shadow: none; }
    }

    /* ═══ RAIN OVERLAY ═══ */
    #rainOverlay {
      position: fixed; inset: 0;
      pointer-events: none;
      z-index: 55;
      opacity: 0;
      transition: opacity 1s ease;
      background: linear-gradient(180deg, rgba(100,130,180,0.06) 0%, rgba(60,80,120,0.03) 100%);
    }
    #rainOverlay.active {
      opacity: 1;
    }

    /* ═══ COUNTDOWN OVERLAY ═══ */
    #countdownOverlay {
      position: fixed; inset: 0;
      display: none; align-items: center; justify-content: center;
      z-index: 500;
      pointer-events: none;
    }
    #countdownText {
      font-size: 120px; font-weight: 900;
      color: #fff;
      text-shadow: 0 0 40px rgba(255,0,0,0.6), 0 4px 20px rgba(0,0,0,0.8);
      animation: countPulse 0.8s ease;
      font-family: 'Orbitron', system-ui;
    }
    @keyframes countPulse {
      0%   { transform: scale(1.6); opacity: 0; }
      30%  { transform: scale(1.0); opacity: 1; }
      100% { transform: scale(0.95); opacity: 0.7; }
    }
    .countdown-go {
      color: #00ff88 !important;
      text-shadow: 0 0 60px rgba(0,255,100,0.7), 0 4px 20px rgba(0,0,0,0.8) !important;
    }

  </style>
</head>

<body>
  <!-- ═══ LOADING SCREEN ═══ -->
  <div id="loadingScreen" class="loading-screen">
    <div class="loading-logo">🏎️</div>
    <div class="loading-title">RACE MODULE</div>
    <div class="loading-subtitle">FORMULA 1 SIMULATOR</div>
    <div class="loading-bars">
      <div class="loading-bar-group">
        <div class="loading-bar-label"><span>Physics Engine</span><span id="loadPct1">0%</span></div>
        <div class="loading-bar-track"><div class="loading-bar-fill bar-physics" id="loadBar1"></div></div>
      </div>
      <div class="loading-bar-group">
        <div class="loading-bar-label"><span>Track Assets</span><span id="loadPct2">0%</span></div>
        <div class="loading-bar-track"><div class="loading-bar-fill bar-assets" id="loadBar2"></div></div>
      </div>
      <div class="loading-bar-group">
        <div class="loading-bar-label"><span>Grid Formation</span><span id="loadPct3">0%</span></div>
        <div class="loading-bar-track"><div class="loading-bar-fill bar-grid" id="loadBar3"></div></div>
      </div>
    </div>
    <div class="loading-hint" id="loadingHint">Initializing telemetry systems...</div>
    <div class="loading-glow"></div>
  </div>

  <!-- ═══ RACE LOADING OVERLAY ═══ -->
  <div id="raceLoadingOverlay" style="
    position:fixed; inset:0; z-index:9999;
    display:none; flex-direction:column; align-items:center; justify-content:center;
    background:radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a14 100%);
    transition: opacity 0.45s ease;
  ">
    <div style="font-size:64px; animation: pulse 1.2s ease-in-out infinite;">🏎️</div>
    <div style="font:bold 22px system-ui; color:#fff; margin-top:12px; letter-spacing:3px;">BUILDING TRACK</div>
    <div style="color:rgba(255,255,255,0.5); font:13px system-ui; margin-top:6px;" id="raceLoadHint">Initializing race...</div>
    <div style="margin-top:20px; width:200px; height:4px; background:rgba(255,255,255,0.1); border-radius:2px; overflow:hidden;">
      <div style="height:100%; width:60%; background:linear-gradient(90deg,#00d4ff,#00ff88); border-radius:2px; animation: loadSlide 1.5s ease-in-out infinite;"></div>
    </div>
    <style>
      @keyframes loadSlide { 0%{transform:translateX(-100%)} 50%{transform:translateX(80%)} 100%{transform:translateX(-100%)} }
    </style>
  </div>

  <!-- ═══ MAIN MENU ═══ -->
  <div id="mainMenu" class="main-menu hidden">
    <div class="mm-logo">🏁</div>
    <div class="mm-title">RACE MODULE</div>
    <div class="mm-sub">FORMULA 1 SIMULATOR</div>
    <div class="mm-buttons">
      <div class="mm-btn primary" id="mmStartRace">
        <span class="mm-btn-icon">▶</span>
        <div class="mm-btn-text">
          <span class="mm-btn-label">Start Race</span>
          <span class="mm-btn-hint">Launch a race with current settings</span>
        </div>
      </div>
      <div class="mm-btn" id="mmEditTrack">
        <span class="mm-btn-icon">🛤️</span>
        <div class="mm-btn-text">
          <span class="mm-btn-label">Edit Track</span>
          <span class="mm-btn-hint">Customize segments, corners & layout</span>
        </div>
      </div>
      <div class="mm-btn" id="mmEditCars">
        <span class="mm-btn-icon">🏎️</span>
        <div class="mm-btn-text">
          <span class="mm-btn-label">Edit Cars & Drivers</span>
          <span class="mm-btn-hint">Tune performance, skills & driver names</span>
        </div>
      </div>
      <div class="mm-btn" id="mmMultiplayer" style="border-color: var(--accent-cyan);">
        <span class="mm-btn-icon">🌐</span>
        <div class="mm-btn-text">
          <span class="mm-btn-label">Multiplayer</span>
          <span class="mm-btn-hint">Host or join an online race</span>
        </div>
      </div>
    </div>
    <div class="mm-version">v1.0 — Built with ❤️ for sim racing</div>
  </div>

  <!-- ═══ CAR/DRIVER EDITOR ═══ -->
  <div id="carEditorOverlay" class="car-editor-overlay hidden">
    <div class="ce-header">
      <span class="ce-title">🏎️ Cars & Drivers</span>
      <div style="flex:1"></div>
      <button class="ce-reset" id="ceResetAll">↺ Reset All Equal</button>
      <button class="ce-save" id="ceSave">✅ Save & Back</button>
      <button id="ceBack">✕ Back</button>
    </div>
    <div class="ce-grid" id="ceGrid">
      <!-- Cards generated dynamically by CarDriverEditor -->
    </div>
  </div>

  <!-- ═══ TRACK EDITOR OVERLAY ═══ -->
  <div id="trackEditorOverlay" class="track-editor-overlay hidden">
    <!-- Header -->
    <div class="te-header">
      <span class="te-title">🏁 Track Editor</span>
      <div class="te-sep"></div>
      <button id="teBackToMenu" class="te-primary">← Back to Menu</button>
      <button id="teGenCustom" class="te-success">✅ Save & Start Race</button>
    </div>

    <!-- Info bar -->
    <div class="te-info">
      <span class="te-stat" id="teSegCount">Segments: 0</span>
      <span class="te-stat" id="teLapLen">Lap length: — m</span>
      <span class="te-stat" id="teNetAngle">Net angle: —°</span>
      <span class="te-stat" id="teClosure">Closure: —</span>
      <div style="flex:1"></div>
      <span class="te-stat" style="color:#aaa">
        Laps: <input type="number" id="teTrackLaps" value="8" min="1" max="99" style="width:40px;background:#1a1e28;border:1px solid #333;border-radius:3px;color:#ddd;padding:2px 4px;font-size:12px;text-align:center">
      </span>
      <span class="te-stat" style="color:#aaa">
        Grip: <select id="teTrackGrip" style="background:#1a1e28;border:1px solid #333;border-radius:3px;color:#ddd;padding:2px 4px;font-size:12px">
          <option value="0.85">Low (Wet)</option>
          <option value="1.0" selected>Normal (Dry)</option>
          <option value="1.05">High (Rubbered)</option>
        </select>
      </span>
      <span class="te-stat" style="color:#aaa">
        Track Name: <input type="text" id="teTrackName" value="Speed Oval" style="width:120px;background:#1a1e28;border:1px solid #333;border-radius:3px;color:#ddd;padding:2px 4px;font-size:12px">
      </span>
      <span class="te-stat" style="color:#aaa">
        🌤 Weather: <select id="teWeatherCondition" style="background:#1a1e28;border:1px solid #333;border-radius:3px;color:#ddd;padding:2px 4px;font-size:12px">
          <option value="sunny">☀ Sunny</option>
          <option value="cloudy">☁ Cloudy</option>
          <option value="light_rain">🌦 Light Rain</option>
          <option value="heavy_rain">🌧 Heavy Rain</option>
        </select>
      </span>
      <span class="te-stat" style="color:#aaa">
        🌡 <input type="number" id="teWeatherTemp" value="25" min="5" max="45" step="1" style="width:38px;background:#1a1e28;border:1px solid #333;border-radius:3px;color:#ddd;padding:2px 4px;font-size:12px;text-align:center">°C
      </span>
    </div>

    <!-- Body: table + preview -->
    <div class="te-body">
      <!-- Segment table -->
      <div class="te-table-wrap">
        <table class="te-table">
          <thead>
            <tr>
              <th style="width:30px">#</th>
              <th style="width:90px">Type</th>
              <th style="width:80px">Length (m)</th>
              <th style="width:80px">Angle (°)</th>
              <th style="width:80px">Radius (m)</th>
              <th style="width:80px">Direction</th>
              <th style="width:120px">Name</th>
              <th style="width:30px"></th>
            </tr>
          </thead>
          <tbody id="teTableBody"></tbody>
        </table>
        <button class="te-add-btn" id="teAddRow" title="Add segment">＋ Add Segment</button>
      </div>

      <!-- Preview canvas -->
      <div class="te-preview-wrap">
        <canvas id="tePreviewCanvas" width="800" height="760"></canvas>
        <span class="te-preview-label">Track preview</span>
      </div>
    </div>

    <!-- Weather Schedule (pre-race, inside Track Editor) -->
    <div id="weatherScheduleSection" style="margin:0 12px 12px; border-top:1px solid #333; padding-top:10px;">
      <div class="lbl" style="margin-bottom:8px; font-size:12px;">⏱ Weather Schedule (pre-race timeline)</div>
      <div id="weatherScheduleList" style="display:flex; flex-direction:column; gap:6px; margin-bottom:8px;"></div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <label style="font-size:11px; color:#888;">Min:</label>
        <input type="number" id="wsAddTime" value="0" min="0" max="120" step="1" style="width:50px; background:#1a1e28; color:#ddd; border:1px solid #555; border-radius:4px; padding:3px 5px; font-size:11px;">
        <select id="wsAddCond" style="background:#1a1e28; color:#ddd; border:1px solid #555; border-radius:4px; padding:3px 5px; font-size:11px;">
          <option value="sunny">☀ Sunny</option>
          <option value="cloudy">☁ Cloudy</option>
          <option value="light_rain">🌦 Light Rain</option>
          <option value="heavy_rain">🌧 Heavy Rain</option>
        </select>
        <input type="number" id="wsAddTemp" value="25" min="5" max="45" step="1" style="width:50px; background:#1a1e28; color:#ddd; border:1px solid #555; border-radius:4px; padding:3px 5px; font-size:11px;">
        <span style="font-size:10px; color:#888;">°C</span>
        <button class="btn" id="wsAddBtn" style="font-size:11px; padding:3px 10px;">+ Add</button>
        <button class="btn" id="wsClearBtn" style="font-size:11px; padding:3px 10px; margin-left:auto;">✕ Clear All</button>
      </div>
      <div class="hint" style="margin-top:6px; font-size:10px;">Definiere Wetter zu bestimmten Zeitpunkten. Dazwischen wird interpoliert.</div>
    </div>
  </div>

  <div class="app" id="mainApp" style="display:none">
    <header class="header">
      <div class="logo">🏎️ RACE MODULE v1</div>
      <div class="timer" id="timer">00:00.000</div>
      <div class="status" id="status">Ready - Press START</div>
      <div id="sessionClock" style="color:#aaa;font-size:11px;font-family:monospace;margin-left:12px;" title="Session elapsed time">🕐 00:00:00</div>
    </header>

    <div class="canvas-container">
      <canvas id="canvas"></canvas>
      <canvas id="minimapCanvas" width="360" height="360"></canvas>
      <div class="zoom-info">
        Zoom: <span id="zoomLevel">100%</span> | Scroll to zoom, drag to pan
        <button id="followBtn" style="margin-left:15px; padding:4px 10px; background:#444; color:#fff; border:1px solid #666; border-radius:4px; cursor:pointer;">📷 Follow</button>
      </div>

      <!-- F1-Style Live Timing Panel -->
      <div class="live-timing" id="liveTiming">
        <div class="live-timing-header">
          <span>🏁 LIVE TIMING</span>
          <span id="raceStatus">LAP 0/8</span>
          <button id="openFullTiming" style="background:rgba(255,255,255,0.15); border:none; color:white; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:10px;">⛶ EXPAND</button>
        </div>
        <!-- Current sector times for selected car -->
        <div class="timing-sectors" id="currentSectors">
          <div class="sector-time s1 white" id="sector1Time">S1 --.-</div>
          <div class="sector-time s2 white" id="sector2Time">S2 --.-</div>
          <div class="sector-time s3 white" id="sector3Time">S3 --.-</div>
        </div>
        <div id="timingRows">
          <!-- Timing rows will be populated dynamically -->
        </div>
        <div class="car-selector">
          <label>🎮 CONTROL:</label>
          <select id="controlledCarSelect">
            <option value="0">Select Car...</option>
          </select>
        </div>
      </div>

      <!-- Full F1-Style Timing Modal -->
      <div class="f1-timing-modal" id="f1TimingModal">
        <div class="f1-timing-content">
          <div class="f1-timing-header-bar">
            <div class="f1-timing-title">🏎️ RACE TIMING</div>
            <button class="f1-timing-close" id="closeFullTiming">×</button>
          </div>
          <table class="f1-timing-table">
            <thead>
              <tr>
                <th style="width:40px">POS</th>
                <th>DRIVER</th>
                <th style="width:80px">TIME</th>
                <th style="width:70px">GAP</th>
                <th style="width:70px">INT</th>
                <th style="width:70px">S1</th>
                <th style="width:70px">S2</th>
                <th style="width:70px">S3</th>
                <th style="width:80px">LAST LAP</th>
                <th style="width:80px">BEST LAP</th>
                <th style="width:40px">TIRE</th>
                <th style="width:40px">LAPS</th>
              </tr>
            </thead>
            <tbody id="f1TimingBody">
              <!-- Rows populated dynamically -->
            </tbody>
          </table>
        </div>
      </div>

      <div class="car-info">
        <div class="info-title">📊 Telemetry</div>
        <div class="info-row"><span>Speed</span><span id="infoSpeed">0 km/h</span></div>
        <div class="info-row"><span>Lap</span><span id="infoLap">0</span></div>
        <div class="info-row"><span>Lap Time</span><span id="infoLapTime">--:--.---</span></div>
        <div class="info-row"><span>Best Lap</span><span id="infoBestLap">--:--.---</span></div>
        
        <div class="info-title" style="margin-top:6px; font-size:11px; opacity:0.6;">─ Car ─</div>
        <div class="info-row"><span>Throttle</span><span id="infoThrottle">0%</span></div>
        <div class="info-row"><span>Brake</span><span id="infoBrake">0%</span></div>
        <div class="info-row"><span>Fuel</span><span id="infoFuel">0 kg</span></div>
        <div class="info-row"><span>Fuel/Lap</span><span id="infoFuelPerLap">— kg</span></div>
        <div class="info-row"><span>Tire</span><span id="infoTire">100%</span></div>
        <div class="info-row"><span>Parts</span><span id="infoParts" style="cursor:pointer; text-decoration:underline dotted;" title="Click for details">100%</span></div>
        <div class="info-row"><span>Pit</span><span id="infoPit">—</span></div>
        <span id="infoGrip" style="display:none;">1.70</span>
        
        <div class="info-title" style="margin-top:6px; font-size:11px; opacity:0.6;">─ Track ─</div>
        <div class="info-row"><span>Segment</span><span id="infoSegment">---</span></div>
        <div class="info-row"><span>Weather</span><span id="infoWeather">☀ Sunny 25°C</span></div>
        <div class="info-row"><span>Track Temp</span><span id="infoTrackTemp">35°C</span></div>
        <div class="info-row"><span>Track Grip</span><span id="infoTrackGrip">100%</span></div>
        <div class="info-row"><span>Track Rubber</span><span id="infoTrackRubber">0%</span></div>
        <div class="info-row"><span>Track Wetness</span><span id="infoTrackWetness">0%</span></div>
        
        <!-- Physics Breakdown (transparent multipliers) -->
        <div class="info-title" style="margin-top:6px; font-size:11px; opacity:0.6; cursor:pointer;" id="physicsToggle">─ Physics ▾ ─</div>
        <div id="physicsBreakdown" style="font-size:10px; color:#888;">
          <div class="info-row" style="font-size:10px;"><span>Driving Mode µ</span><span id="phModeGrip">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Tire Compound</span><span id="phTireGrip">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Tire Condition</span><span id="phTireCond">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>F_rubber</span><span id="phRubber">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>F_wet</span><span id="phTireWeather">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>F_temp</span><span id="phTrackTemp">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Camber (lat/long)</span><span id="phCamber">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Parts→Power</span><span id="phPartsPower">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Parts→Grip</span><span id="phPartsGrip">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Parts→Aero</span><span id="phPartsAero">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Air Density</span><span id="phAirDensity">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Wear Mult</span><span id="phWearMult">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Mode Wear</span><span id="phModeWear">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Plat kDrag</span><span id="phPlatDrag">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Plat kAero</span><span id="phPlatAero">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Plat kGrip</span><span id="phPlatGrip">—</span></div>
          <div class="info-row" style="font-size:10px;"><span>Ride Height</span><span id="phRideH">—</span></div>
        </div>
        

        
        <!-- Hidden but kept for code compatibility -->
        <span id="infoPos" style="display:none;">0 m</span>
        <span id="infoSegRemain" style="display:none;">0 m</span>
        <span id="infoMass" style="display:none;">0 kg</span>
        <span id="infoAccel" style="display:none;">0.00 m/s²</span>
        <span id="infoVLimit" style="display:none;">—</span>
        
        <div class="info-title" style="margin-top:8px; cursor:pointer;" id="lapTimesToggle">⏱ Lap Times ▾</div>
        <div id="lapTimesList" style="max-height:150px; overflow-y:auto; font-size:11px; font-family:monospace;"></div>
      </div>
    </div>

    <footer class="footer">
      <button class="btn primary" id="startBtn">▶ START</button>
      <button class="btn" id="resetBtn">↺ RESET</button>

      <button class="btn" id="telemetryBtn">📈 TELEMETRY</button>
      <button class="btn" id="dataBtn" style="display:none;">📋 DATA</button>
      <button class="btn" id="setupBtn">⚙ SETUP</button>
      <button class="btn" id="tireBtn">🛞 TIRES</button>
      <button class="btn" id="weatherBtn">🌤 WEATHER</button>
      <button class="btn" id="camberBtn">🔧 CAMBER</button>
      <button class="btn" id="aeroBtn">🛩️ AERO</button>
      <button class="btn" id="platformBtn">📐 SUSPENSION</button>
      <button class="btn" id="sensitivityBtn" title="Sensitivity Analysis">📊 SENSITIVITY</button>

      <button class="btn warn" id="pitBtn">🟡 PIT THIS LAP</button>
      <button class="btn" id="liftCoastBtn" disabled>🌊 LIFT & COAST</button>

      <div class="speed-group" style="gap:2px;">
        <label style="font-size:10px; color:#999; margin-right:4px;">🏎 Mode:</label>
        <button class="speed-btn" data-mode="push" style="background:#c62828; color:#fff; font-size:10px; padding:2px 6px;">PUSH</button>
        <button class="speed-btn active" data-mode="normal" style="font-size:10px; padding:2px 6px;">NORMAL</button>
        <button class="speed-btn" data-mode="conserve" style="background:#2e7d32; color:#fff; font-size:10px; padding:2px 6px;">CONSERVE</button>
      </div>

      <div class="speed-group" style="gap:2px;">
        <label style="font-size:10px; color:#999; margin-right:4px;">🌤 Weather:</label>
        <select id="weatherSelect" style="background:#2a2e35; color:#ddd; border:1px solid #555; border-radius:4px; padding:2px 6px; font-size:11px;">
          <option value="sunny">☀ Sunny</option>
          <option value="cloudy">☁ Cloudy</option>
          <option value="light_rain">🌦 Light Rain</option>
          <option value="heavy_rain">🌧 Heavy Rain</option>
        </select>
        <label style="font-size:10px; color:#999; margin-left:8px;">🌡</label>
        <input type="number" id="weatherTemp" value="25" min="5" max="45" step="1" 
               style="width:42px; background:#2a2e35; color:#ddd; border:1px solid #555; border-radius:4px; padding:2px 4px; font-size:11px;">
        <span style="font-size:10px; color:#999;">°C</span>
      </div>

      <div class="speed-group">
        <button class="speed-btn" data-speed="0.25">0.25×</button>
        <button class="speed-btn" data-speed="0.5">0.5×</button>
        <button class="speed-btn active" data-speed="1">1×</button>
        <button class="speed-btn" data-speed="2">2×</button>
        <button class="speed-btn" data-speed="4">4×</button>
        <button class="speed-btn" data-speed="8">8×</button>
        <button class="speed-btn" data-speed="16">16×</button>
        <button class="speed-btn" data-speed="32">32×</button>
      </div>

      <div class="lap-display">LAP <span id="lapNum">0</span>/<span id="totalLaps">10</span></div>
    </footer>
  </div>

  <!-- Telemetry Modal -->
  <div class="modal" id="telemetryModal" aria-hidden="true">
    <div class="modal-card">
      <div class="modal-head">
        <div class="modal-title">📈 Telemetrie – V, vLimit, THR/BRK über Distanz (Zoom/Pan)</div>
        <button class="btn" id="telemetryClose">✕</button>
      </div>

      <div class="modal-controls">
        <div class="select-group">
          <label>Lap A</label>
          <select id="lapSelectA"></select>
        </div>
        <div class="select-group">
          <label>Lap B</label>
          <select id="lapSelectB"></select>
        </div>

        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <button class="btn" id="telemetryResetView">↺ View Reset</button>
        </div>

        <div class="legend">
          <span class="pill">Speed: cyan(A) / yellow(B)</span>
          <span class="pill">vLimit: white</span>
          <span class="pill">THR: green</span>
          <span class="pill">BRK: red</span>
          <span class="pill">Δt: magenta</span>
          <span class="pill">Fuel: orange</span>
          <span class="pill">B = dashed</span>
          <span class="pill" id="liveBadge">LIVE: off</span>
        </div>
      </div>

      <canvas id="telemetryCanvas" width="1100" height="520"></canvas>

      <div class="modal-foot">
        <div class="hint">
          Live-Telemetrie: wähle “Live (current lap)” in Lap A oder Lap B.
          <br/>Zoom: Mausrad | Pan: Drag | Reset: “View Reset” | DblClick: Reset
        </div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <button class="btn" id="telemetryFreeze">⏸ Freeze Live</button>
          <button class="btn" id="telemetryUnfreeze">▶ Resume Live</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Data Modal -->
  <div class="modal" id="dataModal" aria-hidden="true">
    <div class="modal-card" style="grid-template-rows:auto auto 1fr auto;">
      <div class="modal-head">
        <div class="modal-title">📋 Data – Speed, vLimit & Accel über Distanz</div>
        <button class="btn" id="dataClose">✕</button>
      </div>

      <div class="modal-controls">
        <div class="select-group">
          <label>Lap</label>
          <select id="dataLapSelect"></select>
        </div>

        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <button class="btn" id="dataCopy">📎 Copy</button>
          <button class="btn" id="dataDownloadCsv">⬇ CSV</button>
        </div>

        <div class="legend" style="margin-left:auto;">
          <span class="pill">d[m] | v[km/h] | vLimit[km/h] | a[m/s²] | thr[%] | brk[%]</span>
        </div>
      </div>

      <div style="padding:12px 16px; overflow:auto; background:rgba(255,255,255,0.02);">
        <pre id="dataOut"></pre>
      </div>

      <div class="modal-foot">
        <div class="hint">
          vLimit ist Envelope-Grenzkurve (max. zulässige Speed).
          <br/>Wenn PIT ARMED: vLimit basiert auf Pit-Entry Limit (damit das Auto nicht zu schnell in die Box fährt).
        </div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <button class="btn" id="dataRefresh">↻ Refresh</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Setup Modal -->
  <div class="modal" id="setupModal" aria-hidden="true">
    <div class="modal-card" style="grid-template-rows:auto 1fr auto;">
      <div class="modal-head">
        <div class="modal-title">⚙ Car Setup</div>
        <button class="btn" id="setupClose">✕</button>
      </div>

      <div class="setup-grid" id="setupGrid"></div>

      <div class="modal-foot">
        <div id="setupStatusBanner" style="display:none; padding:6px 12px; border-radius:6px; font-size:13px; color:#fff; text-align:center; width:100%; margin-bottom:6px;"></div>
        <div class="hint" id="setupHint">Änderungen werden beim nächsten Boxenstopp übernommen.</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <button class="btn" id="setupResetDefaults">↺ Defaults</button>
          <button class="btn" id="setupSave" title="Save current setup">💾 Save</button>
          <button class="btn" id="setupLoad" title="Load saved setup">📂 Load</button>
          <button class="btn primary" id="setupApply">✅ Apply</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Driver Skills & Skill Sensitivity Modals removed — now in Car/Driver Editor -->

  <!-- Tire Modal -->
  <div class="modal" id="tireModal" aria-hidden="true">
    <div class="modal-card" style="grid-template-rows:auto 1fr auto; max-width: 700px;">
      <div class="modal-head">
        <div class="modal-title">🛞 Tire Management</div>
        <button class="btn" id="tireClose">✕</button>
      </div>

      <div class="setup-grid" id="tireGrid" style="grid-template-columns: repeat(2, 1fr);">
        <!-- Current Compound Display -->
        <div class="field" style="grid-column: span 2;">
          <div class="lbl">Current Compound</div>
          <div style="display: flex; gap: 12px; align-items: center;">
            <div id="tireCompoundBadge" style="padding: 8px 16px; border-radius: 8px; font-weight: 900; font-size: 14px;">MEDIUM</div>
            <span id="tireCompoundInfo" style="color: var(--text-secondary); font-size: 12px;">Balanced grip and durability</span>
          </div>
        </div>

        <!-- Tire condition display -->
        <div class="field" style="grid-column: span 2;">
          <div class="lbl">Tire Condition</div>
          <div style="display: flex; align-items: center; gap: 16px;">
            <div style="flex: 1; background: var(--bg-card); border-radius: 8px; height: 24px; overflow: hidden; position: relative;">
              <div id="tireConditionBar" style="height: 100%; transition: width 0.3s;"></div>
              <!-- Optimal range markers -->
              <div id="tireOptimalMarker" style="position: absolute; top: 0; height: 100%; border-left: 2px dashed rgba(255,255,255,0.5); border-right: 2px dashed rgba(255,255,255,0.5); background: rgba(0,255,136,0.15);"></div>
            </div>
            <span id="tireConditionText" style="font-weight: 900; min-width: 70px; text-align: right;">100.0%</span>
          </div>
        </div>

        <div class="field">
          <div class="lbl">Distance Traveled</div>
          <div id="tireDistanceText" style="font-weight: 900; font-size: 16px;">0.0 km</div>
        </div>

        <div class="field">
          <div class="lbl">Current Grip</div>
          <div id="tireGripMultText" style="font-weight: 900; font-size: 16px;">100%</div>
        </div>

        <!-- Compound Comparison -->
        <div class="field" style="grid-column: span 2;">
          <div class="lbl">Compound Comparison</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-top: 8px;">
            <div id="tireSoftCard" class="tire-compound-card" style="padding: 12px; border-radius: 10px; border: 2px solid #ff4444; background: rgba(255,68,68,0.1); cursor: pointer;">
              <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: #ff4444;"></div>
                <span style="font-weight: 900; color: #ff4444;">SOFT</span>
              </div>
              <div style="font-size: 11px; color: var(--text-secondary);">
                <div>🏎️ Grip: <strong style="color: #00ff88;">+5%</strong> (optimal)</div>
                <div>⚡ Wear: <strong style="color: #ff6666;">Fast</strong></div>
                <div>📍 Optimal: 80-92%</div>
              </div>
            </div>
            <div id="tireMediumCard" class="tire-compound-card" style="padding: 12px; border-radius: 10px; border: 2px solid #ffcc00; background: rgba(255,204,0,0.1); cursor: pointer;">
              <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: #ffcc00;"></div>
                <span style="font-weight: 900; color: #ffcc00;">MEDIUM</span>
              </div>
              <div style="font-size: 11px; color: var(--text-secondary);">
                <div>🏎️ Grip: <strong style="color: #00dd77;">+2%</strong> (optimal)</div>
                <div>⚡ Wear: <strong style="color: #88ff88;">Moderate</strong></div>
                <div>📍 Optimal: 75-90%</div>
              </div>
            </div>
            <div id="tireHardCard" class="tire-compound-card" style="padding: 12px; border-radius: 10px; border: 2px solid #ffffff; background: rgba(255,255,255,0.08); cursor: pointer;">
              <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                <div style="width: 16px; height: 16px; border-radius: 50%; background: #ffffff;"></div>
                <span style="font-weight: 900; color: #ffffff;">HARD</span>
              </div>
              <div style="font-size: 11px; color: var(--text-secondary);">
                <div>🏎️ Grip: <strong style="color: #88bbff;">+1%</strong> (optimal)</div>
                <div>⚡ Wear: <strong style="color: #00ff88;">Slow</strong></div>
                <div>📍 Optimal: 60-85%</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Grip Curve Visualization -->
        <div class="field" style="grid-column: span 2;">
          <div class="lbl">Grip Curve Model</div>
          <canvas id="tireGripCurveCanvas" width="400" height="120" style="width: 100%; height: 120px; background: var(--bg-card); border-radius: 8px;"></canvas>
        </div>

        <!-- Tire Physics Curves (TireModel visualization) -->
        <div class="field" style="grid-column: span 2;">
          <div class="lbl">F_wet — Grip vs Wetness (all compounds)</div>
          <canvas id="tireFwetCanvas" width="640" height="200" style="width: 100%; height: 200px; background: var(--bg-card); border-radius: 8px;"></canvas>
        </div>
        <div class="field" style="grid-column: span 2;">
          <div class="lbl">F_temp — Grip vs Track Temp (all compounds)</div>
          <canvas id="tireFtempCanvas" width="640" height="140" style="width: 100%; height: 140px; background: var(--bg-card); border-radius: 8px;"></canvas>
        </div>
        <div class="field" style="grid-column: span 2;">
          <div class="lbl">M_wear — Wear Multiplier vs Wetness (all compounds)</div>
          <canvas id="tireMwearCanvas" width="640" height="140" style="width: 100%; height: 140px; background: var(--bg-card); border-radius: 8px;"></canvas>
        </div>

        <!-- Tire Sets Allocation -->
        <div class="field" style="grid-column: span 2;">
          <div class="lbl">Available Tire Sets</div>
          <div id="tireSetsContainer" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:6px;"></div>
        </div>
      </div>

      <div class="modal-foot">
        <div class="hint">Reifen verschleißen bei Kraftübertragung (Bremsen, Beschleunigen, Kurven). Reifenwechsel/-auswahl nur in Box möglich.</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <select id="tireCompoundSelect" style="min-width: 120px;">
            <option value="soft">🔴 Soft</option>
            <option value="medium" selected>🟡 Medium</option>
            <option value="hard">⚪ Hard</option>
            <option value="intermediate">🟢 Inter</option>
            <option value="wet">🔵 Wet</option>
          </select>
          <button class="btn primary" id="tireChange" disabled>🔧 Change Tires (Box only)</button>
        </div>
      </div>
    </div>
  </div>


  <!-- ═══ WEATHER FORECAST MODAL ═══ -->
  <div class="modal" id="weatherModal" aria-hidden="true">
    <div class="modal-card" style="max-width:600px; grid-template-rows:auto 1fr auto;">
      <div class="modal-head">
        <div class="modal-title">🌤 Weather Forecast</div>
        <button class="btn" id="weatherClose">✕</button>
      </div>
      <div style="padding:16px; overflow-y:auto;">
        <!-- Current conditions -->
        <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; margin-bottom:16px;">
          <div class="field">
            <div class="lbl">Condition</div>
            <div id="wfCurrentCond" style="font-size:18px; font-weight:700;">☀ Sunny</div>
          </div>
          <div class="field">
            <div class="lbl">Air / Track Temp</div>
            <div id="wfCurrentTemp" style="font-size:18px; font-weight:700;">25 / 35 °C</div>
          </div>
          <div class="field">
            <div class="lbl">Track Wetness</div>
            <div id="wfCurrentWet" style="font-size:18px; font-weight:700;">0%</div>
          </div>
        </div>
        <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; margin-bottom:16px;">
          <div class="field">
            <div class="lbl">Track Grip</div>
            <div id="wfTrackGrip" style="font-size:16px; font-weight:700;">100%</div>
            <div style="font-size:9px; color:#666; margin-top:2px;" id="wfGripDetail">temp · wet · rubber</div>
          </div>
          <div class="field">
            <div class="lbl">Air Density</div>
            <div id="wfDensity" style="font-size:16px; font-weight:700;">1.225 kg/m³</div>
          </div>
        </div>
        <!-- Forecast graph -->
        <div class="lbl" style="margin-bottom:8px;">Forecast (next ~15 min)</div>
        <div style="border:1px solid #333; border-radius:6px; overflow:hidden; padding:8px; background:#0d0f14;">
          <canvas id="wfForecastCanvas" width="560" height="220" style="width:100%; height:220px; display:block;"></canvas>
          <div style="display:flex; gap:16px; justify-content:center; margin-top:6px; font-size:11px; color:#aaa;">
            <span>🟠 Temperature (°C)</span>
            <span>🔵 Rain Probability (%)</span>
            <span style="color:#555">Shaded = uncertainty range</span>
          </div>
        </div>
        <div class="hint" style="margin-top:8px;">Prognose basiert auf aktuellem Wetter. Je weiter in der Zukunft, desto breiter die Unsicherheit.</div>
      </div>
      <div class="modal-foot">
        <button class="btn primary" id="weatherCloseBtn">Close</button>
      </div>
    </div>
  </div>

  <!-- ═══ PARTS MODAL ═══ -->
  <div class="modal" id="partsModal" aria-hidden="true">
    <div class="modal-card" style="max-width:560px; grid-template-rows:auto 1fr auto;">
      <div class="modal-head">
        <div class="modal-title">🔧 Assembly Parts</div>
        <button class="btn" id="partsClose">✕</button>
      </div>
      <div style="padding:16px; overflow-y:auto;">
        <!-- Performance summary -->
        <div id="partsPerfSummary" style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; margin-bottom:14px;"></div>
        <!-- Individual parts list -->
        <div id="partsDetailList" style="display:grid; gap:10px;"></div>
      </div>
      <div class="modal-foot">
        <button class="btn primary" id="partsCloseBtn">Close</button>
      </div>
    </div>
  </div>

  <!-- ═══ CAMBER MODAL ═══ -->
  <div class="modal" id="camberModal" aria-hidden="true">
    <div class="modal-card" style="grid-template-rows:auto 1fr auto; max-width: 600px;">
      <div class="modal-head">
        <div class="modal-title">🔧 Camber Setup</div>
        <button class="btn" id="camberClose">✕</button>
      </div>
      <div style="padding: 16px; overflow-y: auto;">
        <!-- Current value display -->
        <div class="field" style="margin-bottom: 16px;">
          <div class="lbl">Camber Angle</div>
          <div style="display: flex; align-items: center; gap: 16px;">
            <input type="range" id="camberSlider" min="-4" max="0" step="0.1" value="-4" style="flex: 1; accent-color: #00ff88;">
            <span id="camberValue" style="font-weight: 900; font-size: 20px; min-width: 60px; text-align: center;">-4.0°</span>
          </div>
        </div>
        <!-- Effect display -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
          <div class="field">
            <div class="lbl">🏎️ Lateral Grip (Corners)</div>
            <div id="camberLatEffect" style="font-weight: 900; font-size: 16px; color: #00ff88;">+5.0%</div>
          </div>
          <div class="field">
            <div class="lbl">📏 Longitudinal Grip (Straights)</div>
            <div id="camberLongEffect" style="font-weight: 900; font-size: 16px; color: #ff6666;">-6.0%</div>
          </div>
          <div class="field">
            <div class="lbl">⚡ Tire Wear Factor</div>
            <div id="camberWearEffect" style="font-weight: 900; font-size: 14px; color: #ffcc00;">1.20×</div>
          </div>
          <div class="field">
            <div class="lbl">🛞 Rolling Resistance</div>
            <div id="camberRREffect" style="font-weight: 900; font-size: 14px; color: #ff9944;">+0.0%</div>
          </div>
          <div class="field">
            <div class="lbl">⚖️ Trade-off Rating</div>
            <div id="camberTradeoff" style="font-weight: 900; font-size: 14px; color: #00d4ff;">BALANCED</div>
          </div>
        </div>
        <!-- Grip curve canvas -->
        <div class="field">
          <div class="lbl">Grip vs Camber Angle</div>
          <canvas id="camberCurveCanvas" width="520" height="160" style="width: 100%; height: 160px; background: var(--bg-card); border-radius: 8px;"></canvas>
        </div>
      </div>
      <div class="modal-foot">
        <div class="hint">Mehr Negativsturz = mehr Kurvengrip, aber weniger Geradeaus-Grip und höherer Reifenverschleiß.</div>
        <div style="display:flex; gap:10px;">
          <button class="btn" id="camberReset">↺ Default (-4.0°)</button>
          <button class="btn primary" id="camberApply">✅ Übernehmen</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ═══ AERO (WING ANGLE) MODAL ═══ -->
  <div class="modal" id="aeroModal" aria-hidden="true">
    <div class="modal-card" style="grid-template-rows:auto 1fr auto; max-width: 600px;">
      <div class="modal-head">
        <div class="modal-title">🛩️ Aero Setup – Wing Angle</div>
        <button class="btn" id="aeroClose">✕</button>
      </div>
      <div style="padding: 16px; overflow-y: auto;">
        <!-- Current value display -->
        <div class="field" style="margin-bottom: 16px;">
          <div class="lbl">Wing Angle</div>
          <div style="display: flex; align-items: center; gap: 16px;">
            <input type="range" id="wingSlider" min="0" max="25" step="0.1" value="10" style="flex: 1; accent-color: #00d4ff;">
            <span id="aeroValue" style="font-weight: 900; font-size: 20px; min-width: 60px; text-align: center;">12.0°</span>
          </div>
        </div>
        <!-- Effect display -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
          <div class="field">
            <div class="lbl">⬇️ Downforce Bonus</div>
            <div id="aeroLiftEffect" style="font-weight: 900; font-size: 16px; color: #00ff88;">+7.5%</div>
          </div>
          <div class="field">
            <div class="lbl">💨 Wing Drag Penalty</div>
            <div id="aeroDragEffect" style="font-weight: 900; font-size: 16px; color: #ff6666;">+8.2%</div>
          </div>
          <div class="field">
            <div class="lbl">🏎️ Top Speed Impact</div>
            <div id="aeroTopSpeedEffect" style="font-weight: 900; font-size: 14px; color: #ffcc00;">—</div>
          </div>
          <div class="field">
            <div class="lbl">⚖️ Balance</div>
            <div id="aeroBalance" style="font-weight: 900; font-size: 14px; color: #00d4ff;">BALANCED</div>
          </div>
        </div>
        <!-- Aero curve canvas -->
        <div class="field">
          <div class="lbl">Wing Lift & Drag vs Wing Angle</div>
          <canvas id="aeroCurveCanvas" width="520" height="160" style="width: 100%; height: 160px; background: var(--bg-card); border-radius: 8px;"></canvas>
        </div>
      </div>
      <div class="modal-foot">
        <div class="hint">Mehr Flügelwinkel = mehr Downforce (Kurvengrip), aber auch mehr Luftwiderstand (weniger Topspeed).</div>
        <div style="display:flex; gap:10px;">
          <button class="btn" id="aeroReset">↺ Default (10.0°)</button>
          <button class="btn primary" id="aeroApply">✅ Übernehmen</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ═══ PLATFORM (SUSPENSION) MODAL ═══ -->
  <div class="modal" id="platformModal" aria-hidden="true">
    <div class="modal-card" style="grid-template-rows:auto 1fr auto; max-width: 720px;">
      <div class="modal-head">
        <div class="modal-title">📐 Suspension Setup</div>
        <button class="btn" id="platformClose">✕</button>
      </div>
      <div style="padding: 16px; overflow-y: auto;">
        <!-- Sliders -->
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-bottom: 16px;">
          <div class="field">
            <div class="lbl">Ride Height</div>
            <input type="range" id="platformRideHeight" min="20" max="50" step="1" value="35" style="width:100%; accent-color: #00d4ff;">
            <div id="platformRhVal" style="font-weight:900; text-align:center;">35 mm</div>
          </div>
          <div class="field">
            <div class="lbl">Spring Rate</div>
            <input type="range" id="platformSpringK" min="40" max="500" step="5" value="180" style="width:100%; accent-color: #ffcc00;">
            <div id="platformSkVal" style="font-weight:900; text-align:center;">180 N/mm</div>
          </div>
          <div class="field">
            <div class="lbl">Damper</div>
            <input type="range" id="platformDamperC" min="0.1" max="20" step="0.1" value="5.5" style="width:100%; accent-color: #ff6666;">
            <div id="platformDcVal" style="font-weight:900; text-align:center;">5.5 Ns/mm</div>
          </div>
        </div>
        <!-- Summary cards -->
        <div id="platformSpeedLabel" style="text-align:center; font-size:11px; color:rgba(255,255,255,0.5); margin-bottom:4px; font-style:italic;">Click a graph to select speed</div>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 16px;">
          <div class="field" style="text-align:center;">
            <div class="lbl" style="font-size:10px;">⬇️ Aero Eff.</div>
            <div id="platformAeroVal" style="font-weight:900; font-size:16px; color:#00ff88;">100%</div>
          </div>
          <div class="field" style="text-align:center;">
            <div class="lbl" style="font-size:10px;">🏎️ Mech Grip</div>
            <div id="platformGripVal" style="font-weight:900; font-size:16px; color:#00d4ff;">100%</div>
          </div>
          <div class="field" style="text-align:center;">
            <div class="lbl" style="font-size:10px;">💨 Drag</div>
            <div id="platformDragVal" style="font-weight:900; font-size:16px; color:#ffcc00;">100%</div>
          </div>
          <div class="field" style="text-align:center;">
            <div class="lbl" style="font-size:10px;">🔥 Tyre Wear</div>
            <div id="platformWearVal" style="font-weight:900; font-size:16px; color:#ff6666;">1.00×</div>
          </div>
        </div>
        <!-- 3 Graphs -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
          <div class="field">
            <div class="lbl" style="font-size:10px;">Aero & Grip Factors vs Speed</div>
            <canvas id="platformFactorsCanvas" width="320" height="130" style="width:100%; height:130px; background:var(--bg-card); border-radius:8px;"></canvas>
          </div>
          <div class="field">
            <div class="lbl" style="font-size:10px;">Ride Height vs Speed</div>
            <canvas id="platformHeightCanvas" width="320" height="130" style="width:100%; height:130px; background:var(--bg-card); border-radius:8px;"></canvas>
          </div>
        </div>
        <div class="field">
          <div class="lbl" style="font-size:10px;">Aero Efficiency Map (Ride Height)</div>
          <canvas id="platformAeroMapCanvas" width="660" height="120" style="width:100%; height:120px; background:var(--bg-card); border-radius:8px;"></canvas>
        </div>
      </div>
      <div class="modal-foot">
        <div class="hint">Tiefere Ride Height = mehr Bodeneffekt, aber Bottoming-Risiko. Härtere Federn = weniger Schwankung, aber weniger Grip.</div>
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn" id="platformPresetLowDf" style="font-size:11px;">🏁 Low DF</button>
          <button class="btn" id="platformPresetBalanced" style="font-size:11px;">⚖ Balanced</button>
          <button class="btn" id="platformPresetHighDf" style="font-size:11px;">🔽 High DF</button>
          <button class="btn" id="platformPresetWet" style="font-size:11px;">🌧️ Wet</button>
          <button class="btn primary" id="platformApply">✅ Übernehmen</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ═══ SENSITIVITY ANALYSIS MODAL ═══ -->
  <div class="modal" id="sensitivityModal" aria-hidden="true">
    <div class="modal-card" style="grid-template-rows:auto auto 1fr auto; max-width: 1100px;">
      <div class="modal-head">
        <div class="modal-title">📊 Sensitivity Analysis</div>
        <button class="btn" id="sensitivityClose">✕</button>
      </div>
      <div style="padding:8px 16px 0; display:flex; gap:12px; align-items:center; flex-wrap:wrap; font-size:12px; color:#aaa;">
        <span>Track: <b id="saTrackName" style="color:#fff;">—</b></span>
        <span>Lap: <b id="saLapLength" style="color:#fff;">—</b></span>
        <span>Ref Lap Time: <b id="saRefTime" style="color:#00ff88; font-size:14px;">—</b></span>
        <span>Tire: <b style="color:#ff4444;">Fresh Soft</b></span>
        <span>Fuel: <b id="saFuelInfo" style="color:#ffcc00;">—</b></span>
        <button class="btn" id="saRunBtn" style="margin-left:auto; padding:4px 14px; font-size:12px;">▶ Berechnen</button>
      </div>
      <div style="padding:12px 16px; overflow-y:auto;" id="sensitivityContent">
        <table id="saTable" style="width:100%; border-collapse:collapse; font-size:12px; font-family:'JetBrains Mono',monospace;">
          <thead>
            <tr style="border-bottom:2px solid rgba(255,255,255,0.15); text-align:left;">
              <th style="padding:6px 8px; color:#aaa; width:22%;">Parameter</th>
              <th style="padding:6px 8px; color:#aaa; width:10%; text-align:center;">Default</th>
              <th style="padding:6px 8px; color:#aaa; width:8%; text-align:center;">Min</th>
              <th style="padding:6px 8px; color:#aaa; width:8%; text-align:center;">Max</th>
              <th style="padding:6px 8px; color:#aaa; width:11%; text-align:right;">Δ Min</th>
              <th style="padding:6px 8px; color:#aaa; width:11%; text-align:right;">Δ Max</th>
              <th style="padding:6px 8px; color:#aaa; width:30%;">Sensitivity</th>
            </tr>
          </thead>
          <tbody id="saTableBody"></tbody>
        </table>
        <div id="saStatus" style="padding:20px; text-align:center; color:#666; font-size:14px;">Klicke ▶ Berechnen um die Analyse zu starten.</div>
      </div>
      <div class="modal-foot">
        <div class="hint">Rundenzeit-Änderung bei Variation jedes Parameters (alle anderen = Default). Frische Soft-Reifen, konstantes Gewicht.</div>
      </div>
    </div>
  </div>

  <!-- ═══ MULTIPLAYER LOBBY OVERLAY ═══ -->
  <div id="mpLobby" class="main-menu hidden">
    <div class="mm-logo">🌐</div>
    <div class="mm-title">MULTIPLAYER</div>
    <div class="mm-sub" style="font-size:12px; color:var(--text-secondary); margin-bottom:6px;">Server-Authoritative • No AI • Player Cars Only</div>
    <div class="mm-sub" id="mpStatus">Enter a nickname to start</div>

    <div style="max-width:440px; margin:0 auto; width:100%;">
      <!-- Nickname Input -->
      <div id="mpNicknameSection" style="margin-bottom:20px;">
        <input type="text" id="mpNickname" maxlength="16" placeholder="Your Nickname..."
          style="width:100%; padding:14px 18px; font-size:18px; font-weight:700; border-radius:12px;
          border:2px solid var(--accent-cyan); background:var(--bg-card); color:#fff; text-align:center;
          outline:none; letter-spacing:1px;" />
      </div>

      <!-- Host / Join Buttons -->
      <div id="mpChoiceSection" style="display:none; gap:12px; margin-bottom:20px;">
        <div class="mm-btn primary" id="mpHostBtn" style="flex:1; justify-content:center;">
          <span class="mm-btn-icon">🖥️</span>
          <div class="mm-btn-text">
            <span class="mm-btn-label">Host Server</span>
            <span class="mm-btn-hint">Run physics simulation</span>
          </div>
        </div>
        <div class="mm-btn" id="mpJoinBtn" style="flex:1; justify-content:center;">
          <span class="mm-btn-icon">🎮</span>
          <div class="mm-btn-text">
            <span class="mm-btn-label">Join Race</span>
            <span class="mm-btn-hint">Connect to a server</span>
          </div>
        </div>
      </div>

      <!-- Join Code Input -->
      <div id="mpJoinSection" style="display:none; margin-bottom:20px;">
        <input type="text" id="mpJoinCode" maxlength="20" placeholder="Enter Lobby Code..."
          style="width:100%; padding:14px 18px; font-size:16px; font-weight:700; border-radius:12px;
          border:2px solid #ffcc00; background:var(--bg-card); color:#fff; text-align:center;
          outline:none; letter-spacing:2px; text-transform:uppercase;" />
        <div style="display:flex; gap:10px; margin-top:10px;">
          <button class="btn primary" id="mpJoinConfirm" style="flex:1; padding:12px; font-size:14px;">✓ Join</button>
          <button class="btn" id="mpJoinBack" style="flex:1; padding:12px; font-size:14px;">← Back</button>
        </div>
      </div>

      <!-- Lobby Room (after hosting/joining) -->
      <div id="mpRoomSection" style="display:none;">
        <div style="background:var(--bg-card); border-radius:12px; padding:16px; margin-bottom:16px;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
            <span style="font-weight:900; font-size:14px; color:var(--text-secondary);">LOBBY CODE</span>
            <span id="mpLobbyCode" style="font-weight:900; font-size:20px; color:var(--accent-cyan); letter-spacing:3px; cursor:pointer;" title="Click to copy">---</span>
          </div>
          <div style="font-weight:900; font-size:13px; color:var(--text-secondary); margin-bottom:8px;">
            PLAYERS (<span id="mpPlayerCount">0</span>/20)
          </div>
          <div id="mpPlayerList" style="max-height:240px; overflow-y:auto; display:flex; flex-direction:column; gap:6px;">
            <!-- Player cards inserted here -->
          </div>
        </div>

        <!-- Race Settings (Host only) -->
        <div id="mpSettingsSection" style="background:var(--bg-card); border-radius:12px; padding:16px; margin-bottom:16px;">
          <div style="font-weight:900; font-size:13px; color:var(--text-secondary); margin-bottom:10px;">RACE SETTINGS</div>
          <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
            <label style="font-size:13px;">Laps:</label>
            <input type="number" id="mpLaps" min="1" max="99" value="5"
              style="width:60px; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.15);
              background:var(--bg-panel); color:#fff; text-align:center; font-weight:700;" />
            <label style="font-size:13px;">Track:</label>
            <span id="mpTrackName" style="color:var(--accent-cyan); font-weight:700;">Speed Oval</span>
          </div>
        </div>

        <!-- Start / Leave Buttons -->
        <div style="display:flex; gap:12px;">
          <button class="btn primary" id="mpStartRace" style="flex:1; padding:14px; font-size:16px; font-weight:900; display:none;">
            🏁 START RACE
          </button>
          <button class="btn" id="mpReady" style="flex:1; padding:14px; font-size:16px; font-weight:900; display:none;">
            ✓ READY
          </button>
          <button class="btn" id="mpLeaveLobby" style="padding:14px; font-size:14px;">← Leave</button>
        </div>
      </div>
    </div>

    <div class="mm-version" style="margin-top:20px;">
      <button class="btn" id="mpBackToMenu" style="padding:10px 24px;">← Back to Menu</button>
    </div>
  </div>

  <!-- ═══ RACE FINISH / RANKING SCREEN ═══ -->
  <div id="raceFinishOverlay" class="main-menu hidden">
    <div class="mm-logo" id="rfTrophy">🏆</div>
    <div class="mm-title" id="rfTitle">RACE COMPLETE</div>
    <div class="mm-sub" id="rfSubtitle">Final Standings</div>

    <div id="rfRankingContainer" style="max-width:600px; margin:20px auto; width:100%; max-height:60vh; overflow-y:auto;">
      <!-- Ranking rows inserted dynamically -->
    </div>

    <div style="display:flex; gap:12px; justify-content:center; margin-top:20px;">
      <button class="btn primary" id="rfBackToMenu" style="padding:14px 32px; font-size:16px; font-weight:900;">
        🏠 Back to Menu
      </button>
      <button class="btn" id="rfRestartRace" style="padding:14px 32px; font-size:16px; font-weight:900;">
        🔄 Restart
      </button>
    </div>
  </div>

  <!-- ═══ OVERLAY CANVASES ═══ -->
  <canvas id="particleCanvas"></canvas>
  <div id="rainOverlay"></div>
  <div id="countdownOverlay"><div id="countdownText"></div></div>

  <script>
// ═══════════════════════════════════════════════════════════════════════
// TrackRenderer.js — Offscreen track rendering module (INLINED)
// Renders the entire track (asphalt, edges, curbs, gravel, grass,
// scenery, pit lane, start/finish) to an offscreen canvas ONCE,
// then blits it every frame via drawImage.
//
// KEY INVARIANT: Track width is ALWAYS constant (TRACK_WIDTH).
// The racing line shifts laterally through corners (both edges
// move together), but the gap between edges stays fixed.
// ═══════════════════════════════════════════════════════════════════════

const TrackRenderer = (() => {

  // ── Config ──
  // Use realistic race-track widths (typisch ~10-15 m). PX_PER_METER is scale.
  const TRACK_WIDTH     = 15; // meters (updated to requested 15m)
  const HALF_TW         = TRACK_WIDTH / 2;
  const EDGE_GAP        = 1;  // visual gap to keep from exact contact (m)
  const GRAVEL_EXTRA    = 50;
  const GRASS_EXTRA     = 20;
  const SCENERY_MARGIN  = 40;
  const PX_PER_METER    = 4;  // pixels per meter (tweak to resize visuals)

  // ── State ──
  let _offscreen   = null;
  let _offCtx      = null;
  let _bounds      = null;
  let _ready       = false;

  // ── Cached geometry ──
  let _leftEdge    = null;
  let _rightEdge   = null;
  let _points      = null;
  let _racingLine  = null;

  function quintic(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  // Compute edges using a closed uniform cubic B-spline to get C2 continuity
  function computeEdgeGeometry(Track) {
    // ── Use original Track.generatePoints() which provides segIndex, s, heading ──
    const points    = Track.generatePoints();
    const segs      = Track.segments;
    const segStarts = Track.getSegmentStarts();
    _points = points;

    const A_max = HALF_TW - EDGE_GAP;

    // Per-corner lateral shift amplitude
    const cornerInfo = [];
    for (let si = 0; si < segs.length; si++) {
      const seg = segs[si];
      if (seg.kind !== 'corner') { cornerInfo.push(null); continue; }
      const R   = seg.radius;
      const dir = seg.direction || 1;
      const dTheta = (seg.angleDeg || 0) * Math.PI / 180;
      let A = A_max;
      if (R <= HALF_TW + 2) A = Math.min(A, Math.max(0, R - 8));
      const thetaMin = (4 * HALF_TW) / R;
      if (dTheta < thetaMin) A *= (dTheta / thetaMin);
      cornerInfo.push({ A, dir });
    }

    const lateralShift = new Float64Array(points.length);
    const isCorner     = new Uint8Array(points.length);

    for (let i = 0; i < points.length; i++) {
      const p   = points[i];
      const si  = p.segIndex;
      const seg = segs[si];
      if (seg.kind === 'corner' && cornerInfo[si]) {
        const { A, dir } = cornerInfo[si];
        const segStart = segStarts[si];
        const segLen   = seg.length;
        const t = Math.max(0, Math.min(1, (p.s - segStart) / segLen));
        lateralShift[i] = A * Math.cos(2 * Math.PI * t) * dir;
        isCorner[i] = 1;
      }
    }

    // Interpolate straight sections between corners
    {
      let lastCornerExit  = 0;
      let firstCornerEntry = 0;
      for (let k = points.length - 1; k >= 0; k--) {
        if (isCorner[k]) { lastCornerExit = lateralShift[k]; break; }
      }
      for (let k = 0; k < points.length; k++) {
        if (isCorner[k]) { firstCornerEntry = lateralShift[k]; break; }
      }
      let i = 0;
      while (i < points.length) {
        if (isCorner[i]) { i++; continue; }
        const runStart = i;
        while (i < points.length && !isCorner[i]) i++;
        const runEnd = i;
        const exitShift  = runStart > 0 ? lateralShift[runStart - 1] : lastCornerExit;
        const entryShift = runEnd < points.length ? lateralShift[runEnd] : firstCornerEntry;
        const runLen = runEnd - runStart;
        if (runLen === 0) continue;
        for (let j = runStart; j < runEnd; j++) {
          const t = (j - runStart + 0.5) / runLen;
          lateralShift[j] = exitShift + (entryShift - exitShift) * t;
        }
      }
    }

    // Build left/right edges — CONSTANT radius (no lateral shift)
    const hw = HALF_TW + 1.0;   // half-width + 1m run-off margin
    _leftEdge  = new Array(points.length);
    _rightEdge = new Array(points.length);

    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const h = p.heading || 0;
      const perpX = Math.cos(h + Math.PI / 2);
      const perpY = Math.sin(h + Math.PI / 2);
      _leftEdge[i]  = { x: p.x + perpX * hw, y: p.y + perpY * hw };
      _rightEdge[i] = { x: p.x - perpX * hw, y: p.y - perpY * hw };
    }

    // Smooth edge points to eliminate kinks at straight↔curve transitions
    // 3-pass box blur on x,y coordinates (wrapped for closed track)
    for (let pass = 0; pass < 3; pass++) {
      const R = 6;
      const n = points.length;
      const tmpLx = new Float64Array(n), tmpLy = new Float64Array(n);
      const tmpRx = new Float64Array(n), tmpRy = new Float64Array(n);
      for (let i = 0; i < n; i++) {
        let slx = 0, sly = 0, srx = 0, sry = 0;
        for (let k = -R; k <= R; k++) {
          const idx = (i + k + n) % n;
          slx += _leftEdge[idx].x;  sly += _leftEdge[idx].y;
          srx += _rightEdge[idx].x; sry += _rightEdge[idx].y;
        }
        const cnt = 2 * R + 1;
        tmpLx[i] = slx / cnt; tmpLy[i] = sly / cnt;
        tmpRx[i] = srx / cnt; tmpRy[i] = sry / cnt;
      }
      for (let i = 0; i < n; i++) {
        _leftEdge[i]  = { x: tmpLx[i], y: tmpLy[i] };
        _rightEdge[i] = { x: tmpRx[i], y: tmpRy[i] };
      }
    }

    // ── Ideal line: O-I-O through corners, C2 continuous, car-width clearance ──
    const CAR_W = 2.0;  // full car width clearance from edge
    const maxLatOuter = HALF_TW * 0.5;  // outer position: ~half way between center and edge
    const maxLatInner = hw - 1.0;       // inner position: 1m from inner edge
    const maxLat = maxLatInner;          // clamp uses the larger value
    const racingLat = new Float64Array(points.length); // lateral offset from center
    const isCornerPt = new Uint8Array(points.length);

    // First pass: compute lateral offset for corners (O-I-O via sin)
    for (let i = 0; i < points.length; i++) {
      const p   = points[i];
      const si  = p.segIndex;
      const seg = segs[si];
      if (seg.kind === 'corner' && cornerInfo[si]) {
        const { dir } = cornerInfo[si];
        const segStart = segStarts[si];
        const segLen   = seg.length;
        const t = Math.max(0, Math.min(1, (p.s - segStart) / segLen));
        // O-I-O: outside at entry/exit, inside at apex (1m from inner edge)
        const bump = Math.sin(Math.PI * t);
        const outerDist = -maxLatOuter * dir;  // entry/exit: further from edge
        const innerDist =  maxLatInner * dir;  // apex: 1m from inner edge
        racingLat[i] = outerDist * (1 - bump) + innerDist * bump;
        isCornerPt[i] = 1;
      }
    }

    // Second pass: smooth interpolation on straights (Hermite, zero tangents for no overshoot)
    {
      let lastCornerLat = 0;
      let firstCornerLat = 0;
      for (let k = points.length - 1; k >= 0; k--) {
        if (isCornerPt[k]) { lastCornerLat = racingLat[k]; break; }
      }
      for (let k = 0; k < points.length; k++) {
        if (isCornerPt[k]) { firstCornerLat = racingLat[k]; break; }
      }

      let i = 0;
      while (i < points.length) {
        if (isCornerPt[i]) { i++; continue; }
        const runStart = i;
        while (i < points.length && !isCornerPt[i]) i++;
        const runEnd = i;
        const runLen = runEnd - runStart;
        if (runLen === 0) continue;

        const v0 = runStart > 0 ? racingLat[runStart - 1] : lastCornerLat;
        const v1 = runEnd < points.length ? racingLat[runEnd] : firstCornerLat;

        for (let j = runStart; j < runEnd; j++) {
          const t = (j - runStart + 0.5) / runLen;
          // Smoothstep (C1) — guaranteed monotone, no overshoot
          const sm = t * t * (3 - 2 * t);
          racingLat[j] = v0 + (v1 - v0) * sm;
        }
      }
    }

    // Clamp all lateral offsets to stay within track boundary minus car width
    for (let i = 0; i < points.length; i++) {
      racingLat[i] = Math.max(-maxLat, Math.min(maxLat, racingLat[i]));
    }

    // Gaussian smooth the lateral offsets for C1 continuity at segment transitions
    // 3 passes of box-blur approximates Gaussian
    for (let pass = 0; pass < 3; pass++) {
      const tmp = new Float64Array(points.length);
      const R = 8; // smoothing radius in sample points
      for (let i = 0; i < points.length; i++) {
        let sum = 0, cnt = 0;
        for (let k = -R; k <= R; k++) {
          const idx = (i + k + points.length) % points.length;
          sum += racingLat[idx];
          cnt++;
        }
        tmp[i] = sum / cnt;
      }
      for (let i = 0; i < points.length; i++) {
        racingLat[i] = tmp[i];
      }
    }
    // Re-clamp after smoothing
    for (let i = 0; i < points.length; i++) {
      racingLat[i] = Math.max(-maxLat, Math.min(maxLat, racingLat[i]));
    }

    // Build racing line world positions from lateral offsets
    const racingLine = new Array(points.length);
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const h = p.heading || 0;
      const perpX = Math.cos(h + Math.PI / 2);
      const perpY = Math.sin(h + Math.PI / 2);
      racingLine[i] = {
        x: p.x + perpX * racingLat[i],
        y: p.y + perpY * racingLat[i],
        s: p.s
      };
    }

    // Compute heading from actual ideal-line tangent direction (not center line)
    for (let i = 0; i < racingLine.length; i++) {
      const next = racingLine[(i + 1) % racingLine.length];
      const prev = racingLine[(i - 1 + racingLine.length) % racingLine.length];
      racingLine[i].heading = Math.atan2(next.y - prev.y, next.x - prev.x);
    }
    _racingLine = racingLine;

    return { points, leftEdge: _leftEdge, rightEdge: _rightEdge };
  }

  function computeBounds(Track) {
    const points = _points || Track.generatePoints();
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    const margin = HALF_TW + GRAVEL_EXTRA / 2 + SCENERY_MARGIN + 30;
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      minX = Math.min(minX, p.x - margin);
      maxX = Math.max(maxX, p.x + margin);
      minY = Math.min(minY, p.y - margin);
      maxY = Math.max(maxY, p.y + margin);
    }

    const pit = Track.pit;
    if (pit && pit.enabled) {
      for (let s = pit.startS; s <= pit.endS; s += 10) {
        const pp = Track.getPointPitAware(s, true);
        minX = Math.min(minX, pp.x - 20);
        maxX = Math.max(maxX, pp.x + 20);
        minY = Math.min(minY, pp.y - 20);
        maxY = Math.max(maxY, pp.y + 20);
      }
    }

    _bounds = {
      minX, minY, maxX, maxY,
      width:  maxX - minX,
      height: maxY - minY
    };
    return _bounds;
  }

  function makeRNG(seed) {
    let s = seed;
    return () => { s = (s * 16807 + 0) % 2147483647; return s / 2147483647; };
  }

  function renderToOffscreen(Track) {
    const geo       = computeEdgeGeometry(Track);
    const bounds    = computeBounds(Track);
    const points    = geo.points;
    const leftEdge  = geo.leftEdge;
    const rightEdge = geo.rightEdge;

    const segs      = Track.segments;
    const segStarts = Track.getSegmentStarts();

    const MAX_CANVAS_DIM = 8192;
    let cw = Math.ceil(bounds.width  * PX_PER_METER);
    let ch = Math.ceil(bounds.height * PX_PER_METER);
    if (cw > MAX_CANVAS_DIM || ch > MAX_CANVAS_DIM) {
      const scale = Math.min(MAX_CANVAS_DIM / cw, MAX_CANVAS_DIM / ch);
      cw = Math.floor(cw * scale);
      ch = Math.floor(ch * scale);
    }

    _offscreen = document.createElement('canvas');
    _offscreen.width  = cw;
    _offscreen.height = ch;
    _offCtx = _offscreen.getContext('2d');

    const ctx  = _offCtx;
    const zoom = PX_PER_METER;
    const panX = -bounds.minX * zoom;
    const panY = -bounds.minY * zoom;

    ctx.fillStyle = '#1a3a1a';
    ctx.fillRect(0, 0, cw, ch);

    ctx.strokeStyle = 'rgba(30,70,30,0.15)';
    ctx.lineWidth = 1;
    const gridSize = 50 * zoom;
    for (let x = 0; x < cw; x += gridSize) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, ch); ctx.stroke();
    }
    for (let y = 0; y < ch; y += gridSize) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cw, y); ctx.stroke();
    }

    drawRunOffAreas(ctx, zoom, panX, panY, points, leftEdge, rightEdge);
    drawScenery(ctx, zoom, panX, panY, Track, points);

    ctx.lineCap  = 'butt';
    ctx.lineJoin = 'round';

    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.moveTo((leftEdge[0].x + 1.5) * zoom + panX, (leftEdge[0].y + 1.5) * zoom + panY);
    for (let i = 1; i < leftEdge.length; i++)
      ctx.lineTo((leftEdge[i].x + 1.5) * zoom + panX, (leftEdge[i].y + 1.5) * zoom + panY);
    for (let i = rightEdge.length - 1; i >= 0; i--)
      ctx.lineTo((rightEdge[i].x + 1.5) * zoom + panX, (rightEdge[i].y + 1.5) * zoom + panY);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#222830';
    ctx.beginPath();
    ctx.moveTo(leftEdge[0].x * zoom + panX, leftEdge[0].y * zoom + panY);
    for (let i = 1; i < leftEdge.length; i++)
      ctx.lineTo(leftEdge[i].x * zoom + panX, leftEdge[i].y * zoom + panY);
    for (let i = rightEdge.length - 1; i >= 0; i--)
      ctx.lineTo(rightEdge[i].x * zoom + panX, rightEdge[i].y * zoom + panY);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 1.5 * zoom;
    ctx.setLineDash([8 * zoom, 14 * zoom]);
    ctx.beginPath();
    ctx.moveTo(points[0].x * zoom + panX, points[0].y * zoom + panY);
    for (let i = 1; i < points.length; i++)
      ctx.lineTo(points[i].x * zoom + panX, points[i].y * zoom + panY);
    ctx.stroke();
    ctx.setLineDash([]);



    // ── Build per-point segment lookup for extended curb ranges ──
    // Extend curbs N points into adjacent straights for smooth transitions
    const CURB_EXTEND = 12; // points to extend into straights (~24m)
    const cornerPtSet = new Uint8Array(points.length);
    for (let i = 0; i < points.length; i++) {
      if (segs[points[i].segIndex].kind === 'corner') cornerPtSet[i] = 1;
    }
    // Mark extension zones (fade-in / fade-out)
    const curbFade = new Float32Array(points.length); // 0 = no curb, 1 = full curb
    for (let i = 0; i < points.length; i++) {
      if (cornerPtSet[i]) { curbFade[i] = 1.0; continue; }
      // Check if near a corner boundary
      let minDist = CURB_EXTEND + 1;
      for (let d = 1; d <= CURB_EXTEND; d++) {
        const fwd = (i + d) % points.length;
        const bwd = (i - d + points.length) % points.length;
        if (cornerPtSet[fwd] || cornerPtSet[bwd]) { minDist = Math.min(minDist, d); break; }
      }
      if (minDist <= CURB_EXTEND) {
        // Smooth fade: 1 at corner boundary → 0 at CURB_EXTEND distance
        curbFade[i] = Math.pow(1 - minDist / CURB_EXTEND, 2);
      }
    }

    // ── Draw curbs and edge lines using the smooth fade system ──
    const kerbW = 3.5 * zoom;
    const blockLen = 4.0 * zoom;
    const edgeW = 2.5 * zoom;

    function drawKerbSection(edgePts, fadeValues, outwardSign) {
      // outwardSign: +1 = left edge (normal points outward), -1 = right edge (flip normal)
      if (edgePts.length < 2) return;
      let acc = 0;
      for (let j = 0; j < edgePts.length - 1; j++) {
        const ax = edgePts[j].x * zoom + panX;
        const ay = edgePts[j].y * zoom + panY;
        const bx = edgePts[j + 1].x * zoom + panX;
        const by = edgePts[j + 1].y * zoom + panY;
        const dx = bx - ax, dy = by - ay;
        const sLen = Math.sqrt(dx * dx + dy * dy);
        const blockIdx = Math.floor(acc / blockLen);
        acc += sLen;

        const nx = (-dy / (sLen || 1)) * outwardSign;
        const ny = ( dx / (sLen || 1)) * outwardSign;

        // Fade: average of the two endpoints
        const fade = (fadeValues[j] + fadeValues[j + 1]) * 0.5;
        if (fade < 0.01) continue; // skip invisible curb sections

        const curW = kerbW * fade; // narrow the curb in fade zone
        const isRed = blockIdx % 2 === 0;
        const col1 = isRed ? '#d42020' : '#f0f0f0';
        const col2 = isRed ? '#f0f0f0' : '#d42020';

        ctx.fillStyle = col1;
        ctx.globalAlpha = fade;
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(bx, by);
        ctx.lineTo(bx + nx * curW * 0.5, by + ny * curW * 0.5);
        ctx.lineTo(ax + nx * curW * 0.5, ay + ny * curW * 0.5);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = col2;
        ctx.beginPath();
        ctx.moveTo(ax + nx * curW * 0.5, ay + ny * curW * 0.5);
        ctx.lineTo(bx + nx * curW * 0.5, by + ny * curW * 0.5);
        ctx.lineTo(bx + nx * curW, by + ny * curW);
        ctx.lineTo(ax + nx * curW, ay + ny * curW);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1.0;
      }
      // border along edge
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      let started = false;
      for (let j = 0; j < edgePts.length; j++) {
        if (fadeValues[j] < 0.01) { started = false; continue; }
        const px = edgePts[j].x * zoom + panX;
        const py = edgePts[j].y * zoom + panY;
        if (!started) { ctx.moveTo(px, py); started = true; }
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
    }

    // Collect all edge points with their fade values
    const allLeftFade = [], allRightFade = [];
    for (let i = 0; i < points.length; i++) {
      allLeftFade.push(curbFade[i]);
      allRightFade.push(curbFade[i]);
    }

    // Draw curbs globally (not per-segment) for seamless transitions
    drawKerbSection(leftEdge, allLeftFade, 1);    // left edge: normal already points outward
    drawKerbSection(rightEdge, allRightFade, -1); // right edge: flip normal to point outward

    // ── White edge lines on straight sections (where no curbs) ──
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = edgeW;
    ctx.lineCap = 'round';
    // Left edge
    let inLine = false;
    ctx.beginPath();
    for (let i = 0; i < points.length; i++) {
      if (curbFade[i] > 0.3) { inLine = false; continue; } // skip curb areas
      const px = leftEdge[i].x * zoom + panX;
      const py = leftEdge[i].y * zoom + panY;
      if (!inLine) { ctx.moveTo(px, py); inLine = true; }
      else ctx.lineTo(px, py);
    }
    ctx.stroke();
    // Right edge
    inLine = false;
    ctx.beginPath();
    for (let i = 0; i < points.length; i++) {
      if (curbFade[i] > 0.3) { inLine = false; continue; }
      const px = rightEdge[i].x * zoom + panX;
      const py = rightEdge[i].y * zoom + panY;
      if (!inLine) { ctx.moveTo(px, py); inLine = true; }
      else ctx.lineTo(px, py);
    }
    ctx.stroke();


    for (let si = 1; si < segStarts.length; si++) {
      const bp = Track.getPointCorrected(segStarts[si]);
      const bx = bp.x * zoom + panX;
      const by = bp.y * zoom + panY;
      const h  = bp.heading || 0;
      const hw = (TRACK_WIDTH / 2) * zoom;
      const px = Math.cos(h + Math.PI / 2);
      const py = Math.sin(h + Math.PI / 2);

      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth   = 1.5 * zoom;
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.moveTo(bx - px * hw, by - py * hw);
      ctx.lineTo(bx + px * hw, by + py * hw);
      ctx.stroke();
    }

    drawPitLane(ctx, zoom, panX, panY, Track);

    const sfp = Track.getPointCorrected(Track.startLineS);
    const sfx = sfp.x * zoom + panX;
    const sfy = sfp.y * zoom + panY;
    ctx.save();
    ctx.translate(sfx, sfy);
    ctx.rotate(sfp.heading + Math.PI / 2);
    const lineW    = TRACK_WIDTH * zoom;
    const checkSz  = lineW / 8;
    for (let row = 0; row < 2; row++) {
      for (let col = 0; col < 8; col++) {
        ctx.fillStyle = (row + col) % 2 === 0 ? '#fff' : '#000';
        ctx.fillRect(-lineW / 2 + col * checkSz, -checkSz + row * checkSz, checkSz, checkSz);
      }
    }
    ctx.restore();

    _ready = true;
  }

  function drawRunOffAreas(ctx, zoom, panX, panY, points, leftEdge, rightEdge) {
    const layers = [
      { extra: GRAVEL_EXTRA / 2, color: '#3a3520' },
      { extra: GRASS_EXTRA  / 2, color: '#2a5a2a' }
    ];

    for (const layer of layers) {
      const outerLeft  = [];
      const outerRight = [];

      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        const h = p.heading || 0;
        const px = Math.cos(h + Math.PI / 2);
        const py = Math.sin(h + Math.PI / 2);

        outerLeft.push({
          x: leftEdge[i].x + px * layer.extra,
          y: leftEdge[i].y + py * layer.extra
        });
        outerRight.push({
          x: rightEdge[i].x - px * layer.extra,
          y: rightEdge[i].y - py * layer.extra
        });
      }

      ctx.fillStyle = layer.color;
      ctx.beginPath();
      ctx.moveTo(outerLeft[0].x * zoom + panX, outerLeft[0].y * zoom + panY);
      for (let i = 1; i < outerLeft.length; i++)
        ctx.lineTo(outerLeft[i].x * zoom + panX, outerLeft[i].y * zoom + panY);
      for (let i = outerRight.length - 1; i >= 0; i--)
        ctx.lineTo(outerRight[i].x * zoom + panX, outerRight[i].y * zoom + panY);
      ctx.closePath();
      ctx.fill();
    }
  }

  function drawScenery(ctx, zoom, panX, panY, Track, points) {
    const rand = makeRNG(42);
    const segStarts = Track.getSegmentStarts();

    for (let i = 0; i < points.length; i += 8) {
      const p = points[i];
      const h = p.heading || 0;
      for (let side = -1; side <= 1; side += 2) {
        const dist = 40 + rand() * 60;
        const nx = Math.cos(h + Math.PI / 2) * dist * side;
        const ny = Math.sin(h + Math.PI / 2) * dist * side;
        if (rand() < 0.5) {
          const tx = (p.x + nx) * zoom + panX;
          const ty = (p.y + ny) * zoom + panY;
          const sz = 3 + rand() * 5;
          const shade = rand() * 0.3;
          ctx.fillStyle = `rgba(60,40,20,${0.6 + shade})`;
          ctx.beginPath();
          ctx.arc(tx, ty, Math.max(1, 0.8 * zoom), 0, Math.PI * 2);
          ctx.fill();
          const g = 80 + shade * 100 | 0;
          ctx.fillStyle = `rgba(${30 + shade * 30 | 0},${g},${20 + shade * 20 | 0},0.7)`;
          ctx.beginPath();
          ctx.arc(tx, ty, Math.max(2, sz * zoom), 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    const grandstandSegs = [0, 6, 18];
    for (const si of grandstandSegs) {
      if (si >= segStarts.length) continue;
      const seg = Track.segments[si];
      if (seg.kind !== 'straight') continue;
      const midS = segStarts[si] + seg.length * 0.5;
      const p = Track.getPointCorrected(midS);
      const h = p.heading || 0;
      const side = si === 0 ? 1 : -1;
      const dist = HALF_TW + 35;
      const sx = (p.x + Math.cos(h + Math.PI / 2) * dist * side) * zoom + panX;
      const sy = (p.y + Math.sin(h + Math.PI / 2) * dist * side) * zoom + panY;
      const gLen = Math.min(seg.length * 0.6, 300) * zoom;
      const gDep = 18 * zoom;

      ctx.save();
      ctx.translate(sx, sy);
      ctx.rotate(h);
      const grad = ctx.createLinearGradient(0, -gDep / 2, 0, gDep / 2);
      grad.addColorStop(0, '#3a3a4a');
      grad.addColorStop(0.5, '#4a4a5a');
      grad.addColorStop(1, '#2a2a3a');
      ctx.fillStyle = grad;
      ctx.fillRect(-gLen / 2, -gDep / 2, gLen, gDep);
      ctx.fillStyle = '#555568';
      ctx.fillRect(-gLen / 2, -gDep / 2 - 3 * zoom, gLen, 3 * zoom);
      ctx.fillStyle = 'rgba(255,200,50,0.3)';
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < Math.floor(gLen / (5 * zoom)); c++) {
          ctx.fillRect(-gLen / 2 + c * 5 * zoom + zoom, -gDep / 3 + r * 4 * zoom, 2.5 * zoom, 2 * zoom);
        }
      }
      ctx.restore();
    }

    const pit = Track.pit;
    if (pit && pit.enabled) {
      const pitMid = (pit.startS + pit.endS) / 2;
      const pp = Track.getPointCorrected(pitMid);
      const ph = pp.heading || 0;
      const pDist = HALF_TW + 55;
      const pbx = (pp.x + Math.cos(ph + Math.PI / 2) * pDist * -1) * zoom + panX;
      const pby = (pp.y + Math.sin(ph + Math.PI / 2) * pDist * -1) * zoom + panY;

      ctx.save();
      ctx.translate(pbx, pby);
      ctx.rotate(ph);
      const bW = 400 * zoom, bD = 20 * zoom;
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(-bW / 2 + 2 * zoom, -bD / 2 + 2 * zoom, bW, bD);
      ctx.fillStyle = '#2a2a35';
      ctx.fillRect(-bW / 2, -bD / 2, bW, bD);
      ctx.fillStyle = 'rgba(255,255,200,0.15)';
      const wSz = 3 * zoom;
      for (let wx = -bW / 2 + 4 * zoom; wx < bW / 2 - 4 * zoom; wx += 6 * zoom)
        for (let wy = -bD / 2 + 3 * zoom; wy < bD / 2 - 3 * zoom; wy += 5 * zoom)
          ctx.fillRect(wx, wy, wSz, wSz * 0.8);
      ctx.restore();
    }

    const sfP = Track.getPointCorrected(Track.startLineS);
    const sfH = sfP.heading || 0;
    const tDist = HALF_TW + 45;
    const twx = (sfP.x + Math.cos(sfH + Math.PI / 2) * tDist) * zoom + panX;
    const twy = (sfP.y + Math.sin(sfH + Math.PI / 2) * tDist) * zoom + panY;
    ctx.save();
    ctx.translate(twx, twy);
    ctx.rotate(sfH);
    const tW = 25 * zoom, tD = 15 * zoom;
    ctx.fillStyle = '#3a3a4a';
    ctx.fillRect(-tW / 2, -tD / 2, tW, tD);
    ctx.fillStyle = '#5a5a6a';
    ctx.fillRect(-tW / 2 - 2 * zoom, -tD / 2 - 3 * zoom, tW + 4 * zoom, 3 * zoom);
    ctx.fillStyle = 'rgba(0,200,255,0.4)';
    ctx.fillRect(-tW / 2 + 2 * zoom, -tD / 3, tW - 4 * zoom, tD * 0.35);
    ctx.fillStyle = '#ff4444';
    ctx.fillRect(tW / 2 - zoom, -tD / 2 - 12 * zoom, 1.5 * zoom, 10 * zoom);
    ctx.fillRect(tW / 2, -tD / 2 - 12 * zoom, 6 * zoom, 3 * zoom);
    ctx.restore();

    const bldgs = [
      { segIdx: 9,  dist: 80, side:  1 },
      { segIdx: 3,  dist: 70, side: -1 },
      { segIdx: 15, dist: 65, side: -1 }
    ];
    for (const bp of bldgs) {
      if (bp.segIdx >= segStarts.length) continue;
      const seg = Track.segments[bp.segIdx];
      const midS = segStarts[bp.segIdx] + seg.length * 0.5;
      const p = Track.getPointCorrected(midS);
      const h = p.heading || 0;
      const bx = (p.x + Math.cos(h + Math.PI / 2) * bp.dist * bp.side) * zoom + panX;
      const by = (p.y + Math.sin(h + Math.PI / 2) * bp.dist * bp.side) * zoom + panY;

      ctx.save();
      ctx.translate(bx, by);
      ctx.rotate(h);
      const bW = (20 + rand() * 30) * zoom;
      const bD = (12 + rand() * 15) * zoom;
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(-bW / 2 + 2 * zoom, -bD / 2 + 2 * zoom, bW, bD);
      ctx.fillStyle = `rgb(${35 + rand() * 20 | 0}, ${35 + rand() * 20 | 0}, ${45 + rand() * 20 | 0})`;
      ctx.fillRect(-bW / 2, -bD / 2, bW, bD);
      ctx.fillStyle = 'rgba(255,255,200,0.15)';
      const ws = 3 * zoom;
      for (let wx = -bW / 2 + 4 * zoom; wx < bW / 2 - 4 * zoom; wx += 6 * zoom)
        for (let wy = -bD / 2 + 3 * zoom; wy < bD / 2 - 3 * zoom; wy += 5 * zoom)
          ctx.fillRect(wx, wy, ws, ws * 0.8);
      ctx.restore();
    }
  }

  function drawPitLane(ctx, zoom, panX, panY, Track) {
    const pit = Track.pit;
    if (!pit || !pit.enabled) return;

    const step = 2;
    const pitPts = [];
    for (let s = pit.startS; s <= pit.endS; s += step) {
      pitPts.push(Track.getPointPitAware(s, true));
    }

    ctx.strokeStyle = 'rgba(0,212,255,0.14)';
    ctx.lineWidth   = (TRACK_WIDTH * 0.55) * zoom;
    ctx.lineCap     = 'round';
    ctx.lineJoin    = 'round';
    ctx.beginPath();
    ctx.moveTo(pitPts[0].x * zoom + panX, pitPts[0].y * zoom + panY);
    for (let i = 1; i < pitPts.length; i++)
      ctx.lineTo(pitPts[i].x * zoom + panX, pitPts[i].y * zoom + panY);
    ctx.stroke();

    ctx.strokeStyle = 'rgba(0,212,255,0.32)';
    ctx.lineWidth   = 2 * zoom;
    ctx.beginPath();
    ctx.moveTo(pitPts[0].x * zoom + panX, pitPts[0].y * zoom + panY);
    for (let i = 1; i < pitPts.length; i++)
      ctx.lineTo(pitPts[i].x * zoom + panX, pitPts[i].y * zoom + panY);
    ctx.stroke();

    const trkEntry = Track.getPointCorrected(pit.startS);
    const pitEntry = Track.getPointPitAware(pit.startS, true);
    ctx.strokeStyle = 'rgba(255,255,100,0.4)';
    ctx.lineWidth   = 2 * zoom;
    ctx.setLineDash([4 * zoom, 4 * zoom]);
    ctx.beginPath();
    ctx.moveTo(trkEntry.x * zoom + panX, trkEntry.y * zoom + panY);
    ctx.lineTo(pitEntry.x * zoom + panX, pitEntry.y * zoom + panY);
    ctx.stroke();

    const trkExit = Track.getPointCorrected(pit.endS);
    const pitExit = Track.getPointPitAware(pit.endS, true);
    ctx.beginPath();
    ctx.moveTo(pitExit.x * zoom + panX, pitExit.y * zoom + panY);
    ctx.lineTo(trkExit.x * zoom + panX, trkExit.y * zoom + panY);
    ctx.stroke();
    ctx.setLineDash([]);

    const limStart = Track.getPointPitAware(pit.limiterStartS, true);
    const limEnd   = Track.getPointPitAware(pit.limiterEndS, true);
    ctx.fillStyle = 'rgba(255,100,100,0.7)';
    ctx.beginPath();
    ctx.arc(limStart.x * zoom + panX, limStart.y * zoom + panY, Math.max(2, 3 * zoom), 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(limEnd.x * zoom + panX, limEnd.y * zoom + panY, Math.max(2, 3 * zoom), 0, Math.PI * 2);
    ctx.fill();

    const ps = Track.getPointPitAware(pit.stopS, true);
    ctx.fillStyle = 'rgba(255,215,0,0.9)';
    ctx.beginPath();
    ctx.arc(ps.x * zoom + panX, ps.y * zoom + panY, Math.max(3, 4 * zoom), 0, Math.PI * 2);
    ctx.fill();
  }

    return {
      TRACK_WIDTH,

      build(Track) {
        _ready = false;
        renderToOffscreen(Track);
      },

      draw(ctx, zoom, panX, panY) {
        if (!_ready || !_offscreen || !_bounds) return;

        const scale = zoom / PX_PER_METER;
        const dx = _bounds.minX * zoom + panX;
        const dy = _bounds.minY * zoom + panY;

        ctx.drawImage(
          _offscreen,
          0, 0, _offscreen.width, _offscreen.height,
          dx, dy,
          _offscreen.width * scale,
          _offscreen.height * scale
        );
      },

      get ready() { return _ready; },

      invalidate() {
        _ready     = false;
        _offscreen = null;
        _offCtx    = null;
        _leftEdge  = null;
        _rightEdge = null;
        _racingLine = null;
        _bounds    = null;
      },

      getEdges() {
        return { leftEdge: _leftEdge, rightEdge: _rightEdge, points: _points, racingLine: _racingLine };
      },

      /** Return ideal-line world position {x, y, heading} for a given s (arc-length).
       *  Linearly interpolates between sampled points for smooth results. */
      getIdealLinePos(s) {
        if (!_racingLine || !_points || _points.length < 2) return null;
        const pts = _points;
        const n = pts.length;
        const totalLen = pts[n - 1].s;
        if (!totalLen || totalLen <= 0) return null;
        // Wrap s into [0, totalLen)
        s = ((s % totalLen) + totalLen) % totalLen;
        // Binary search for bracket
        let lo = 0, hi = n - 1;
        while (lo < hi - 1) {
          const mid = (lo + hi) >> 1;
          if (pts[mid].s <= s) lo = mid; else hi = mid;
        }
        const a = _racingLine[lo];
        const b = _racingLine[hi];
        if (!a || !b) return null;
        const ds = (pts[hi].s - pts[lo].s) || 1;
        const t = Math.max(0, Math.min(1, (s - pts[lo].s) / ds));
        return {
          x: a.x + (b.x - a.x) * t,
          y: a.y + (b.y - a.y) * t,
          heading: a.heading + (b.heading - a.heading) * t
        };
      }
    };

})();
  </script>
  <script>
    // ═══════════════════════════════════════════════════════════════════════════════
    // DEBUG: PAGE RELOAD DETECTIVE — survives reload via sessionStorage
    // ═══════════════════════════════════════════════════════════════════════════════
    (function() {
      const LOG_KEY = '__racemod_debug_log';
      const STATE_KEY = '__racemod_state';
      const MAX_LOG = 80;

      // ── Persistent log (survives reload) ──
      window._debugLog = function(msg) {
        const ts = new Date().toISOString().slice(11, 23);
        const entry = `[${ts}] ${msg}`;
        console.log('%c[DEBUG] ' + msg, 'color: #0ff; font-weight: bold');
        try {
          const arr = JSON.parse(sessionStorage.getItem(LOG_KEY) || '[]');
          arr.push(entry);
          if (arr.length > MAX_LOG) arr.splice(0, arr.length - MAX_LOG);
          sessionStorage.setItem(LOG_KEY, JSON.stringify(arr));
        } catch(e) { /* storage full */ }
      };

      // ── On page load: check if we RELOADED during a race ──
      const prevState = sessionStorage.getItem(STATE_KEY);
      const prevLog = JSON.parse(sessionStorage.getItem(LOG_KEY) || '[]');
      if (prevState === 'RACING') {
        console.warn('%c🔴 PAGE RELOADED WHILE RACING! Previous debug log:', 'color:red;font-size:16px;font-weight:bold');
        prevLog.forEach(l => console.warn('  ', l));
        // Also show as an overlay alert the user can see
        setTimeout(() => {
          const banner = document.createElement('div');
          banner.style.cssText = 'position:fixed;top:0;left:0;right:0;z-index:99999;background:#c00;color:#fff;padding:12px 20px;font:bold 14px monospace;white-space:pre-wrap;max-height:50vh;overflow:auto;cursor:pointer;';
          banner.textContent = '🔴 PAGE RELOADED DURING RACE!\nClick to dismiss. Last ' + prevLog.length + ' debug entries:\n\n' + prevLog.join('\n');
          banner.onclick = () => banner.remove();
          document.body.prepend(banner);
        }, 100);
      }
      _debugLog('Page loaded. Previous state: ' + (prevState || 'none'));
      sessionStorage.setItem(STATE_KEY, 'EDITOR');

      // ── Track when we enter racing state ──
      window._debugSetRacing = function() {
        sessionStorage.setItem(STATE_KEY, 'RACING');
        _debugLog('State → RACING');
      };

      // ── beforeunload: fires right before page leaves ──
      window.addEventListener('beforeunload', function(e) {
        _debugLog('⚠️ beforeunload fired! Page is about to unload/reload.');
        // Capture stack trace if possible
        try { throw new Error('beforeunload-stack'); } catch(stackErr) {
          _debugLog('  Stack: ' + stackErr.stack.split('\n').slice(1, 4).join(' | '));
        }
      });

      // ── pagehide: fires when tab is being discarded/crashed ──
      window.addEventListener('pagehide', function(e) {
        _debugLog('⚠️ pagehide fired! persisted=' + e.persisted);
      });

      // ── Heartbeat: detect if JS execution stops (OOM/crash) ──
      let _heartbeatCount = 0;
      let _heartbeatInterval = null;
      window._startHeartbeat = function() {
        if (_heartbeatInterval) return;
        _heartbeatInterval = setInterval(() => {
          _heartbeatCount++;
          // Log every 30s to avoid spam, but always keep counter
          if (_heartbeatCount % 30 === 0) {
            const mem = performance.memory ? 
              `JSHeap: ${(performance.memory.usedJSHeapSize / 1048576).toFixed(1)}MB / ${(performance.memory.jsHeapSizeLimit / 1048576).toFixed(1)}MB` : 
              'memory API unavailable';
            _debugLog(`Heartbeat #${_heartbeatCount} — ${mem}`);
          }
        }, 1000);
      };

      // ── Performance monitor: detect memory pressure ──
      window._checkPerformance = function() {
        if (performance.memory) {
          const used = performance.memory.usedJSHeapSize;
          const limit = performance.memory.jsHeapSizeLimit;
          const pct = (used / limit * 100).toFixed(1);
          if (used / limit > 0.85) {
            _debugLog(`🔴 MEMORY CRITICAL: ${pct}% (${(used/1048576).toFixed(1)}MB / ${(limit/1048576).toFixed(1)}MB)`);
          }
        }
      };

      // ── MutationObserver: watch trackEditorOverlay for visibility changes ──
      window._watchOverlay = function() {
        const overlay = document.getElementById('trackEditorOverlay');
        if (!overlay) { _debugLog('⚠️ trackEditorOverlay not found!'); return; }
        
        const observer = new MutationObserver((mutations) => {
          for (const m of mutations) {
            if (m.attributeName === 'class') {
              const hasHidden = overlay.classList.contains('hidden');
              _debugLog(`trackEditorOverlay class changed → hidden=${hasHidden}, classes="${overlay.className}"`);
              if (!hasHidden) {
                // Overlay became VISIBLE — this is the "back to editor" event!
                _debugLog('🔴 OVERLAY BECAME VISIBLE! Capturing stack...');
                try { throw new Error('overlay-visible-stack'); } catch(stackErr) {
                  _debugLog('  Stack: ' + stackErr.stack.split('\n').slice(1, 5).join(' | '));
                }
              }
            }
          }
        });
        observer.observe(overlay, { attributes: true, attributeFilter: ['class'] });
        _debugLog('MutationObserver active on trackEditorOverlay');

        // Also watch mainApp display
        const mainApp = document.getElementById('mainApp');
        if (mainApp) {
          const appObserver = new MutationObserver(() => {
            _debugLog(`mainApp style.display changed → "${mainApp.style.display}"`);
          });
          appObserver.observe(mainApp, { attributes: true, attributeFilter: ['style'] });
          _debugLog('MutationObserver active on mainApp');
        }
      };

    })();

    // ═══════════════════════════════════════════════════════════════════════════════
    // GLOBAL ERROR HANDLER — prevents browser tab crash/reload
    // ═══════════════════════════════════════════════════════════════════════════════
    window.onerror = function(msg, url, line, col, error) {
      _debugLog(`GlobalError: ${msg} at L${line}:${col}`);
      console.error(`[GlobalError] ${msg} at ${line}:${col}`, error);
      return true; // Prevent default browser error handling (page crash)
    };
    window.addEventListener('unhandledrejection', function(e) {
      _debugLog(`UnhandledRejection: ${e.reason}`);
      console.error('[UnhandledRejection]', e.reason);
      e.preventDefault();
    });

    // ═══════════════════════════════════════════════════════════════════════════════
    // CONSTANTS
    // ═══════════════════════════════════════════════════════════════════════════════
    const SIM_DT = 0.01;
    const GRAVITY = 9.81;

    // ═══════════════════════════════════════════════════════════════════════════════
    // WEATHER SYSTEM — Temperature, Precipitation, Track Conditions
    // ═══════════════════════════════════════════════════════════════════════════════
    // Weather affects:
    //   - Air density (temperature dependent)
    //   - Track grip (wetness, temperature)
    //   - Tire µ (compound-specific wet/dry performance)
    //   - Visibility (rain intensity)
    //   - Tire compound legality (inters/wets only in rain)
    // ═══════════════════════════════════════════════════════════════════════════════
    const Weather = {
      // ── Current conditions ──
      airTemp: 25,              // °C ambient temperature
      trackTemp: 35,            // °C track surface temperature (asphalt absorbs heat)
      condition: 'sunny',       // 'sunny' | 'cloudy' | 'light_rain' | 'heavy_rain'
      wetness: 0.0,             // 0.0 = bone dry, 1.0 = fully saturated
      rainIntensity: 0.0,       // 0.0 = no rain, 1.0 = monsoon
      humidity: 0.45,           // 0-1 relative humidity
      windSpeed: 5,             // m/s (affects drag slightly)

      // ── Derived values (recomputed each update) ──
      airDensity: 1.225,        // kg/m³ — f(temp, humidity, altitude)
      trackGripFactor: 1.0,     // Overall track grip multiplier from weather
      trackRubberLevel: 0.0,    // 0-1 rubber build-up (washed away by rain)

      // ── Weather change tracking ──
      _lastUpdateTime: 0,
      _targetCondition: 'sunny',
      _transitionProgress: 1.0,  // 0-1, 1 = arrived at target

      // Compute air density from thermodynamic model
      // ρ = p / (R_specific × T)
      // Humid air is LESS dense (water vapor is lighter than N₂/O₂)
      computeAirDensity() {
        const T_kelvin = this.airTemp + 273.15;
        const p = 101325; // sea level Pa
        const R_dry = 287.05; // J/(kg·K)
        const R_vapor = 461.5;

        // Saturation vapor pressure (Tetens formula)
        const e_sat = 610.78 * Math.exp((17.27 * this.airTemp) / (this.airTemp + 237.3));
        const e_vapor = this.humidity * e_sat;
        const p_dry = p - e_vapor;

        this.airDensity = (p_dry / (R_dry * T_kelvin)) + (e_vapor / (R_vapor * T_kelvin));
        return this.airDensity;
      },

      // Track temperature model (dynamic):
      // Track surface absorbs solar radiation and slowly approaches a target temp.
      // Air temp is only an input — track temp reacts with thermal inertia.
      // Sunny: target ~12°C above air, Cloudy: ~5°C, Rain: cools toward air temp.
      _trackTempTarget: 37,
      computeTrackTemp(dt) {
        const sunBonus = this.condition === 'sunny' ? 12 :
                         this.condition === 'cloudy' ? 5 :
                         this.condition === 'light_rain' ? 2 : 0;
        // Rain actively cools the surface
        const rainCooling = this.wetness * 4;
        this._trackTempTarget = this.airTemp + sunBonus - rainCooling;
        // Thermal inertia: track temp moves slowly toward target (~200s time constant)
        if (dt && dt > 0) {
          const rate = 0.005; // 1/s — ~200s to reach 63% of delta (slow adaptation)
          this.trackTemp += (this._trackTempTarget - this.trackTemp) * rate * dt;
        } else {
          this.trackTemp = this._trackTempTarget; // instant on init
        }
        return this.trackTemp;
      },

      // Track grip from wetness, temperature, and rubber buildup
      // Returns combined factor AND stores individual breakdowns for UI transparency
      gripBreakdown: { temp: 1.0, wet: 1.0, rubber: 1.0 },
      computeTrackGrip() {
        // Temperature factor: optimal at ~40°C track surface, falls off outside
        const tOpt = 40;
        const tSigma = 25;
        const tDiff = this.trackTemp - tOpt;
        const tempFactor = 0.92 + 0.08 * Math.exp(-(tDiff * tDiff) / (2 * tSigma * tSigma));

        // Wetness factor: grip drops with water (0% wet = 1.0, 100% wet = 0.40)
        const wetFactor = 1.0 - this.wetness * 0.60;

        // Rubber level bonus (0-8% extra grip from rubber build-up)
        const rubberFactor = 1.0 + this.trackRubberLevel * 0.08;

        // Store breakdown for transparency UI
        this.gripBreakdown = { temp: tempFactor, wet: wetFactor, rubber: rubberFactor };

        this.trackGripFactor = tempFactor * wetFactor * rubberFactor;
        return this.trackGripFactor;
      },

      // Wetness dynamics: changes based on rain intensity
      // Rain adds water, evaporation removes it
      updateWetness(dt) {
        // Rain adds wetness (very slow — track adapts gradually over many laps)
        const rainRate = this.rainIntensity * 0.003; // 0.003 per second at full intensity (slow adaptation)
        // Evaporation removes wetness (slow, realistic)
        const evapBase = this.condition === 'sunny' ? 0.0004 : 0.00012;  // slow evaporation
        const tempBonus = Math.max(0, (this.trackTemp - 15) * 0.00001);  // marginal temp effect
        const windBonus = this.windSpeed * 0.00003;                       // marginal wind effect
        const evapRate = evapBase + tempBonus + windBonus;

        this.wetness = Math.max(0, Math.min(1, this.wetness + (rainRate - evapRate) * dt));

        // Rubber build-up: accumulates on dry track, washed by rain
        // More cars = faster rubber buildup (each car lays down rubber)
        if (this.wetness < 0.2) {
          const numCars = (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) ? MultiCarRace.cars.length : 1;
          const rubberRate = 0.00015 * Math.sqrt(numCars); // scales with √cars
          this.trackRubberLevel = Math.min(1, this.trackRubberLevel + rubberRate * dt);
        } else {
          this.trackRubberLevel = Math.max(0, this.trackRubberLevel - this.wetness * 0.008 * dt);
        }
      },

      // Set rain intensity from condition
      _syncRainFromCondition() {
        switch (this.condition) {
          case 'sunny':      this.rainIntensity = 0; break;
          case 'cloudy':     this.rainIntensity = 0; break;
          case 'light_rain': this.rainIntensity = 0.3; break;
          case 'heavy_rain': this.rainIntensity = 0.8; break;
        }
      },

      // Set weather condition (for UI / career mode)
      setCondition(cond) {
        this.condition = cond;
        this._syncRainFromCondition();
      },

      // ── Per-step compound cache (computed once per Weather.update) ──
      // Avoids recalculating TireModel functions at every grip lookup.
      _compoundCache: {},

      // Full update (call each physics step or less frequently)
      update(dt) {
        // Apply weather timeline if active
        if (this._timelineActive && typeof Simulation !== 'undefined') {
          const wp = this._evaluateTimeline(Simulation.time);
          if (wp) {
            this.condition = wp.condition;
            this.airTemp = wp.airTemp;
          }
        }
        this._syncRainFromCondition();
        this.updateWetness(dt);
        this.computeAirDensity();
        this.computeTrackTemp(dt);
        this.computeTrackGrip();
        
        // Pre-compute TireModel factors for all compounds (cache for this step)
        const r = this.trackRubberLevel;
        const w = this.wetness;
        const T = this.trackTemp;
        const cache = {};
        for (const compound of ['soft', 'medium', 'hard', 'intermediate', 'wet']) {
          cache[compound] = {
            gripFactor: TireModel.getGripFactor(compound, r, w, T),
            wearMult:   TireModel.getWearMultiplier(compound, r, w, T),
            F_rubber:   TireModel.F_rubber(compound, r),
            F_wet:      TireModel.F_wet(compound, w),
            F_temp:     TireModel.F_temp(compound, T)
          };
        }
        this._compoundCache = cache;
      },

      // ── Cached compound grip factor (replaces trackGripFactor * getTireWeatherFactor) ──
      // Returns the combined F_rubber · F_wet · F_temp for a compound
      getCompoundGripFactor(compound) {
        const c = this._compoundCache[compound];
        return c ? c.gripFactor : 1.0;
      },

      // ── Cached compound wear multiplier (replaces getTireWearWeatherFactor) ──
      getCompoundWearMult(compound) {
        const c = this._compoundCache[compound];
        return c ? c.wearMult : 1.0;
      },

      // ── Individual factors for UI transparency ──
      getCompoundFactors(compound) {
        return this._compoundCache[compound] || { gripFactor: 1, wearMult: 1, F_rubber: 1, F_wet: 1, F_temp: 1 };
      },

      // Legacy: getTireWeatherFactor → now uses TireModel
      getTireWeatherFactor(compound) {
        return this.getCompoundGripFactor(compound);
      },

      // Legacy: getTireWearWeatherFactor → now uses TireModel
      getTireWearWeatherFactor(compound) {
        return this.getCompoundWearMult(compound);
      },

      // ═══════════════════════════════════════════════════════════════
      // WEATHER TIMELINE — Pre-race weather schedule
      // Array of { time (minutes), condition, airTemp }
      // Between waypoints the conditions are interpolated
      // ═══════════════════════════════════════════════════════════════
      _timeline: [],      // Array<{ time: number(min), condition: string, airTemp: number }>
      _timelineActive: false,

      setTimeline(waypoints) {
        // Sort by time ascending
        this._timeline = waypoints.slice().sort((a, b) => a.time - b.time);
        this._timelineActive = this._timeline.length > 0;
      },

      clearTimeline() {
        this._timeline = [];
        this._timelineActive = false;
      },

      // Evaluate timeline at given race time (seconds)
      _evaluateTimeline(raceTimeSec) {
        const tl = this._timeline;
        if (tl.length === 0) return null;

        const tMin = raceTimeSec / 60; // convert to minutes

        // Before first waypoint: use first
        if (tMin <= tl[0].time) {
          return { condition: tl[0].condition, airTemp: tl[0].airTemp };
        }

        // After last waypoint: use last
        if (tMin >= tl[tl.length - 1].time) {
          return { condition: tl[tl.length - 1].condition, airTemp: tl[tl.length - 1].airTemp };
        }

        // Find surrounding waypoints and interpolate
        for (let i = 0; i < tl.length - 1; i++) {
          if (tMin >= tl[i].time && tMin < tl[i + 1].time) {
            const t = (tMin - tl[i].time) / (tl[i + 1].time - tl[i].time); // 0-1

            // Temperature: linear interpolation
            const airTemp = tl[i].airTemp + t * (tl[i + 1].airTemp - tl[i].airTemp);

            // Condition: map to rain intensity, interpolate, then pick closest
            const condToIntensity = { sunny: 0, cloudy: 0.15, light_rain: 0.45, heavy_rain: 0.85 };
            const i0 = condToIntensity[tl[i].condition] || 0;
            const i1 = condToIntensity[tl[i + 1].condition] || 0;
            const intensity = i0 + t * (i1 - i0);

            // Map intensity back to condition string
            let condition;
            if (intensity < 0.08) condition = 'sunny';
            else if (intensity < 0.30) condition = 'cloudy';
            else if (intensity < 0.65) condition = 'light_rain';
            else condition = 'heavy_rain';

            return { condition, airTemp };
          }
        }

        return null;
      },

      // Reset to clear weather
      reset() {
        this.airTemp = 25;
        this.condition = 'sunny';
        this.wetness = 0.0;
        this.rainIntensity = 0.0;
        this.humidity = 0.45;
        this.windSpeed = 5;
        this.trackRubberLevel = 0.0;
        this.computeAirDensity();
        this.computeTrackTemp();
        this.computeTrackGrip();
      }
    };

    // Initialize weather derived values
    Weather.computeAirDensity();
    Weather.computeTrackTemp();
    Weather.computeTrackGrip();

    // Dynamic air density — always use Weather.airDensity
    const AIR_DENSITY_REF = 1.225; // reference for static calculations
    // Helper to get current air density (from weather system)
    function getAirDensity() { return Weather.airDensity; }
    // Backward-compatible: AIR_DENSITY is used ~50 times — keep as mutable
    let AIR_DENSITY = 1.225;

    // closer to 1 => later braking, higher risk (safety margin on max decel)
    // Rückwärts-Euler ist optimistisch: b(v)/v sinkt bei mittleren v → dv überschätzt.
    // 4% Marge kompensiert Integrationsfehler + ENVELOPE_EPS Detektionsverzögerung.
    const BRAKE_SAFETY = 0.96;  // 4% margin: backward Euler integration error + detection delay

    // Envelope discretization (meters)
    const ENVELOPE_DS = 0.75;

    // Tiny overshoot margin (m/s) to allow late "kiss" of boundary
    const ENVELOPE_EPS = 0.15;

    // Rebuild envelope periodically to track fuel/mass changes
    const ENVELOPE_REBUILD_PERIOD = 0.50;

    // In-pit braking "aim speed" near zero at box (m/s)
    const PIT_BOX_V_AIM = 0.15;

    // ═══════════════════════════════════════════════════════════════════════════════
    // TIRE PHYSICS - DEGRESSIVE FRICTION MODEL
    // ═══════════════════════════════════════════════════════════════════════════════
    // Real tires have DEGRESSIVE friction: as normal load increases,
    // friction coefficient decreases. This is why:
    // - Heavy cars don't corner as fast as light cars (relative to weight)
    // - Downforce doesn't scale linearly with cornering speed
    // - Weight transfer hurts overall grip
    //
    // Model: F_tire = µ * Fz^TIRE_LOAD_SENSITIVITY
    // - At TIRE_LOAD_SENSITIVITY = 1.0: linear (F = µ * Fz)
    // - At TIRE_LOAD_SENSITIVITY = 0.9: degressive (realistic)
    // - At TIRE_LOAD_SENSITIVITY = 0.85: very degressive (worn tires)
    //
    // Reference load for normalization (typical F1 corner: ~15kN per tire)
    // ═══════════════════════════════════════════════════════════════════════════════
    const TIRE_LOAD_SENSITIVITY = 0.97;  // Exponent: F_tire = µ * Fz^α (< 1 = degressive)
    const TIRE_REFERENCE_LOAD = 15000;  // Reference load in N (unused, kept for documentation)
    
    // ── Helper: Analytische Kurvengeschwindigkeit mit F = µ * Fz^0.98 ──
    // 2-Schritt-Verfahren: 1) Lineares v berechnen, 2) Load-Sensitivity-Korrektur
    function calcCornerSpeed(mu, m, r, Cl, A, rho) {
      const g = GRAVITY;
      const halfRhoClA = 0.5 * rho * Cl * A;
      
      // Step 1: Analytische Lösung mit linearem Reifenmodell (F = µ·Fz)
      const denom = m / r - mu * halfRhoClA;
      const vLin = denom <= 0 ? 200 : Math.sqrt(mu * m * g / denom);
      const v0 = Math.min(vLin, 200);
      
      // Step 2: Load-Sensitivity-Korrektur bei v0
      // Fz bei v0 berechnen, dann F_grip = µ * Fz^0.98
      const Fz = m * g + halfRhoClA * v0 * v0;
      const F_grip = mu * Math.pow(Fz, TIRE_LOAD_SENSITIVITY);
      // v² = F_grip * r / m
      const v = Math.sqrt(Math.max(0, F_grip * r / m));
      
      return Math.min(Math.max(v, 5), 200);
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // TRACK
    // ═══════════════════════════════════════════════════════════════════════════════
    const Track = {
      name: "Speed Oval",

      // Closed oval circuit: 2×600m + 2×1200m straights connected by 4×90° left turns
      // Net turn: 4 × 90° = 360° ✓
      segments: [
        // ═══ Speed Oval – ~4.1 km, designed for close slipstream racing ═══
        { kind: 'straight', length: 600,  name: 'Start/Finish Straight',  roughAmp: 0.001, roughLambda: 4.0 },
        { kind: 'corner',   angleDeg: 90,  radius: 80,  direction: 1, name: 'T1 – Turn 1',     roughAmp: 0.002, roughLambda: 3.0, roughPhase: 0.0 },
        { kind: 'straight', length: 1200, name: 'Back Straight',          roughAmp: 0.001, roughLambda: 4.0 },
        { kind: 'corner',   angleDeg: 90,  radius: 80,  direction: 1, name: 'T2 – Turn 2',     roughAmp: 0.002, roughLambda: 3.0, roughPhase: 0.8 },
        { kind: 'straight', length: 600,  name: 'Short Straight',         roughAmp: 0.001, roughLambda: 4.0 },
        { kind: 'corner',   angleDeg: 90,  radius: 80,  direction: 1, name: 'T3 – Turn 3',     roughAmp: 0.002, roughLambda: 3.0, roughPhase: 1.6 },
        { kind: 'straight', length: 1200, name: 'Pit Straight',           roughAmp: 0.001, roughLambda: 4.0 },
        { kind: 'corner',   angleDeg: 90,  radius: 80,  direction: 1, name: 'T4 – Turn 4',     roughAmp: 0.002, roughLambda: 3.0, roughPhase: 2.4 },
      ],

      totalLaps: 8,
      startLineS: 300,
      gripMultiplier: 1.0,  // Track surface grip: 0.85=wet, 1.0=dry, 1.05=rubbered
      
      // Sectors divide the track into 3 timing sections
      // Sector boundaries as fractions of lap length (0.0 to 1.0)
      sectors: [
        { start: 0.0, end: 0.333, name: 'S1' },    // Sector 1: 0% - 33.3%
        { start: 0.333, end: 0.666, name: 'S2' },  // Sector 2: 33.3% - 66.6%
        { start: 0.666, end: 1.0, name: 'S3' }     // Sector 3: 66.6% - 100%
      ],
      
      // Get sector number (1, 2, or 3) for a given position
      getSector(s) {
        const normalized = this.normalize(s);
        const fraction = normalized / this.lapLength;
        if (fraction < 0.333) return 1;
        if (fraction < 0.666) return 2;
        return 3;
      },
      
      // Get sector boundary positions in meters
      getSectorBoundaries() {
        return [
          0,                          // S1 start
          this.lapLength * 0.333,     // S2 start
          this.lapLength * 0.666,     // S3 start
          this.lapLength              // Finish
        ];
      },

      pit: {
        enabled: true,
        startS: 30,         // Pit entry at very start of Hauptgerade
        stopS: 550,         // Pit box (service position) mid-Hauptgerade
        endS: 1090,         // Pit exit at very end of Hauptgerade (before T1)

        offset: -25,        // 25m away from track centerline (fully separated)
        speedLimit: 60 / 3.6,

        // Speed limiter only enforced between these S positions
        // Cars enter parallel lane at startS, brake before limiterStartS,
        // speed limit through box area, accelerate after limiterEndS,
        // rejoin track at endS (corner entry)
        limiterStartS: 200,   // Limiter zone begins (after entry braking)
        limiterEndS: 850,     // Limiter zone ends (accelerate to rejoin before T1)

        // kept but no longer used to restrict "pit this lap" button
        armWindowBeforeStartFinish: 180,
        entryCommitWindow: 8,
        speedTolerance: 1.06,
        boxStopTolerance: 1.0
      },

      _lapLength: null,
      _segmentStarts: null,
      _points: null,

      // Auto-compute arc length for corner segments defined with angleDeg
      _segmentsInitialized: false,
      _initSegments() {
        if (this._segmentsInitialized) return;
        for (const seg of this.segments) {
          if (seg.kind === 'corner' && seg.angleDeg !== undefined && !seg._lengthComputed) {
            seg.length = Math.abs(seg.radius) * seg.angleDeg * Math.PI / 180;
            seg._lengthComputed = true;
          }
        }
        // Invalidate caches once
        this._lapLength = null;
        this._segmentStarts = null;
        this._points = null;
        this._closureError = null;
        this._trackRotation = null;
        this._segmentsInitialized = true;
      },

      get lapLength() {
        this._initSegments();
        if (!this._lapLength) this._lapLength = this.segments.reduce((sum, s) => sum + s.length, 0);
        return this._lapLength;
      },

      getSegmentStarts() {
        this._initSegments();
        if (!this._segmentStarts) {
          this._segmentStarts = [];
          let acc = 0;
          for (const seg of this.segments) {
            this._segmentStarts.push(acc);
            acc += seg.length;
          }
        }
        return this._segmentStarts;
      },

      normalize(s) {
        const len = this.lapLength;
        return ((s % len) + len) % len;
      },

      atPosition(s) {
        s = this.normalize(s);
        const starts = this.getSegmentStarts();
        for (let i = this.segments.length - 1; i >= 0; i--) {
          if (s >= starts[i]) {
            return { segment: this.segments[i], index: i, offset: s - starts[i], start: starts[i] };
          }
        }
        return { segment: this.segments[0], index: 0, offset: s, start: 0 };
      },

      forwardDistance(fromS, toS) {
        fromS = this.normalize(fromS);
        toS = this.normalize(toS);
        if (toS >= fromS) return toS - fromS;
        return (this.lapLength - fromS) + toS;
      },

      didCrossLine(prevS, newS, lineS) {
        const a = this.normalize(prevS);
        const b = this.normalize(newS);
        const ds = this.forwardDistance(a, b);
        const dToLine = this.forwardDistance(a, lineS);
        return (dToLine > 0 && dToLine <= ds + 1e-9);
      },

      getPoint(s) {
        s = this.normalize(s);
        let x = 0, y = 0, heading = 0;
        let accumulated = 0;

        for (let i = 0; i < this.segments.length; i++) {
          const seg = this.segments[i];
          const segEnd = accumulated + seg.length;
          const distInSeg = Math.min(s - accumulated, seg.length);

          if (distInSeg <= 0) break;

          if (seg.kind === 'straight') {
            const d = Math.min(distInSeg, seg.length);
            x += Math.cos(heading) * d;
            y += Math.sin(heading) * d;
          } else {
            const r = seg.radius;
            const dir = seg.direction || 1; // 1 = left, -1 = right
            const arcLength = Math.min(distInSeg, seg.length);
            const angle = (arcLength / r) * dir;

            const perp = heading + (Math.PI / 2) * dir;
            const cx = x + Math.cos(perp) * r;
            const cy = y + Math.sin(perp) * r;

            const startAngle = heading - (Math.PI / 2) * dir;
            x = cx + Math.cos(startAngle + angle) * r;
            y = cy + Math.sin(startAngle + angle) * r;
            heading += angle;
          }

          if (s <= segEnd) break;
          accumulated = segEnd;
        }

        return { x, y, heading };
      },

      getPointPitAware(s, inPit) {
        const p = this.getPointCorrected(s);
        if (!this.pit.enabled || !inPit) return p;

        const ss = this.normalize(s);
        const inPitRange = (ss >= this.pit.startS && ss <= this.pit.endS);
        if (!inPitRange) return p;

        const nx = Math.cos(p.heading + Math.PI / 2);
        const ny = Math.sin(p.heading + Math.PI / 2);
        return { x: p.x + nx * this.pit.offset, y: p.y + ny * this.pit.offset, heading: p.heading };
      },

      // Compute closure error (end point vs start point) for correction
      _closureError: null,
      getClosureError() {
        if (this._closureError) return this._closureError;
        this._initSegments();
        // Trace all segments to find where the end point lands
        let x = 0, y = 0, heading = 0;
        for (const seg of this.segments) {
          if (seg.kind === 'straight') {
            x += Math.cos(heading) * seg.length;
            y += Math.sin(heading) * seg.length;
          } else {
            const r = seg.radius;
            const dir = seg.direction || 1;
            const angle = (seg.length / r) * dir;
            const perp = heading + (Math.PI / 2) * dir;
            const cx = x + Math.cos(perp) * r;
            const cy = y + Math.sin(perp) * r;
            const startAngle = heading - (Math.PI / 2) * dir;
            x = cx + Math.cos(startAngle + angle) * r;
            y = cy + Math.sin(startAngle + angle) * r;
            heading += angle;
          }
        }
        this._closureError = { dx: x, dy: y };
        return this._closureError;
      },

      // Corrected getPoint that distributes closure error linearly
      // Also applies rotation correction so Hauptgerade stays horizontal
      _trackRotation: null,
      getTrackRotation() {
        if (this._trackRotation !== null) return this._trackRotation;
        const err = this.getClosureError();
        const L = this.lapLength;
        // The linear correction tilts heading by approx atan2(-err.dy/L, 1-err.dx/L)
        // Counter-rotate to keep Hauptgerade horizontal
        this._trackRotation = -Math.atan2(-err.dy, L - err.dx);
        return this._trackRotation;
      },
      
      getPointCorrected(s) {
        const raw = this.getPoint(s);
        const err = this.getClosureError();
        const L = this.lapLength;
        const frac = this.normalize(s) / L;
        // Apply linear closure correction
        let x = raw.x - err.dx * frac;
        let y = raw.y - err.dy * frac;
        // Rotate everything so Hauptgerade is truly horizontal
        const rot = this.getTrackRotation();
        const cosR = Math.cos(rot);
        const sinR = Math.sin(rot);
        const rx = x * cosR - y * sinR;
        const ry = x * sinR + y * cosR;
        // Compute corrected heading from tangent of the corrected path
        // Raw tangent: (cos(h), sin(h)). Closure correction shifts it by (-err.dx/L, -err.dy/L).
        const rawCos = Math.cos(raw.heading);
        const rawSin = Math.sin(raw.heading);
        const corrCos = rawCos - err.dx / L;
        const corrSin = rawSin - err.dy / L;
        // Apply rotation to tangent vector
        const tX = corrCos * cosR - corrSin * sinR;
        const tY = corrCos * sinR + corrSin * cosR;
        return {
          x: rx,
          y: ry,
          heading: Math.atan2(tY, tX)
        };
      },

      generatePoints(step = 2) {
        this._initSegments();
        if (this._points) return this._points;
        this._points = [];
        for (let s = 0; s <= this.lapLength; s += step) {
          const p = this.getPointCorrected(s);
          const segInfo = this.atPosition(s);
          this._points.push({ ...p, s, segment: segInfo.segment, segIndex: segInfo.index });
        }
        return this._points;
      }
    };

    Track.getNextCorner = function (s) {
      s = this.normalize(s);
      const starts = this.getSegmentStarts();
      const currentSeg = this.atPosition(s);

      if (currentSeg.segment.kind === 'corner') {
        return { found: true, segment: currentSeg.segment, distance: 0, start: currentSeg.start, cornerIndex: currentSeg.index };
      }

      let dist = currentSeg.segment.length - currentSeg.offset;
      for (let i = 1; i < this.segments.length; i++) {
        const idx = (currentSeg.index + i) % this.segments.length;
        const seg = this.segments[idx];
        if (seg.kind === 'corner') {
          return { found: true, segment: seg, distance: dist, start: starts[idx], cornerIndex: idx };
        }
        dist += seg.length;
      }
      return { found: false };
    };

    // Distance before pit entry where button should be disabled
    const PIT_DISABLE_DISTANCE_BEFORE = 300;

    // ═══════════════════════════════════════════════════════════════════════════════
    // CAR CONFIG + DEFAULTS
    // ═══════════════════════════════════════════════════════════════════════════════
    const CarDefaults = {
      mass: 800,
      fuelCapacity: 110,
      power: 750000,
      cLWing: 1.575,       // Wing lift coefficient (wing portion of downforce)
      cLDiffuser: 1.925,   // Diffuser lift coefficient (ground effect portion)
      cDBody: 0.400,       // Body/chassis drag coefficient (affected by suspension)
      cDWing: 0.450,       // Wing drag coefficient (affected by wing angle, L/D ~3.5)
      cRr: 0.015,          // Rolling resistance coefficient (0.010-0.020 for slicks)
      frontalArea: 1.8,
      tireGrip: 1.5,
      brakeForce: 35000,
      camber: -4.0,        // Camber angle in degrees (negative = top inward)
      wingAngle: 12.0,     // Wing angle in degrees (0-25)
      
      // Suspension setup (Platform model)
      rideHeight: 0.035,   // Ride height in meters (35mm default)
      springK: 180000,     // Spring stiffness N/m (180 N/mm) - realistic race car
      damperC: 5500,       // Damper coefficient N·s/m (5.5 kN·s/m) - ~46% critical damping

      color: '#e94560',
      teamColor: '#1e3a8a',
      number: 1
    };
    const CarConfig = structuredClone(CarDefaults);

    // ═══════════════════════════════════════════════════════════════════════════════
    // TIRE MODEL - Compound-based with force-dependent wear
    // ═══════════════════════════════════════════════════════════════════════════════
    
    // Tire compound definitions
    const TireCompounds = {
      soft: {
        name: 'Soft',
        color: '#ff4444',
        baseGrip: 1.0,           // Grip multiplier at 100% condition
        wearRate: 0.0007,        // Wear per unit of force-distance (higher = wears faster)
        minGripFactor: 0.60,     // Grip at 0% condition
        optimalConditionLow: 80,
        optimalConditionHigh: 92,
        optimalGripBonus: 1.05   // 5% bonus in optimal window
      },
      medium: {
        name: 'Medium',
        color: '#ffcc00',
        baseGrip: 0.97,          // Slightly less grip than soft (narrower gap)
        wearRate: 0.00045,       // ~64% of soft wear rate
        minGripFactor: 0.75,     // Better degradation curve
        optimalConditionLow: 75,
        optimalConditionHigh: 90,
        optimalGripBonus: 1.02   // 2% bonus in optimal window
      },
      hard: {
        name: 'Hard',
        color: '#ffffff',
        baseGrip: 0.94,          // Less grip than medium (narrower gap)
        wearRate: 0.00025,       // ~36% of soft wear rate
        minGripFactor: 0.82,     // Very durable degradation curve
        optimalConditionLow: 60,
        optimalConditionHigh: 85,
        optimalGripBonus: 1.01   // 1% bonus in optimal window
      },
      intermediate: {
        name: 'Inter',
        color: '#44cc44',
        baseGrip: 0.88,          // Less dry grip than hard
        wearRate: 0.0006,        // Moderate wear
        minGripFactor: 0.65,
        optimalConditionLow: 70,
        optimalConditionHigh: 90,
        optimalGripBonus: 1.02
      },
      wet: {
        name: 'Wet',
        color: '#4488ff',
        baseGrip: 0.80,          // Even less dry grip
        wearRate: 0.0010,        // High wear on dry surfaces
        minGripFactor: 0.55,
        optimalConditionLow: 65,
        optimalConditionHigh: 88,
        optimalGripBonus: 1.03
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // TIRE PHYSICS MODEL — Compound-specific grip & wear multipliers
    // ═══════════════════════════════════════════════════════════════════════════════
    //
    // µ(c,r,w,T) = µ_max(c) · F_rubber(c,r) · F_wet(c,w) · F_temp(c,T)
    // Wear(c,r,w,T) = WearBase(c,wear%) · M_wear(c,r,w,T)
    //
    // All factors are multipliers on your existing baselines.
    // ═══════════════════════════════════════════════════════════════════════════════
    const TireModel = {
      // ── Sigmoid helper ──
      _sig(x) { return 1 / (1 + Math.exp(-x)); },

      // ── Per-compound parameters ──
      _params: {
        soft:         { d0: 0.027, gamma: 1.9, Topt: 26, aCold: 1.00, aHot: 1.30, wearRubber: 0.10, wearTemp: 0.16 },
        medium:       { d0: 0.040, gamma: 1.8, Topt: 30, aCold: 1.15, aHot: 1.15, wearRubber: 0.14, wearTemp: 0.13 },
        hard:         { d0: 0.050, gamma: 1.7, Topt: 34, aCold: 1.30, aHot: 1.00, wearRubber: 0.20, wearTemp: 0.11 },
        intermediate: { d0: 0.033, gamma: 1.8, Topt: 22, aCold: 1.05, aHot: 1.05, wearRubber: 0.12, wearTemp: 0.12 },
        wet:          { d0: 0.033, gamma: 1.8, Topt: 18, aCold: 1.05, aHot: 1.15, wearRubber: 0.12, wearTemp: 0.13 }
      },

      // Slick wet parameters
      _slickWet: {
        soft:   { mid: 0.205, k: 22, min: 0.05 },
        medium: { mid: 0.195, k: 24, min: 0.04 },
        hard:   { mid: 0.185, k: 26, min: 0.03 }
      },

      // Inter wet parameters
      _interWet: {
        floor: 0.30,
        wUp: 0.11, kUp: 20,
        wDn: 0.58, kDn: 14,
        wPull: 0.70, kPull: 16,
        minHeavy: 0.40
      },

      // Wet compound parameters
      _wetWet: {
        floor: 0.20, w0: 0.48, k: 13, maxRain: 0.97
      },

      // Pre-computed b(c) for F_temp scaling (max 2% penalty in 10-45°C range)
      _bTemp: {},

      // ── Init: pre-compute b(c) so F_temp max penalty = 2% in [10,45] ──
      init() {
        for (const [compound, p] of Object.entries(this._params)) {
          let Pmax = 0;
          for (let T = 10; T <= 45; T += 0.5) {
            const cold = Math.max(0, p.Topt - T);
            const hot  = Math.max(0, T - p.Topt);
            const penalty = p.aCold * cold * cold + p.aHot * hot * hot;
            if (penalty > Pmax) Pmax = penalty;
          }
          this._bTemp[compound] = Pmax > 0 ? 0.02 / Pmax : 0;
        }
      },

      // ════════════════════════════════════════════════════════════════════
      // 1) F_rubber(c, r): Tire vs Track Rubber/Grip (max ~5% effect)
      //    Soft is better on green track, at full rubber all converge to 1.0
      // ════════════════════════════════════════════════════════════════════
      F_rubber(compound, rubberLevel) {
        const p = this._params[compound] || this._params.medium;
        return Math.max(0, Math.min(1, 1 - p.d0 * Math.pow(1 - rubberLevel, p.gamma)));
      },

      // ════════════════════════════════════════════════════════════════════
      // 2) F_wet(c, w): Tire vs Track Wetness (large effect allowed)
      //    Slicks: logistic cliff at 15-20% wetness
      //    Inter: peak at light/medium rain, pulls down in heavy
      //    Wet: rises late, stays strong in heavy rain
      // ════════════════════════════════════════════════════════════════════
      F_wet(compound, wetness) {
        const w = wetness;
        const sig = this._sig;

        // Slicks
        if (compound === 'soft' || compound === 'medium' || compound === 'hard') {
          const s = this._slickWet[compound];
          return s.min + (1 - s.min) * sig(-s.k * (w - s.mid));
        }

        // Inter
        if (compound === 'intermediate') {
          const p = this._interWet;
          const up   = sig(p.kUp * (w - p.wUp));
          const dn   = sig(-p.kDn * (w - p.wDn));
          const peak = up * dn;
          const gPeak = p.floor + (1 - p.floor) * peak;
          const pull  = sig(p.kPull * (w - p.wPull));
          return (1 - pull) * gPeak + pull * p.minHeavy;
        }

        // Wet
        if (compound === 'wet') {
          const p = this._wetWet;
          return p.floor + (p.maxRain - p.floor) * sig(p.k * (w - p.w0));
        }

        // Fallback
        return 1.0 - w * 0.45;
      },

      // ════════════════════════════════════════════════════════════════════
      // 3) F_temp(c, T): Tire vs Track Temperature (max ~2% effect)
      //    Asymmetric cold/hot penalty, scaled so worst case = 0.98
      // ════════════════════════════════════════════════════════════════════
      F_temp(compound, trackTemp) {
        const p = this._params[compound] || this._params.medium;
        const b = this._bTemp[compound] || 0;
        const cold = Math.max(0, p.Topt - trackTemp);
        const hot  = Math.max(0, trackTemp - p.Topt);
        return 1 - b * (p.aCold * cold * cold + p.aHot * hot * hot);
      },

      // ════════════════════════════════════════════════════════════════════
      // COMBINED GRIP FACTOR: F_rubber · F_wet · F_temp
      // This replaces Weather.getTireWeatherFactor + Weather.trackGripFactor
      // ════════════════════════════════════════════════════════════════════
      getGripFactor(compound, rubberLevel, wetness, trackTemp) {
        return this.F_rubber(compound, rubberLevel) *
               this.F_wet(compound, wetness) *
               this.F_temp(compound, trackTemp);
      },

      // ════════════════════════════════════════════════════════════════════
      // 4) M_wear: Wear multiplier (on existing wear curve)
      //    Based on stress functions for rubber, temp, wetness mismatch
      // ════════════════════════════════════════════════════════════════════

      // Stress: rubber
      _S_rubber(rubberLevel) {
        return Math.pow(1 - rubberLevel, 2);
      },

      // Stress: temperature vs compound optimum
      _S_temp(compound, trackTemp) {
        const p = this._params[compound] || this._params.medium;
        const diff = (trackTemp - p.Topt) / 10;
        return diff * diff;
      },

      // Stress: wet mismatch
      _S_wet(compound, wetness) {
        const w = wetness;
        if (compound === 'soft' || compound === 'medium' || compound === 'hard') {
          // Slicks scrub in rain
          return 0.10 * Math.pow(w, 1.5);
        }
        if (compound === 'intermediate') {
          // Too wet or too dry
          return 0.06 * Math.pow(Math.max(0, w - 0.75), 2) +
                 0.05 * Math.pow(Math.max(0, 0.08 - w), 2);
        }
        if (compound === 'wet') {
          // Too dry
          return 0.05 * Math.pow(Math.max(0, 0.35 - w), 2);
        }
        return 0;
      },

      // Combined wear multiplier (>=1.0)
      getWearMultiplier(compound, rubberLevel, wetness, trackTemp) {
        const p = this._params[compound] || this._params.medium;
        const Sr = this._S_rubber(rubberLevel);
        const St = this._S_temp(compound, trackTemp);
        const Sw = this._S_wet(compound, wetness);
        return Math.max(1, 1 + p.wearRubber * 0.8 * Sr + p.wearTemp * 0.8 * St + Sw);
      },

      // ════════════════════════════════════════════════════════════════════
      // DRIVING MODE MULTIPLIERS
      // Push:     100% µ, 125% wear
      // Normal:   98% µ, 110% wear
      // Conserve: 95% µ, 100% wear
      // ════════════════════════════════════════════════════════════════════
      _drivingModes: {
        push:     { gripMult: 1.00, wearMult: 1.25 },
        normal:   { gripMult: 0.98, wearMult: 1.10 },
        conserve: { gripMult: 0.95, wearMult: 1.00 }
      },

      getDrivingModeGrip(mode) {
        return (this._drivingModes[mode] || this._drivingModes.normal).gripMult;
      },

      getDrivingModeWear(mode) {
        return (this._drivingModes[mode] || this._drivingModes.normal).wearMult;
      }
    };

    // Initialize TireModel b(c) scaling
    TireModel.init();

    const Tire = {
      condition: 100,           // 0-100%
      distanceTraveled: 0,      // meters since last tire change
      compound: 'medium',       // Current compound type
      forceAccumulator: 0,      // Accumulated lateral/longitudinal force for wear calc
      reset() {
        this.condition = 100;
        this.distanceTraveled = 0;
        this.forceAccumulator = 0;
      },
      
      getCompound() {
        return TireCompounds[this.compound] || TireCompounds.medium;
      },
      
      // Update tire wear based on grip UTILIZATION (not raw force)
      // gripUtilization: 0-1 ratio of USED grip vs AVAILABLE grip at the tire
      // This models: when engine/brakes are the limit (not tires), wear is low
      // When tires are at the limit (cornering, traction-limited accel), wear is high
      // deltaS: distance traveled this step
      update(deltaS, gripUtilization) {
        this.distanceTraveled += deltaS;
        
        // Wear model: utilization^1.4 (compromise between linear and quadratic)
        const compound = this.getCompound();
        const utilizationFactor = Math.pow(gripUtilization, 1.4);
        const wearAmount = deltaS * utilizationFactor * compound.wearRate;
        this.condition = Math.max(0, this.condition - wearAmount);
      },
      
      // Get current grip multiplier based on tire condition and compound
      getGripMultiplier() {
        const c = this.condition;
        const comp = this.getCompound();
        
        // Check if in optimal range
        if (c >= comp.optimalConditionLow && c <= comp.optimalConditionHigh) {
          return comp.baseGrip * comp.optimalGripBonus;
        }
        
        // Above optimal (fresh tires): slight reduction
        if (c > comp.optimalConditionHigh) {
          const t = (c - comp.optimalConditionHigh) / (100 - comp.optimalConditionHigh);
          return comp.baseGrip * (1.0 - t * 0.03); // Max 3% reduction for brand new
        }
        
        // Below optimal (worn tires): linear degradation
        const t = c / comp.optimalConditionLow;
        const degradedGrip = comp.minGripFactor + t * (1.0 - comp.minGripFactor);
        return comp.baseGrip * degradedGrip;
      },
      
      // Change tires with optional compound change
      changeTires(newCompound) {
        if (newCompound && TireCompounds[newCompound]) {
          this.compound = newCompound;
        }
        this.condition = 100;
        this.distanceTraveled = 0;
        this.forceAccumulator = 0;
      },
      
      // Set compound (for pit strategy)
      setCompound(compound) {
        if (TireCompounds[compound]) {
          this.compound = compound;
        }
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // TIRE ALLOCATION — Pre-race tire set management
    // Each car gets a limited number of tire sets per compound.
    // Used sets retain their wear state for re-use.
    // ═══════════════════════════════════════════════════════════════════════════════
    const TireAllocation = {
      // Default allocation per car
      defaultAllocation: {
        soft: 3,
        medium: 3,
        hard: 2,
        intermediate: 2,
        wet: 2
      },
      
      // Create a fresh allocation for a car
      create() {
        const sets = {};
        for (const [compound, count] of Object.entries(this.defaultAllocation)) {
          sets[compound] = [];
          for (let i = 0; i < count; i++) {
            sets[compound].push({
              id: `${compound}_${i}`,
              condition: 100,
              distanceTraveled: 0,
              used: false // has it been mounted at least once?
            });
          }
        }
        return {
          sets,
          activeCompound: 'medium',
          activeSetIndex: 0  // which set of that compound is mounted
        };
      },
      
      // Get the currently mounted set
      getActiveSet(alloc) {
        if (!alloc) return null;
        const compound = alloc.activeCompound;
        const sets = alloc.sets[compound];
        if (!sets || sets.length === 0) return null;
        return sets[alloc.activeSetIndex] || sets[0];
      },
      
      // Get available (unused or partially used) sets for a compound
      getAvailableSets(alloc, compound) {
        if (!alloc || !alloc.sets[compound]) return [];
        return alloc.sets[compound];
      },
      
      // Save current tire state back to the allocation before changing
      saveCurrentState(alloc, tire) {
        if (!alloc || !tire) return;
        const set = this.getActiveSet(alloc);
        if (set) {
          set.condition = tire.condition;
          set.distanceTraveled = tire.distanceTraveled;
          set.used = true;
        }
      },
      
      // Switch to a specific set of a compound
      mountSet(alloc, tire, compound, setIndex) {
        if (!alloc || !tire) return false;
        const sets = alloc.sets[compound];
        if (!sets || setIndex >= sets.length) return false;
        
        // Save current state first
        this.saveCurrentState(alloc, tire);
        
        // Mount new set
        alloc.activeCompound = compound;
        alloc.activeSetIndex = setIndex;
        const newSet = sets[setIndex];
        
        tire.compound = compound;
        tire.condition = newSet.condition;
        tire.distanceTraveled = newSet.distanceTraveled;
        newSet.used = true;
        
        return true;
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // ASSEMBLY PARTS — Component wear tracking
    // Each car part tracks km driven and degrades performance over distance.
    // Parts affect: engine power, gearbox efficiency, aero, grip
    // ═══════════════════════════════════════════════════════════════════════════════
    const AssemblyParts = {
      // Part definitions: name, max km before critical wear, performance effect description
      partTypes: {
        engine:   { name: 'Engine',    maxKm: 3000, label: '🔧 Motor',     affects: 'power' },
        gearbox:  { name: 'Gearbox',   maxKm: 5000, label: '⚙ Getriebe',   affects: 'power' },
        chassis:  { name: 'Chassis',   maxKm: 8000, label: '🏎 Chassis',    affects: 'grip' },
        frontWing:{ name: 'Front Wing',maxKm: 2000, label: '✈ Frontflügel', affects: 'aero' },
        rearWing: { name: 'Rear Wing', maxKm: 2500, label: '✈ Heckflügel',  affects: 'aero' },
        diffuser: { name: 'Diffuser',  maxKm: 4000, label: '🔽 Diffusor',   affects: 'aero' }
      },
      
      // Create fresh parts for a car
      create() {
        const parts = {};
        for (const [key, def] of Object.entries(this.partTypes)) {
          parts[key] = {
            km: 0,             // kilometers driven
            maxKm: def.maxKm,
            condition: 100     // 0-100% (derived from km)
          };
        }
        return parts;
      },
      
      // Update km tracking (call each physics step)
      update(parts, deltaS) {
        if (!parts) return;
        const deltaKm = deltaS / 1000;
        for (const key of Object.keys(this.partTypes)) {
          if (parts[key]) {
            parts[key].km += deltaKm;
            // Condition decreases linearly with km
            parts[key].condition = Math.max(0, 100 * (1 - parts[key].km / parts[key].maxKm));
          }
        }
      },
      
      // Get performance multiplier for a specific effect type
      // 'power' — engine + gearbox avg
      // 'grip' — chassis
      // 'aero' — frontWing + rearWing + diffuser avg
      getMultiplier(parts, affect) {
        if (!parts) return 1.0;
        const relevant = Object.entries(this.partTypes)
          .filter(([, def]) => def.affects === affect);
        if (relevant.length === 0) return 1.0;
        
        let sum = 0;
        for (const [key] of relevant) {
          const cond = parts[key] ? parts[key].condition : 100;
          // Performance loss: up to 8% at 0% condition
          sum += 1.0 - (1 - cond / 100) * 0.08;
        }
        return sum / relevant.length;
      },
      
      // Get overall condition summary (average of all parts)
      getOverallCondition(parts) {
        if (!parts) return 100;
        const keys = Object.keys(this.partTypes);
        let sum = 0;
        for (const key of keys) {
          sum += parts[key] ? parts[key].condition : 100;
        }
        return sum / keys.length;
      },

      // Replace a single part (career mode) — resets km and condition
      replacePart(parts, key) {
        if (!parts || !this.partTypes[key]) return;
        parts[key].km = 0;
        parts[key].condition = 100;
      },

      // Get detailed performance impact per part
      getPartImpact(parts, key) {
        if (!parts || !parts[key]) return { mult: 1.0, lossPct: 0 };
        const cond = parts[key].condition;
        const loss = (1 - cond / 100) * 0.08; // max 8% loss at 0% condition
        return { mult: 1.0 - loss, lossPct: loss * 100 };
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // CAMBER (STURZ) MODEL
    // ═══════════════════════════════════════════════════════════════════════════════
    // Camber affects grip differently for lateral (corners) vs longitudinal (straights)
    // More negative camber helps in corners but hurts on straights
    
    const CamberModel = {
      // Default parameters (can be adjusted per setup)
      params: {
        // Lateral (corner) parameters
        camberOpt: -4.0,      // Optimal camber for corners (degrees)
        latGain: 0.05,        // Max lateral grip bonus (+5%)
        latSigma: 1.5,        // Width of the Gaussian curve (degrees)
        latMin: 0.92,         // Minimum lateral factor
        latMax: 1.06,         // Maximum lateral factor
        
        // Longitudinal (straight) parameters  
        longPenaltyAtRef: 0.06, // Penalty at reference camber (-6%)
        camberRef: 4.0,         // Reference camber for penalty
        longExp: 1.5,           // Exponent for penalty curve
        longMin: 0.88,          // Minimum longitudinal factor
        
        // Wear parameters
        wearW: 0.20,          // Wear penalty coefficient (+20% at reference)
        wearR: 1.4,           // Wear penalty exponent
        
        // Rolling resistance parameters
        rrCoeff: 0.04,        // RR increase coefficient (+4% at reference camber)
        rrExp: 1.6            // RR increase exponent (slightly super-linear)
      },
      
      // Clamp helper
      clamp(x, a, b) {
        return Math.max(a, Math.min(b, x));
      },
      
      // Calculate lateral (corner) and longitudinal (straight) grip factors
      getFactors(camberDeg, customParams) {
        const p = customParams || this.params;
        
        // Lateral factor: Gaussian peak at optimal camber
        // kLat = 1 + latGain * exp(-(camber - camberOpt)² / (2 * sigma²))
        const d = camberDeg - p.camberOpt;
        const kLat = 1 + p.latGain * Math.exp(-(d * d) / (2 * p.latSigma * p.latSigma));
        
        // Longitudinal factor: monotonic penalty with |camber|
        // kLong = 1 - penalty * (|camber| / camberRef)^exp
        const absCamber = Math.abs(camberDeg);
        let kLong = 1 - p.longPenaltyAtRef * Math.pow(absCamber / p.camberRef, p.longExp);
        
        return {
          kLat: this.clamp(kLat, p.latMin, p.latMax),
          kLong: this.clamp(kLong, p.longMin, 1.02)
        };
      },
      
      // Calculate wear multiplier (more |camber| = more wear)
      getWearFactor(camberDeg, customParams) {
        const p = customParams || this.params;
        const absCamber = Math.abs(camberDeg);
        return 1 + p.wearW * Math.pow(absCamber / p.camberRef, p.wearR);
      },

      // Rolling resistance factor from camber angle
      // More camber = higher rolling resistance due to:
      // - Uneven contact patch → higher deformation energy
      // - Asymmetric tread loading → more hysteresis loss
      // At 0° camber: kRR = 1.0 (baseline)
      // At -4° camber: kRR ≈ 1.04 (+4% rolling resistance)
      // Based on SAE studies: ~1% increase per degree of camber
      getRollingResistanceFactor(camberDeg, customParams) {
        const p = customParams || this.params;
        const absCamber = Math.abs(camberDeg);
        // Quadratic model: slight increase at low camber, steeper at high camber
        // kRR = 1 + rrCoeff * (|camber| / camberRef)^rrExp
        return 1 + p.rrCoeff * Math.pow(absCamber / p.camberRef, p.rrExp);
      },
      
      // Calculate effective grip based on lateral vs longitudinal force ratio
      // Fy = lateral force (cornering), Fx = longitudinal force (accel/brake)
      getEffectiveFactor(camberDeg, Fx, Fy, customParams) {
        const { kLat, kLong } = this.getFactors(camberDeg, customParams);
        
        const total = Math.hypot(Fx, Fy);
        
        // If no forces, default to longitudinal factor (straight line)
        if (total < 1e-6) {
          return kLong;
        }
        
        const wLat = Math.abs(Fy) / total;   // Weight for lateral
        const wLong = Math.abs(Fx) / total;  // Weight for longitudinal
        
        return wLat * kLat + wLong * kLong;
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // AERO MODEL — Split into WINGS and DIFFUSER
    // ═══════════════════════════════════════════════════════════════════════════════
    // Wings: Controlled by wing angle. Produce downforce + drag.
    //   - Front & rear wing angle directly adjustable
    //   - More angle = more downforce (linear) + more drag (exponential)
    //   - Affected by slipstream (reduced efficiency in dirty air)
    //
    // Diffuser: Controlled by suspension/ride height (via Platform model).
    //   - Ground effect: venturi effect from underbody floor
    //   - kAero from Platform model determines diffuser efficiency
    //   - Lower ride height = more diffuser downforce (until stall)
    //   - Not affected by wing angle
    //
    // Split: baseDownforce = wingDownforce + diffuserDownforce
    //   - wingPortion:    fraction of cLift from wings (default 0.45)
    //   - diffuserPortion: fraction of cLift from diffuser (default 0.55)
    //   - Wings: scaled by wingAngle factor
    //   - Diffuser: scaled by Platform.kAero (ride height dependent)
    // ═══════════════════════════════════════════════════════════════════════════════
    
    const AeroModel = {
      // Default parameters — wing/diffuser split
      params: {
        wingAngleMax: 25.0,       // Maximum wing angle (degrees)
        wingAngleDefault: 12.0,   // Default wing angle
        
        // Wing Lift parameters — linear increase with angle
        wingLiftBonus: 0.30,      // Max wing lift bonus at max angle (+30% of wing portion)
        
        // Wing Drag parameters — exponential increase (applied to wing drag ONLY)
        wingDragGain: 0.40,       // Wing drag multiplier gain at max angle → +40% wing drag at max
        wingDragExp: 1.6,         // Drag exponent (>1 = exponential)
        
        // Diffuser parameters (efficiency comes from Platform.kAero)
        diffuserDragEffect: 0.05, // Diffuser contributes small drag change via ground effect
      },
      
      // Calculate wing-only lift and drag multipliers
      getWingFactors(wingAngleDeg, customParams) {
        const p = customParams || this.params;
        const alpha = Math.max(0, Math.min(wingAngleDeg, p.wingAngleMax)) / p.wingAngleMax;
        
        // Wing lift factor (applied to cLWing)
        const kWingLift = 1 + p.wingLiftBonus * alpha;
        
        // Wing drag factor (applied to cDWing)
        const kWingDrag = 1 + p.wingDragGain * Math.pow(alpha, p.wingDragExp);
        
        return { kWingLift, kWingDrag, alpha };
      },
      
      // Calculate combined effective cLift with BOTH wing and diffuser
      // wingAngle affects wing lift, Platform.kAero affects diffuser
      getEffectiveLift(cLWing, cLDiffuser, wingAngleDeg, kAero, customParams) {
        const { kWingLift } = this.getWingFactors(wingAngleDeg, customParams);
        
        // Use provided kAero or default 1.0
        const diffuserEff = (kAero !== undefined) ? kAero : 1.0;
        
        // Direct: wing + diffuser
        const wingCL = cLWing * kWingLift;
        const diffuserCL = cLDiffuser * diffuserEff;
        
        return wingCL + diffuserCL;
      },
      
      // Compute total baseline cLift (for Platform suspension model)
      getTotalCLift(cLWing, cLDiffuser, wingAngleDeg) {
        return this.getEffectiveLift(cLWing, cLDiffuser, wingAngleDeg, 1.0);
      },
      
      // Get drag components separately (body vs wing)
      // Platform.kDrag should only affect body drag, not wing drag
      getDragComponents(cDBody, cDWing, wingAngleDeg, customParams) {
        const { kWingDrag } = this.getWingFactors(wingAngleDeg, customParams);
        const body = cDBody;
        const wing = cDWing * kWingDrag;
        return { body, wing, total: body + wing };
      },
      
      // Calculate effective total cDrag (wing angle affects wing portion only)
      getEffectiveDrag(cDBody, cDWing, wingAngleDeg, customParams) {
        return this.getDragComponents(cDBody, cDWing, wingAngleDeg, customParams).total;
      },
      
      // Get display factors for UI
      getFactors(wingAngleDeg, customParams) {
        const p = customParams || this.params;
        const { kWingLift, kWingDrag, alpha } = this.getWingFactors(wingAngleDeg, customParams);
        
        return {
          kWingLift,
          kWingDrag,
          alpha,
          liftBonusPct: ((kWingLift - 1) * CarDefaults.cLWing / (CarDefaults.cLWing + CarDefaults.cLDiffuser)) * 100,
          dragPenaltyPct: (kWingDrag - 1) * 100
        };
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // MULTI-CAR SYSTEM - SLIPSTREAM, DIRTY AIR & LANE LOGIC
    // ═══════════════════════════════════════════════════════════════════════════════
    // Supports 2-10 cars racing simultaneously
    // Infinite lanes on straights (lane = meter offset from center)
    // Slipstream & Dirty Air only when on SAME lane
    // No overtaking in corners - queue at corner entry (freeze if too close)
    
    // Vehicle class-specific slipstream/dirty air parameters
    // Based on real aerodynamic wake studies:
    //   - Drag reduction (slipstream): exponential decay from max at d=0
    //     AD = max drag reduction fraction, dD = characteristic decay distance (m)
    //   - Downforce loss (dirty air): same model
    //     ACL = max downforce loss fraction, dCL = decay distance (m)
    //   kDrag = 1 - AD * exp(-d/dD),  kCL = 1 - ACL * exp(-d/dCL)
    //   At d=0:  kDrag = 1-AD (e.g. 0.55 = 45% drag reduction)
    //   At d=dD: kDrag ≈ 1 - AD*0.37 (effect drops to 37%)
    const SlipstreamParams = {
      // F1 2022+ ground effect (reduced dirty air, strong slipstream)
      // kDrag = 1 - AD * exp(-d/dD).  At d=dD: 37% of max effect remains.
      // Effective range ≈ 3*dD (~75m for drag, ~45m for downforce loss)
      F1: {
        AD: 0.38,    // ~38% max drag reduction at d≈0
        dD: 25,      // Drag benefit extends far (~25m char. distance → felt up to ~75m)
        ACL: 0.12,   // ~12% max downforce loss
        dCL: 15      // Downforce loss felt up to ~45m behind
      },
      // LMP/Hypercar (enclosed bodywork, cleaner wake)
      LMP: {
        AD: 0.28,
        dD: 28,
        ACL: 0.08,
        dCL: 18
      },
      // GT3 (least aero dependency)
      GT3: {
        AD: 0.20,
        dD: 30,
        ACL: 0.05,
        dCL: 20
      }
    };

    // Car length for collision/spacing calculations
    const CAR_LENGTH = 5.5;  // meters (realistic F1 car length)
    
    // Lane configuration: lanes are continuous offsets in meters from track center
    // Lane 0 = center/racing line. Positive = right, negative = left.
    const LANE_CENTER = 0;  // Center of track (racing line)
    const LANE_WIDTH = 3.0; // Width of one "slot" in meters (realistic)
    const TRACK_HALF_WIDTH = 8.5; // Half the track width with margin (HALF_TW + 1.0)
    
    // Race configuration
    // Race configuration — use Track.totalLaps directly (may change at runtime)

    // ═══════════════════════════════════════════════════════════════════════════════
    // AI DRIVER SYSTEM (strategy only — no skill parameters, no lane decisions)
    // ═══════════════════════════════════════════════════════════════════════════════
    // Lane logic is purely physics-based (follow / dodge). AI only decides:
    //   - Pit strategy: when to pit, which compound
    //   - Fuel management: lift & coast timing
    // ═══════════════════════════════════════════════════════════════════════════════

    // ═══════════════════════════════════════════════════════════════════════════════
    // DRIVING MODES — Push / Normal / Conserve
    // ═══════════════════════════════════════════════════════════════════════════════
    // Tire µ & wear are handled by TireModel._drivingModes:
    //   Push:     100% µ, 125% tire wear
    //   Normal:    98% µ, 110% tire wear
    //   Conserve:  95% µ, 100% tire wear
    //
    // Pace & fuel scaling (driver skill output):
    //   Push:     100% pace, 100% fuel
    //   Normal:    96% pace,  97% fuel
    //   Conserve:  90% pace,  92% fuel
    // ═══════════════════════════════════════════════════════════════════════════════
    const DrivingMode = {
      current: 'normal',  // 'push' | 'normal' | 'conserve'
      
      modes: {
        push:     { paceFactor: 1.00, fuelFactor: 1.00, label: 'PUSH',     color: '#c62828' },
        normal:   { paceFactor: 0.96, fuelFactor: 0.97, label: 'NORMAL',   color: '#555' },
        conserve: { paceFactor: 0.90, fuelFactor: 0.92, label: 'CONSERVE', color: '#2e7d32' }
      },
      
      get() { return this.modes[this.current] || this.modes.normal; },
      
      set(mode) {
        if (this.modes[mode]) this.current = mode;
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // DRIVER SKILLS SYSTEM
    // ═══════════════════════════════════════════════════════════════════════════════
    //
    // 6 skills (0-99). Skills can ONLY make the car WORSE than the physical limit.
    //
    //  Skill         | Mechanism
    //  --------------|----------------------------------------------------------
    //  braking       | decelFactor  = scales RESULT of getBrakingAt()        (0.85–1.00)
    //  cornering     | μ_corner     = μ_physics × gripFactor(cornering)      (0.95–1.00)
    //  accelerating  | accelFactor  = scales RESULT of getAccelerationWith() (0.88–1.00)
    //  tyre_mgmt     | wearRate     = wearRate × wearMult(tyre_mgmt)        (1.00–1.40)
    //  fuel_mgmt     | fuelRate     = fuelRate × fuelMult(fuel_mgmt)        (1.00–1.15)
    //  consistency   | additional random penalty 0..+5% on all factors per segment
    //
    // Cornering uses μ (friction coefficient) because corner speed depends on grip.
    // Braking & Accelerating use OUTPUT scaling (decel/accel factor) so they work
    // regardless of whether the car is grip-limited or force/power-limited.
    // This ensures all 3 skills are equally impactful across all downforce levels.
    //
    //   cornering 99  → μ × 1.00     |  cornering 0  → μ × 0.95
    //   braking 99    → decel × 1.00 |  braking 0    → decel × 0.85
    //   accelerating 99→ accel × 1.00 | accelerating 0→ accel × 0.88
    //
    // Consistency adds a random ADDITIONAL penalty (never helps):
    //   consistency 99 → 0..+0.5% extra penalty per segment
    //   consistency  0 → 0..+5%   extra penalty per segment
    //
    // ═══════════════════════════════════════════════════════════════════════════════

    const DriverSkills = {

      // ── Cornering skill (0-99) → μ grip factor (0.95 – 1.00) ──
      // Applied to friction coefficient in corner speed calculation.
      // 99 = use 100% of available grip, 0 = only 95%
      ratingToGripFactor(rating) {
        const r = Math.min(99, Math.max(0, rating));
        return 0.95 + (r / 99) * 0.05;
      },

      // ── Braking skill (0-99) → deceleration factor (0.85 – 1.00) ──
      // Scales the RESULT of getBrakingAt(), so it works whether
      // grip-limited (low-DF) or brake-force-limited (high-DF).
      // 99 = 100% of available decel, 0 = only 85%
      ratingToDecelFactor(rating) {
        const r = Math.min(99, Math.max(0, rating));
        return 0.85 + (r / 99) * 0.15;
      },

      // ── Accelerating skill (0-99) → acceleration factor (0.88 – 1.00) ──
      // Scales the RESULT of getAccelerationWithThrottle(), so it works whether
      // traction-limited (low-DF) or power-limited (high-DF).
      // 99 = 100% of available accel, 0 = only 88%
      ratingToAccelFactor(rating) {
        const r = Math.min(99, Math.max(0, rating));
        return 0.88 + (r / 99) * 0.12;
      },

      // ── Consistency (0-99) → max additional penalty (0.005 – 0.05) ──
      // This is the RANGE of extra loss. Actual penalty is random 0..maxPenalty.
      // 99 = max 0.5% extra loss, 0 = max 5% extra loss
      consistencyMaxPenalty(consistency) {
        const c = Math.min(99, Math.max(0, consistency));
        return 0.05 - (c / 99) * 0.045;
      },

      // ── Tyre management (0-99) → wear multiplier (1.00 – 1.40) ──
      // 99 = 1.00× (no extra wear), 0 = 1.40× (40% more wear)
      // NEVER below 1.0 — skill can only make it worse
      tyreWearMultiplier(tyreMgmt) {
        const r = Math.min(99, Math.max(0, tyreMgmt));
        return 1.40 - (r / 99) * 0.40;
      },

      // ── Fuel management (0-99) → fuel consumption multiplier (1.00 – 1.15) ──
      // 99 = 1.00× (no extra consumption), 0 = 1.15× (15% more fuel)
      // NEVER below 1.0 — skill can only make it worse
      fuelEfficiencyMultiplier(fuelMgmt) {
        const r = Math.min(99, Math.max(0, fuelMgmt));
        return 1.15 - (r / 99) * 0.15;
      },

      // ── Fuel management (0-99) → lift-coast threshold ──
      // 99 = start L&C at fuelMargin < 0.95 (slightly early, avoids running out)
      //  0 = start L&C at fuelMargin < 0.80 (very late, high risk)
      // L&C only activates when fuel is genuinely tight, not routinely
      fuelCoastThreshold(fuelMgmt) {
        const r = Math.min(99, Math.max(0, fuelMgmt));
        return 0.80 + (r / 99) * 0.15;
      },

      // ── Create a single segment snapshot ──
      // Applies consistency noise (ONLY makes things worse).
      // Each segment gets independent random penalties.
      // drivingMode: optional override ('push'|'normal'|'conserve')
      createSegmentSnapshot(skills, drivingMode) {
        const maxPenalty = this.consistencyMaxPenalty(skills.consistency);

        // Random penalty for this segment: triangle distribution [0, maxPenalty]
        // Average of 2 uniform values → peak at center, fewer extremes
        // This prevents wild lap-to-lap swings while keeping natural variation
        const randomPenalty = () => (Math.random() + Math.random()) * 0.5 * maxPenalty;

        // Base factors from raw skill ratings
        let decelBase  = this.ratingToDecelFactor(skills.braking);
        let cornerBase = this.ratingToGripFactor(skills.cornering);
        let accelBase  = this.ratingToAccelFactor(skills.accelerating);
        
        // ── WET PACE: Reduce pace skills when track is wet ──
        // wet_pace 99 → skills unchanged, wet_pace 0 → skills reduced by ~1/3
        const wetness = Weather.wetness || 0;
        if (wetness > 0 && skills.wet_pace !== undefined) {
          // wetPenaltyFactor: how much to reduce (0 at wet_pace=99, 0.33 at wet_pace=0)
          const wp = Math.min(99, Math.max(0, skills.wet_pace));
          const wetPenaltyFactor = (1 - wp / 99) * 0.33 * wetness;
          decelBase  *= (1 - wetPenaltyFactor);
          cornerBase *= (1 - wetPenaltyFactor);
          accelBase  *= (1 - wetPenaltyFactor);
        }

        // Apply consistency penalty (only subtract, never add)
        // clampMu for cornering μ [0.88, 1.00]
        // clampFactor for decel/accel output factors [0.80, 1.00]
        const clampMu     = (val) => Math.max(0.88, Math.min(1.00, val));
        const clampFactor = (val) => Math.max(0.80, Math.min(1.00, val));
        
        // Driving Mode scaling (Push=100%, Normal=96%, Conserve=90%)
        const mode = DrivingMode.modes[drivingMode] || DrivingMode.get();
        const pf = mode.paceFactor;

        return {
          // Braking: scales deceleration OUTPUT (not μ)
          decelFactor: clampFactor((decelBase  - randomPenalty()) * pf),
          // Cornering: scales μ (friction coefficient)
          muCorner:    clampMu((cornerBase - randomPenalty()) * pf),
          // Accelerating: scales acceleration OUTPUT (not μ)
          accelFactor: clampFactor((accelBase  - randomPenalty()) * pf),

          // Tyre and fuel — skill-based only (driving mode wear applied via TireModel)
          tyreWearMult: this.tyreWearMultiplier(skills.tyre_mgmt),
          fuelEffMult:  this.fuelEfficiencyMultiplier(skills.fuel_mgmt) * mode.fuelFactor,
          fuelCoastThr: this.fuelCoastThreshold(skills.fuel_mgmt),
          
          // Store mode for display + TireModel lookup
          drivingMode: mode.label,
          drivingModeKey: drivingMode || DrivingMode.current
        };
      },

      // ── Create per-lap snapshot (legacy wrapper) ──
      createLapSnapshot(skills) {
        return this.createSegmentSnapshot(skills);
      },

      // ── Create all segment snapshots for one full lap ──
      // Returns array[numSegments] of snapshots, each with independent
      // consistency noise. Pre-computed so the brake envelope can
      // look ahead to the next corner's grip factors.
      createAllSegmentSnapshots(skills, numSegments, drivingMode) {
        const snapshots = [];
        for (let i = 0; i < numSegments; i++) {
          snapshots.push(this.createSegmentSnapshot(skills, drivingMode));
        }
        return snapshots;
      },
    };

    // ── 20 Driver Skill Profiles ──
    // Index matches teams[] / teamSetups[] order
    // Skills: braking, cornering, accelerating, tyre_mgmt, fuel_mgmt, consistency, wet_pace
    const driverSkillProfiles = [
      // Red Bull 1 — Verstappen-tier: elite everywhere
      { braking: 97, cornering: 98, accelerating: 95, tyre_mgmt: 88, fuel_mgmt: 85, consistency: 96, wet_pace: 97 },
      // Red Bull 2 — strong #2 driver
      { braking: 86, cornering: 84, accelerating: 85, tyre_mgmt: 80, fuel_mgmt: 78, consistency: 82, wet_pace: 78 },
      // Ferrari 1 — very fast but inconsistent
      { braking: 90, cornering: 92, accelerating: 91, tyre_mgmt: 72, fuel_mgmt: 75, consistency: 78, wet_pace: 70 },
      // Ferrari 2 — smooth, tyre whisperer
      { braking: 84, cornering: 86, accelerating: 83, tyre_mgmt: 92, fuel_mgmt: 82, consistency: 88, wet_pace: 82 },
      // Mercedes 1 — veteran, ultra consistent, great in rain
      { braking: 92, cornering: 90, accelerating: 88, tyre_mgmt: 90, fuel_mgmt: 90, consistency: 95, wet_pace: 95 },
      // Mercedes 2 — promising, raw speed
      { braking: 82, cornering: 85, accelerating: 87, tyre_mgmt: 70, fuel_mgmt: 68, consistency: 75, wet_pace: 60 },
      // McLaren 1 — quick, great racer
      { braking: 88, cornering: 91, accelerating: 90, tyre_mgmt: 82, fuel_mgmt: 80, consistency: 86, wet_pace: 88 },
      // McLaren 2 — balanced, still developing
      { braking: 80, cornering: 82, accelerating: 81, tyre_mgmt: 78, fuel_mgmt: 76, consistency: 80, wet_pace: 72 },
      // Aston Martin 1 — experienced veteran
      { braking: 86, cornering: 83, accelerating: 80, tyre_mgmt: 88, fuel_mgmt: 92, consistency: 90, wet_pace: 85 },
      // Aston Martin 2 — solid midfielder
      { braking: 76, cornering: 78, accelerating: 77, tyre_mgmt: 74, fuel_mgmt: 72, consistency: 76, wet_pace: 68 },
      // Alpine 1 — decent allrounder
      { braking: 78, cornering: 80, accelerating: 79, tyre_mgmt: 76, fuel_mgmt: 74, consistency: 78, wet_pace: 74 },
      // Alpine 2 — junior driver, error prone
      { braking: 68, cornering: 72, accelerating: 74, tyre_mgmt: 60, fuel_mgmt: 58, consistency: 62, wet_pace: 45 },
      // Williams 1 — good qualifier, decent racer
      { braking: 80, cornering: 78, accelerating: 82, tyre_mgmt: 72, fuel_mgmt: 70, consistency: 77, wet_pace: 70 },
      // Williams 2 — newcomer, raw talent
      { braking: 65, cornering: 70, accelerating: 72, tyre_mgmt: 55, fuel_mgmt: 52, consistency: 58, wet_pace: 40 },
      // RB 1 — quick midfielder
      { braking: 76, cornering: 79, accelerating: 78, tyre_mgmt: 74, fuel_mgmt: 72, consistency: 75, wet_pace: 72 },
      // RB 2 — steady but slow
      { braking: 70, cornering: 72, accelerating: 70, tyre_mgmt: 70, fuel_mgmt: 68, consistency: 74, wet_pace: 65 },
      // Sauber 1 — struggling with skills
      { braking: 66, cornering: 68, accelerating: 66, tyre_mgmt: 62, fuel_mgmt: 60, consistency: 65, wet_pace: 55 },
      // Sauber 2 — pay driver, limited talent
      { braking: 55, cornering: 58, accelerating: 56, tyre_mgmt: 50, fuel_mgmt: 48, consistency: 50, wet_pace: 35 },
      // Haas 1 — decent braker, weak otherwise
      { braking: 78, cornering: 70, accelerating: 68, tyre_mgmt: 65, fuel_mgmt: 60, consistency: 68, wet_pace: 58 },
      // Haas 2 — aggressive, error-prone
      { braking: 62, cornering: 64, accelerating: 66, tyre_mgmt: 52, fuel_mgmt: 50, consistency: 55, wet_pace: 42 },
    ];

    const AIDriver = {
      create(index) {
        // Small randomization so AI cars don't all pit at once
        const pitVariation = (Math.random() - 0.5) * 10;  // ±5% threshold shift

        return {
          // Runtime state
          coastActive: false,
          pitPlanned: false,
          nextCompound: 'medium',
          lastDecisionTime: 0,
          decisionInterval: 2.0 + Math.random() * 1.0,  // 2-3s

          // ── PIT STRATEGY ──
          evaluatePitStrategy(car, currentLap, totalLaps) {
            if (car.pit.inLane || car.pit.armed || car.pit.committed) return;
            if (this.pitPlanned) return;
            if (currentLap < 1) return;

            const remainingLaps = totalLaps - currentLap;
            if (remainingLaps <= 1) return;

            const tireCondition = car.tire ? car.tire.condition : 100;
            const fuelPerLap = car.lastLapFuelUsed || 3.0;
            const fuelForRemaining = fuelPerLap * remainingLaps;

            const tirePitThreshold = 35 + pitVariation;
            const shouldPitTires = tireCondition < tirePitThreshold;
            const shouldPitFuel = car.fuel < fuelPerLap * 2;

            if (shouldPitTires || shouldPitFuel) {
              this.pitPlanned = true;
              if (remainingLaps <= 3) this.nextCompound = 'soft';
              else if (remainingLaps <= 6) this.nextCompound = 'medium';
              else this.nextCompound = 'hard';
            }
          },

          executePitStop(car) {
            if (!this.pitPlanned || car.pit.inLane || car.pit.armed) return;
            car.pit.armed = true;
            car.pit.phase = 'approach';
            this.pitPlanned = false;
          },

          handlePitBox(car) {
            if (!car.pit.stopped) return;
            if (car.tire) {
              // Save current set state before switching
              if (car.tireAllocation) {
                TireAllocation.saveCurrentState(car.tireAllocation, car.tire);
                // Find a fresh set of the next compound
                const nextSets = car.tireAllocation.sets[this.nextCompound] || [];
                let bestIdx = 0;
                let bestCond = -1;
                for (let i = 0; i < nextSets.length; i++) {
                  if (nextSets[i].condition > bestCond) {
                    bestCond = nextSets[i].condition;
                    bestIdx = i;
                  }
                }
                TireAllocation.mountSet(car.tireAllocation, car.tire, this.nextCompound, bestIdx);
              } else {
                car.tire.compound = this.nextCompound;
                car.tire.condition = 100;
                car.tire.distanceTraveled = 0;
                car.tire.forceAccumulator = 0;
              }
            }
            car.fuel = car.setup.fuelCapacity || CarDefaults.fuelCapacity;
            car.pit.exitRequested = true;
          },

          // ── FUEL: Lift & Coast ──
          evaluateLiftCoast(car, currentLap, totalLaps) {
            const remainingLaps = totalLaps - currentLap;
            if (remainingLaps <= 0) { this.coastActive = false; return; }

            const fuelPerLap = car.lastLapFuelUsed || 3.0;
            const fuelNeeded = fuelPerLap * remainingLaps;
            const fuelMargin = car.fuel / Math.max(1, fuelNeeded);

            // ── DRIVER SKILL: Fuel management threshold ──
            // Higher skill = start coasting earlier (conservative), avoids running out
            const coastThreshold = car.skillSnapshot
              ? car.skillSnapshot.fuelCoastThr
              : 1.0;

            if (fuelMargin < coastThreshold && !car.pit.inLane) {
              const segInfo = Track.atPosition(car.s);
              if (segInfo.segment.kind === 'straight') {
                const nc = Track.getNextCorner(car.s);
                if (nc.found && nc.distance < 400 && nc.distance > 50) {
                  this.coastActive = true;
                }
              }
            }
            if (fuelMargin > 1.2) this.coastActive = false;
            if (Track.atPosition(car.s).segment.kind === 'corner') this.coastActive = false;
          },

          // ── MAIN AI TICK ──
          update(car, simTime, allCars, currentLap, totalLaps) {
            if (simTime - this.lastDecisionTime >= this.decisionInterval) {
              this.lastDecisionTime = simTime;
              this.evaluatePitStrategy(car, currentLap, totalLaps);
              this.evaluateLiftCoast(car, currentLap, totalLaps);
            }
            if (this.pitPlanned && !car.pit.armed && !car.pit.inLane) {
              this.executePitStop(car);
            }
            if (car.pit.stopped) {
              this.handlePitBox(car);
            }
          }
        };
      }
    };

    // ═══════════════════════════════════════════════════════════════
    // CORNER DEBUG — logs per-lap values for a specific car + corner
    // Enable: CornerDebug.enabled = true  (default: true)
    // Configure: CornerDebug.carId = 1, CornerDebug.cornerIdx = 1
    // View log: CornerDebug.print()
    // ═══════════════════════════════════════════════════════════════
    const CornerDebug = {
      enabled: true,
      carId: 1,           // which car to track
      cornerIdx: 1,       // segment index of corner (1 = T1 on Speed Oval)
      _rows: [],          // collected rows
      _approach: {},      // temp data from approach/envelope phase
      
      // Called when envelope is built or vTarget is computed on approach
      logApproach(car, lap, data) {
        if (!this.enabled || car.id !== this.carId) return;
        this._approach[lap] = { ...(this._approach[lap] || {}), ...data };
      },
      
      // Called at corner entry (when car enters the corner segment)
      logCornerEntry(car, lap, data) {
        if (!this.enabled || car.id !== this.carId) return;
        const approach = this._approach[lap] || {};
        const row = {
          lap,
          // Approach / envelope values
          envVTarget:    approach.vTarget   != null ? +approach.vTarget.toFixed(2)   : '—',
          envMuCorner:   approach.muCorner  != null ? +approach.muCorner.toFixed(4)  : '—',
          envKCL:        approach.kCL       != null ? +approach.kCL.toFixed(4)       : '—',
          envTireCond:   approach.tireCond  != null ? +approach.tireCond.toFixed(1)  : '—',
          envFuel:       approach.fuel      != null ? +approach.fuel.toFixed(1)      : '—',
          envRebuilt:    approach.rebuilt    != null ? approach.rebuilt               : '—',
          envDecelF:     approach.decelF    != null ? +approach.decelF.toFixed(4)    : '—',
          // At corner entry
          vBefore:       +data.vBefore.toFixed(2),
          vCornerOwn:    +data.vCornerOwn.toFixed(2),
          kCL_corner:    +data.kCL.toFixed(4),
          vCornerDirty:  +data.vCornerDirty.toFixed(2),
          vCornerFinal:  +data.vCornerFinal.toFixed(2),
          wasClamped:    data.vBefore > data.vCornerFinal + 0.5 ? 'YES' : '',
          clampDelta:    data.vBefore > data.vCornerFinal + 0.5 ? +(data.vBefore - data.vCornerFinal).toFixed(1) : '',
          muCorner_now:  data.muCorner != null ? +data.muCorner.toFixed(4) : '—',
          tireCond_now:  data.tireCond != null ? +data.tireCond.toFixed(1) : '—',
          fuel_now:      data.fuel != null ? +data.fuel.toFixed(1) : '—',
          carAheadV:     data.carAheadV != null ? +data.carAheadV.toFixed(1) : '—',
        };
        this._rows.push(row);
        
        // Auto-print after each entry
        if (row.wasClamped === 'YES') {
          console.warn(`[CornerDebug] Car ${this.carId} Lap ${lap} T${this.cornerIdx}: CLAMPED by ${row.clampDelta} m/s! vBefore=${row.vBefore} → vCornerFinal=${row.vCornerFinal}`);
          console.warn(`  Envelope vTarget=${row.envVTarget}, envMuCorner=${row.envMuCorner}, envKCL=${row.envKCL}, rebuilt=${row.envRebuilt}`);
          console.warn(`  Corner entry muCorner=${row.muCorner_now}, kCL=${row.kCL_corner}, tireCond=${row.tireCond_now}, fuel=${row.fuel_now}`);
        }
      },
      
      // Print all collected data as a table
      print() {
        if (this._rows.length === 0) {
          console.log('[CornerDebug] No data collected yet.');
          return;
        }
        console.log(`%c[CornerDebug] Car ${this.carId}, Corner Segment ${this.cornerIdx} — ${this._rows.length} entries`, 'color:#0f0;font-weight:bold;font-size:14px');
        console.table(this._rows);
      },
      
      // Reset for new race
      reset() {
        this._rows = [];
        this._approach = {};
      }
    };
    window.CornerDebug = CornerDebug;

    // Multi-car race manager
    const MultiCarRace = {
      cars: [],           // Array of all cars in race
      isActive: false,
      vehicleClass: 'LMP', // Default class for slipstream params
      
      // ─────────────────────────────────────────────────────────────────
      // SLIPSTREAM & DIRTY AIR CALCULATION
      // ─────────────────────────────────────────────────────────────────
      // kDrag(d) = 1 - AD * e^(-d/dD)   [drag reduction = good]
      // kCL(d)   = 1 - ACL * e^(-d/dCL) [downforce loss = bad]
      //
      // Effects only apply when cars are on the SAME LANE
      // ─────────────────────────────────────────────────────────────────
      
      calculateSlipstream(distance, params = null) {
        const p = params || SlipstreamParams[this.vehicleClass];
        const d = Math.max(0, Math.min(100, distance));
        
        // Slipstream (drag reduction) - BENEFIT
        const kDrag = 1 - p.AD * Math.exp(-d / p.dD);
        
        // Dirty Air (downforce loss) - PENALTY
        const kCL = 1 - p.ACL * Math.exp(-d / p.dCL);
        
        return { kDrag, kCL };
      },
      
      // Get slipstream/dirty air effects for a car
      // STRAIGHTS: Slipstream (drag reduction) from car ahead in SAME LANE
      // CORNERS: Dirty air (downforce loss) from car ahead (all in center lane)
      // OVERLAP: Extreme dirty air penalty when inside car ahead's body (2.5× max)
      getSlipstreamForCar(car) {
        const segInfo = Track.atPosition(car.s);
        const isCorner = segInfo.segment.kind === 'corner';
        const lapLen = Track.lapLength;
        
        // Find car ahead in same lane (for straights) or any car ahead (for corners)
        // Also track closest car even at zero/negative distance (overlap detection)
        let carAheadInLane = null;
        let minDistance = Infinity;
        let overlapCar = null;      // car we're overlapping with
        let overlapDistance = Infinity; // how deep we're inside (0 = touching, negative = overlapping)
        
        for (const other of this.cars) {
          if (other === car) continue;
          if (other.pit && other.pit.inLane) continue;
          if (car.pit && car.pit.inLane) continue;
          
          // Use proper forward distance (handles lap wrap-around)
          let fwdDist = other.s - car.s;
          if (fwdDist < 0) fwdDist += lapLen;
          if (fwdDist > lapLen * 0.5) continue; // other car is behind us
          
          // Check for overlap: forward distance less than car length
          if (fwdDist < CAR_LENGTH) {
            // This car is overlapping with us or very nearly so
            const lateralClose = isCorner || Math.abs(car.lane - other.lane) < LANE_WIDTH * 0.8;
            if (lateralClose && fwdDist < overlapDistance) {
              overlapDistance = fwdDist;
              overlapCar = other;
            }
          }
          
          // Normal slipstream: only cars clearly ahead (distance > 0)
          if (fwdDist <= 0 || fwdDist > 150) continue;
          
          if (isCorner) {
            if (fwdDist < minDistance) {
              minDistance = fwdDist;
              carAheadInLane = other;
            }
          } else {
            const sameLane = Math.abs(car.lane - other.lane) < LANE_WIDTH * 0.8;
            if (sameLane && fwdDist < minDistance) {
              minDistance = fwdDist;
              carAheadInLane = other;
            }
          }
        }
        
        // Store for reference
        car.carAheadInLane = carAheadInLane || overlapCar;
        car.distanceToCarAhead = carAheadInLane ? minDistance : (overlapCar ? overlapDistance : Infinity);
        
        // ── OVERLAP PENALTY: extreme dirty air when inside another car ──
        // 2.5× the normal maximum downforce loss + significant drag increase
        if (overlapCar) {
          const p = SlipstreamParams[this.vehicleClass];
          // Overlap factor: 1.0 at touching (fwdDist = CAR_LENGTH), 2.5 at full overlap (fwdDist = 0)
          const overlapDepth = 1.0 - (overlapDistance / CAR_LENGTH); // 0..1 (0=touching, 1=fully inside)
          const overlapMult = 1.0 + overlapDepth * 1.5;  // 1.0..2.5× penalty scaling
          
          // Extreme downforce loss: up to 2.5× the base ACL (e.g. 0.12 * 2.5 = 0.30 = 30% loss)
          const kCL = 1 - p.ACL * overlapMult;
          // Also add drag INCREASE in overlap (turbulence, not slipstream benefit)
          // kDrag > 1.0 = MORE drag than clean air
          const kDrag = 1 + p.AD * overlapDepth * 0.5;  // up to ~19% extra drag
          
          return { kDrag, kCL };
        }
        
        if (!carAheadInLane) {
          return { kDrag: 1.0, kCL: 1.0 };  // No effect - clean air
        }
        
        const p = SlipstreamParams[this.vehicleClass];
        const d = minDistance;
        
        if (isCorner) {
          // CORNER: Dirty air only (downforce loss, NO drag benefit)
          const kCL = 1 - p.ACL * Math.exp(-d / p.dCL);
          return { kDrag: 1.0, kCL };  // No drag reduction in corners
        } else {
          // STRAIGHT: Full slipstream (drag reduction AND some downforce loss)
          const kDrag = 1 - p.AD * Math.exp(-d / p.dD);
          const kCL = 1 - p.ACL * Math.exp(-d / p.dCL);
          return { kDrag, kCL };
        }
      },
      
      // ─────────────────────────────────────────────────────────────────
      // LANE MANAGEMENT — "Infinite lanes" on straights
      // ─────────────────────────────────────────────────────────────────
      // Rule: follow lane of car ahead. At critical distance, dodge to
      // a free lane (offset) that gives the smallest gap to the next
      // car ahead. In corners: all cars on lane 0 (center, single file).
      // ─────────────────────────────────────────────────────────────────
      
      // Minimum gap (center-to-center) to maintain behind car ahead in corners
      // Must be >= CAR_LENGTH to prevent visual overlap
      CORNER_MIN_GAP: CAR_LENGTH * 1.8,  // ~8.1m — tight but no overlap (car length = 4.5m, so 3.6m bumper gap)
      
      // Gap required before a queued car may enter the corner (must be > CORNER_MIN_GAP)
      CORNER_ENTRY_GAP: CAR_LENGTH * 3.0,  // ~13.5m — comfortable entry spacing
      
      // Distance at which lane change is triggered to avoid overlap
      LANE_CHANGE_TRIGGER: CAR_LENGTH * 3.0,  // ~13.5m center-to-center
      
      // Per-corner arrival queues: tracks which cars arrived at each corner boundary
      // Key: cornerIndex, Value: array of { carId, arrivalTime, arrivalSpeed }
      _cornerQueues: {},
      _cornerQueueSets: {},  // Set<carId> for O(1) duplicate check
      _sortedBuf: [],          // reusable buffer for updateLanes sort
      
      // Record a car's arrival at a corner boundary
      _recordCornerArrival(car, cornerIndex, simTime) {
        if (!this._cornerQueues[cornerIndex]) {
          this._cornerQueues[cornerIndex] = [];
          this._cornerQueueSets[cornerIndex] = new Set();
        }
        // O(1) duplicate check
        if (this._cornerQueueSets[cornerIndex].has(car.id)) return;
        this._cornerQueueSets[cornerIndex].add(car.id);
        this._cornerQueues[cornerIndex].push({ carId: car.id, arrivalTime: simTime, arrivalSpeed: car.v });
        // Sort only when queue changes (new entry)
        this._cornerQueues[cornerIndex].sort((a, b) => {
          if (Math.abs(a.arrivalTime - b.arrivalTime) < 0.02) {
            return b.arrivalSpeed - a.arrivalSpeed;
          }
          return a.arrivalTime - b.arrivalTime;
        });
      },
      
      // Build ID→car lookup map (cached, rebuilt when cars change)
      _carByIdMap: null,
      _carByIdMapSize: -1,
      _getCarById(id) {
        if (!this._carByIdMap || this._carByIdMapSize !== this.cars.length) {
          this._carByIdMap = new Map();
          for (const c of this.cars) this._carByIdMap.set(c.id, c);
          this._carByIdMapSize = this.cars.length;
        }
        return this._carByIdMap.get(id) || null;
      },
      
      // Get the car that should be directly ahead in corner queue order
      _getCornerQueueAhead(car, cornerIndex) {
        const queue = this._cornerQueues[cornerIndex];
        if (!queue) return null;
        const myIdx = queue.findIndex(e => e.carId === car.id);
        if (myIdx <= 0) return null; // First in queue or not found
        // Find the car object for the entry ahead in queue
        const aheadEntry = queue[myIdx - 1];
        const aheadCar = this._getCarById(aheadEntry.carId);
        if (!aheadCar) return null;
        // Validate: the ahead car must actually be in or near this corner,
        // not somewhere else on the track (stale queue entry)
        const aheadSeg = Track.atPosition(aheadCar.s);
        if (aheadSeg.index === cornerIndex) return aheadCar; // in the corner
        const starts = Track.getSegmentStarts();
        const cornerStart = starts[cornerIndex];
        const distFromCorner = Track.forwardDistance(cornerStart, aheadCar.s);
        const cornerLen = Track.segments[cornerIndex] ? Track.segments[cornerIndex].length : 200;
        if (distFromCorner < cornerLen + 30) return aheadCar; // just exited corner
        return null; // stale entry — car is far away
      },
      
      // Clean up old corner queues (corners that all cars have passed)
      _cleanCornerQueues() {
        const starts = Track.getSegmentStarts();
        
        for (const key of Object.keys(this._cornerQueues)) {
          const queue = this._cornerQueues[key];
          const ki = parseInt(key);
          const cornerSeg = Track.segments[ki];
          if (!cornerSeg) {
            delete this._cornerQueues[key];
            delete this._cornerQueueSets[key];
            continue;
          }
          const cornerStart = starts[ki];
          this._cornerQueues[key] = queue.filter(e => {
            const car = this._getCarById(e.carId);
            if (!car) return false;
            const seg = Track.atPosition(car.s);
            const distToCorner = Track.forwardDistance(car.s, cornerStart);
            return seg.index === ki || distToCorner < 50;
          });
          // Rebuild the Set from filtered queue
          this._cornerQueueSets[key] = new Set(this._cornerQueues[key].map(e => e.carId));
          if (this._cornerQueues[key].length === 0) {
            delete this._cornerQueues[key];
            delete this._cornerQueueSets[key];
          }
        }
      },
      
      updateLanes() {
        // Reuse buffer – avoids filter+spread allocations at 100Hz
        const sorted = this._sortedBuf;
        sorted.length = 0;
        for (const c of this.cars) {
          if (c.pit && c.pit.inLane) {
            // Pit-lane cars: clear carAhead, no freeze, no lane logic
            c.carAhead = null;
            c.frozenAtCornerEntry = false;
            c.waitingForCar = null;
          } else {
            sorted.push(c);
          }
        }
        // Sort TRACK cars by position (front to back)
        sorted.sort((a, b) => b.s - a.s);
        
        // Get current sim time
        const simTime = typeof Simulation !== 'undefined' ? Simulation.time : 0;
        
        // Clean up old corner queues every 100 steps (deterministic, not random)
        if (this._updateCounter % 100 === 0) this._cleanCornerQueues();
        
        for (let i = 0; i < sorted.length; i++) {
          const car = sorted[i];
          const carAhead = i > 0 ? sorted[i - 1] : null;
          car.carAhead = carAhead;
          
          const segInfo = Track.atPosition(car.s);
          const isInCorner = segInfo.segment.kind === 'corner';
          
          // ─── CORNER ARRIVAL TRACKING ───
          const nextCorner = Track.getNextCorner(car.s);
          const FREEZE_DETECT_RANGE = 40; // meters before corner to start checking
          
          // Register arrivals
          if (isInCorner) {
            this._recordCornerArrival(car, segInfo.index, simTime);
          } else if (nextCorner.found && nextCorner.distance < FREEZE_DETECT_RANGE) {
            this._recordCornerArrival(car, nextCorner.cornerIndex, simTime);
          }
          
          // ─── SIMPLIFIED CORNER ENTRY & IN-CORNER ORDERING ───
          // Rules:
          //   1. Straights: infinite lanes, ZERO interaction with other cars
          //   2. Corners: single file, speed = min(own corner speed, car ahead speed)
          //   3. Corner entry: FREEZE (v→0) until gap to queue-ahead car >= CORNER_MIN_GAP
          //      Then slot in immediately. No gradual braking, no pre-braking.
          
          if (isInCorner) {
            // ── IN CORNER: single-file following ──
            const queueAhead = this._getCornerQueueAhead(car, segInfo.index);
            if (queueAhead) {
              const gap = Track.forwardDistance(car.s, queueAhead.s);
              // Only treat as carAhead if actually close enough to matter
              if (gap > 0 && gap < this.CORNER_MIN_GAP * 3) {
                car.carAhead = queueAhead;
              } else {
                car.carAhead = null; // queue car is far away, not blocking
              }
              if (gap > 0 && gap < this.CORNER_MIN_GAP) {
                car.frozenAtCornerEntry = true;
                car.waitingForCar = queueAhead;
              } else {
                car.frozenAtCornerEntry = false;
                car.waitingForCar = null;
              }
            } else {
              car.carAhead = null; // no queue ahead in this corner
              car.frozenAtCornerEntry = false;
              car.waitingForCar = null;
            }
          } else if (nextCorner.found && nextCorner.distance < FREEZE_DETECT_RANGE) {
            // ── APPROACHING CORNER: check if we need to freeze ──
            const cornerIdx = nextCorner.cornerIndex;
            const queueAhead = this._getCornerQueueAhead(car, cornerIdx);
            
            if (queueAhead) {
              const gap = Track.forwardDistance(car.s, queueAhead.s);
              if (gap > 0 && gap < this.CORNER_ENTRY_GAP) {
                car.frozenAtCornerEntry = true;
                car.waitingForCar = queueAhead;
                car.carAhead = queueAhead;
              } else {
                car.frozenAtCornerEntry = false;
                car.waitingForCar = null;
              }
            } else {
              car.frozenAtCornerEntry = false;
              car.waitingForCar = null;
            }
          } else {
            car.frozenAtCornerEntry = false;
            car.waitingForCar = null;
          }
          
          // ─── LANE ASSIGNMENT ───
          if (isInCorner) {
            // CORNER: single lane (center = 0) for single-file cornering
            car.targetLane = LANE_CENTER;
            
          } else {
            // STRAIGHT: maintain lanes, dodge when too close, slipstream when aligned
            if (!carAhead) {
              // Leader: stay on current lane (or drift to racing line)
              // Only move to center if far from any traffic
              car.targetLane = car.lane;
            } else {
              const gap = carAhead.s - car.s;
              const sameLane = Math.abs(car.lane - carAhead.lane) < LANE_WIDTH * 0.8;
              
              if (sameLane && gap > 0 && gap < this.LANE_CHANGE_TRIGGER) {
                // Too close in same lane! Find free lane to dodge into.
                let bestLane = car.lane;
                let bestScore = -Infinity;
                
                const maxSlots = Math.floor(TRACK_HALF_WIDTH / LANE_WIDTH);
                for (let slot = -maxSlots; slot <= maxSlots; slot++) {
                  const testLane = slot * LANE_WIDTH;
                  // Skip the conflicting lane (carAhead's lane)
                  if (Math.abs(testLane - carAhead.lane) < LANE_WIDTH * 0.8) continue;
                  
                  // Check clearance: find closest car in this test lane
                  let minGap = Infinity;
                  for (const other of sorted) {
                    if (other === car) continue;
                    if (Math.abs(testLane - other.lane) < LANE_WIDTH * 0.8) {
                      const otherGap = Math.abs(other.s - car.s);
                      minGap = Math.min(minGap, otherGap);
                    }
                  }
                  
                  // Lane must have enough clearance
                  if (minGap < this.LANE_CHANGE_TRIGGER) continue;
                  
                  // Score: prefer lanes closer to center (racing line advantage)
                  const centerPenalty = Math.abs(testLane) * 0.5;
                  const score = -centerPenalty;
                  
                  if (score > bestScore) {
                    bestScore = score;
                    bestLane = testLane;
                  }
                }
                
                car.targetLane = bestLane;
                
              } else if (!sameLane && gap > 0 && gap < this.LANE_CHANGE_TRIGGER * 2) {
                // Already in different lane from car ahead AND still close:
                // KEEP current lane (don't snap back after a successful dodge!)
                car.targetLane = car.lane;
                
              } else if (sameLane && gap > this.LANE_CHANGE_TRIGGER) {
                // Same lane as car ahead but far enough: slipstream (stay aligned)
                car.targetLane = carAhead.lane;
                
              } else if (gap > this.LANE_CHANGE_TRIGGER * 4) {
                // Very far from car ahead: gradually drift toward racing line
                car.targetLane = LANE_CENTER;
              }
              // Else: keep current targetLane (maintain lane stability)
            }
          }
          
          // Clamp lane to track bounds
          car.targetLane = Math.max(-TRACK_HALF_WIDTH + LANE_WIDTH,
                                    Math.min(TRACK_HALF_WIDTH - LANE_WIDTH, car.targetLane));
          
          // Smooth lane transition (faster in corners to snap to center)
          const laneChangeSpeed = isInCorner ? 14.0 : 10.0; // meters/second
          if (Math.abs(car.lane - car.targetLane) > 0.01) {
            const diff = car.targetLane - car.lane;
            const step = laneChangeSpeed * SIM_DT;
            if (Math.abs(diff) < step) {
              car.lane = car.targetLane;
            } else {
              car.lane += Math.sign(diff) * step;
            }
          }
          
          // Visual lane (smooth interpolation for rendering)
          if (car.visualLane === undefined) car.visualLane = car.lane;
          car.visualLane += (car.lane - car.visualLane) * 0.35;
        }
      },
      
      // ─────────────────────────────────────────────────────────────────
      // CAR FACTORY
      // ─────────────────────────────────────────────────────────────────
      
      createCar(id, config = {}) {
        return {
          id: id,
          name: config.name || `Car ${id}`,
          color: config.color || this.getDefaultColor(id),
          number: config.number || id,
          
          // Position & Physics
          s: config.startPosition || 0,
          v: config.startVelocity || 10,  // Start with 10 m/s
          a: 0,
          prevS: config.startPosition || 0,
          lane: LANE_CENTER,        // 0 = center of track
          targetLane: LANE_CENTER,
          visualS: config.startPosition || 0,
          visualLane: LANE_CENTER,    // 0 = center
          vLimit: null,
          
          // Multiplayer/Race flags
          _raceFinished: false,
          _finishTime: null,
          _dnf: false,
          _playerPeerId: null,     // PeerId of the player controlling this car (MP only)
          
          // Throttle/Brake state
          throttle: 0,
          brake: 0,
          
          // Setup (cloned from CarDefaults with overrides)
          setup: structuredClone({ ...CarDefaults, ...config.setup }),
          
          // Tire state (full tire object like global Tire)
          tire: {
            condition: 100,
            compound: config.compound || 'medium',
            distanceTraveled: 0,
            forceAccumulator: 0,
            
            getCompound() {
              return TireCompounds[this.compound] || TireCompounds.medium;
            },
            
            getGripMultiplier() {
              const c = this.condition;
              const comp = this.getCompound();
              if (c >= comp.optimalConditionLow && c <= comp.optimalConditionHigh) {
                return comp.baseGrip * comp.optimalGripBonus;
              }
              if (c > comp.optimalConditionHigh) {
                const t = (c - comp.optimalConditionHigh) / (100 - comp.optimalConditionHigh);
                return comp.baseGrip * (1.0 - t * 0.03);
              }
              const t = (comp.optimalConditionLow - c) / comp.optimalConditionLow;
              return comp.baseGrip * (1.0 - t * 0.3);
            }
          },
          
          // Tire allocation (limited sets per compound)
          tireAllocation: TireAllocation.create(),
          
          // Assembly parts (km tracking)
          assemblyParts: AssemblyParts.create(),
          
          // Fuel
          fuel: config.fuelCapacity || CarDefaults.fuelCapacity,
          fuelAtLapStart: config.fuelCapacity || CarDefaults.fuelCapacity,
          lastLapFuelUsed: null,
          
          // Pit state (per-car)
          pit: {
            armed: false,
            committed: false,
            inLane: false,
            limiter: false,
            stopped: false,
            phase: 'none',
            exitRequested: false
          },
          
          // Envelope cache (per-car)
          _env: null,
          _lastEnvBuildTime: -999,
          _envPit: null,
          _lastPitEnvBuildTime: -999,
          
          // Race state
          lap: 0,
          lapStartTime: 0,
          currentLapTime: 0,
          lastLapTime: null,
          bestLapTime: null,
          carAhead: null,
          
          // Sector timing (times in seconds, with milliseconds precision)
          currentSector: 1,
          sectorStartTime: 0,
          sectors: {
            current: [null, null, null],
            last: [null, null, null],
            best: [null, null, null],
            personalBest: [null, null, null]
          },
          
          // Corner state
          inCorner: false,
          cornerResolved: false,
          cornerOrder: 0,
          mustWait: false,
          waitForCar: null,
          waitUntilGap: 0,
          arrivalTime: 0,
          
          // Corner entry freeze state
          frozenAtCornerEntry: false,
          waitingForCar: null,
          
          // Slipstream effects (updated each frame)
          slipstream: { kDrag: 1.0, kCL: 1.0 },
          
          // Driver Skills (7 core skills 0-99)
          skills: config.skills || { braking: 75, cornering: 75, accelerating: 75, tyre_mgmt: 75, fuel_mgmt: 75, consistency: 75, wet_pace: 75 },
          // Per-segment snapshots (μ factors with independent consistency noise)
          segSkillSnapshots: null,  // array[numSegments], initialized on first lap
          skillSnapshot: null,      // current segment's snapshot (pointer into array)
          _lastSkillSegIndex: -1,   // track segment transitions
          
          // AI Driver (null for player-controlled car, AIDriver for AI cars)
          ai: config.ai || null,
          
          // Per-car suspension lookup table (built from this car's setup)
          _platformLookup: null,
          
          // Methods
          getTotalMass() {
            return this.setup.mass + this.fuel;
          },
          
          // Build or rebuild this car's suspension lookup table from its own setup
          rebuildPlatformLookup() {
            const totalCL = AeroModel.getTotalCLift(this.setup.cLWing, this.setup.cLDiffuser, this.setup.wingAngle);
            const setupForLookup = {
              rideHeight: this.setup.rideHeight,
              springK: this.setup.springK,
              damperC: this.setup.damperC,
              cLift: totalCL,
              frontalArea: this.setup.frontalArea
            };
            this._platformLookup = Platform.buildLookupFor(setupForLookup);
            // Debug: log kDrag at different speeds
            const f200 = Platform.getFactorsFromLookup(this._platformLookup, 200/3.6);
            const f300 = Platform.getFactorsFromLookup(this._platformLookup, 300/3.6);
            console.log(`[PlatformLookup] Car ${this.id} rebuilt | rH=${(setupForLookup.rideHeight*1000).toFixed(1)}mm springK=${setupForLookup.springK} cLift=${totalCL.toFixed(2)} | kDrag@200=${f200.kDrag.toFixed(3)} kDrag@300=${f300.kDrag.toFixed(3)} kAero@200=${f200.kAero.toFixed(3)}`);
            // Also invalidate braking envelope (suspension affects grip + drag)
            this._env = null;
          },
          
          // Get platform factors at speed from this car's own lookup
          getPlatformFactors(v) {
            if (!this._platformLookup) this.rebuildPlatformLookup();
            return Platform.getFactorsFromLookup(this._platformLookup, v);
          },
          
          getEffectiveCLift() {
            // Use this car's speed-dependent suspension factors
            const factors = this.getPlatformFactors(this.v);
            const kAero = factors.kAero * this.slipstream.kCL;
            const partsMult = AssemblyParts.getMultiplier(this.assemblyParts, 'aero');
            return AeroModel.getEffectiveLift(
              this.setup.cLWing, this.setup.cLDiffuser,
              this.setup.wingAngle,
              kAero
            ) * partsMult;
          },
          
          getEffectiveCDrag() {
            // Use this car's speed-dependent suspension factors
            const factors = this.getPlatformFactors(this.v);
            // Split drag: Platform kDrag affects body only, not wing
            const dc = AeroModel.getDragComponents(this.setup.cDBody, this.setup.cDWing, this.setup.wingAngle);
            return (dc.body * factors.kDrag + dc.wing) * this.slipstream.kDrag;
          },
          
          // Get corner speed for given radius (matches single-car iterative approach)
          getCornerSpeed(radius) {
            const r = Math.abs(radius);
            const m = this.getTotalMass();
            const trackGrip = Track.gripMultiplier || 1.0;
            
            // ── TireModel: compound-specific grip (rubber + wet + temp) ──
            const compGrip = Weather.getCompoundGripFactor(this.tire.compound);
            // ── Driving mode µ multiplier ──
            const modeKey = this.skillSnapshot ? this.skillSnapshot.drivingModeKey : 'push';
            const modeGrip = TireModel.getDrivingModeGrip(modeKey);
            
            // Base grip (without suspension)
            const chassisMult = AssemblyParts.getMultiplier(this.assemblyParts, 'grip');
            const baseGrip = this.setup.tireGrip * this.tire.getGripMultiplier() * trackGrip * compGrip * modeGrip * chassisMult;
            const camberFactor = CamberModel.getFactors(this.setup.camber).kLat;
            const muBase = baseGrip * camberFactor;
            
            // Step 1: Basis v analytisch (nur Wings, kein Platform)
            const setupCl = AeroModel.getEffectiveLift(this.setup.cLWing, this.setup.cLDiffuser, this.setup.wingAngle, 1.0);
            const A = this.setup.frontalArea;
            const vBase = calcCornerSpeed(muBase, m, r, setupCl, A, AIR_DENSITY);
            
            // Step 2: Get suspension correction factors at vBase (from this car's lookup)
            const factors = this.getPlatformFactors(vBase);
            const kMech = factors.kMech;
            const kAero = factors.kAero;
            
            // Step 3: Recalculate WITH suspension + driver skill
            const muDriver = this.skillSnapshot ? this.skillSnapshot.muCorner : 1.0;
            const muEff = baseGrip * camberFactor * kMech * muDriver;
            const ClEff = AeroModel.getEffectiveLift(this.setup.cLWing, this.setup.cLDiffuser, this.setup.wingAngle, kAero);
            
            return calcCornerSpeed(muEff, m, r, ClEff, A, AIR_DENSITY);
          },
          
          // Get braking deceleration at given speed (matches envelope physics exactly)
          getBrakingAt(v) {
            const m = this.getTotalMass();
            
            // Use this car's speed-dependent platform factors (same as envelope)
            const factors = this.getPlatformFactors(v);
            const kMech = factors.kMech;
            const kAero = factors.kAero;
            
            // Grip: must match envelope's baseGrip exactly (trackGrip + chassisMult included)
            const trackGrip = Track.gripMultiplier || 1.0;
            const compGrip = Weather.getCompoundGripFactor(this.tire.compound);
            const modeKey = this.skillSnapshot ? this.skillSnapshot.drivingModeKey : 'push';
            const modeGrip = TireModel.getDrivingModeGrip(modeKey);
            const chassisMult = AssemblyParts.getMultiplier(this.assemblyParts, 'grip');
            const baseGrip = this.setup.tireGrip * this.tire.getGripMultiplier() * trackGrip * compGrip * modeGrip * chassisMult;
            const camberFactor = CamberModel.getFactors(this.setup.camber).kLong;
            const grip = baseGrip * camberFactor * kMech;
            
            // Downforce: split wing/diffuser model — no slipstream
            const cL = AeroModel.getEffectiveLift(this.setup.cLWing, this.setup.cLDiffuser, this.setup.wingAngle, kAero);
            const downforce = 0.5 * AIR_DENSITY * cL * this.setup.frontalArea * v * v;
            const normalForce = m * GRAVITY + downforce;
            
            // Grip-limited braking force (F = µ * Fz^0.98)
            const gripForce = grip * Math.pow(normalForce, TIRE_LOAD_SENSITIVITY);
            const effectiveBrake = Math.min(this.setup.brakeForce, gripForce);
            
            // ── DRIVER SKILL: Scale deceleration RESULT by decelFactor ──
            // Works whether grip-limited or brake-force-limited (high-DF)
            const decelFactor = this.skillSnapshot ? this.skillSnapshot.decelFactor : 1.0;
            return (effectiveBrake / m) * decelFactor;
          },
          
          // Get acceleration with full throttle
          getAccelerationWithThrottle() {
            const v = Math.max(this.v, 0.1);
            const m = this.getTotalMass();
            
            const cD = this.getEffectiveCDrag();
            const cL = this.getEffectiveCLift();
            
            // Debug: log once per car when at high speed
            if (v > 50 && !this._dbgAccelLogged) {
              this._dbgAccelLogged = true;
              const factors = this.getPlatformFactors(v);
              console.log(`[Accel] Car ${this.id} v=${(v*3.6).toFixed(0)}km/h cD=${cD.toFixed(4)} cL=${cL.toFixed(4)} kDrag=${factors.kDrag.toFixed(4)} kAero=${factors.kAero.toFixed(4)} rH=${(this.setup.rideHeight*1000).toFixed(1)}mm`);
              setTimeout(() => { this._dbgAccelLogged = false; }, 5000); // Re-log every 5s
            }
            
            const dragForce = 0.5 * AIR_DENSITY * cD * this.setup.frontalArea * v * v;
            const downforce = 0.5 * AIR_DENSITY * cL * this.setup.frontalArea * v * v;
            const normalForce = m * GRAVITY + downforce;
            const camberRR = CamberModel.getRollingResistanceFactor(this.setup.camber);
            const rollResist = this.setup.cRr * camberRR * normalForce;
            
            const powerMult = AssemblyParts.getMultiplier(this.assemblyParts, 'power');
            const driveForce = (this.setup.power * powerMult) / v;
            
            // Traction limit with compound-specific grip × driving mode
            const compGrip = Weather.getCompoundGripFactor(this.tire.compound);
            const modeKey = this.skillSnapshot ? this.skillSnapshot.drivingModeKey : 'push';
            const modeGrip = TireModel.getDrivingModeGrip(modeKey);
            const baseGrip = this.setup.tireGrip * this.tire.getGripMultiplier() * compGrip * modeGrip;
            const maxTraction = baseGrip * Math.pow(normalForce, TIRE_LOAD_SENSITIVITY);
            
            // Drive force is limited by BOTH power and traction
            const effectiveDrive = Math.min(driveForce, maxTraction);
            const netForce = effectiveDrive - dragForce - rollResist;
            const accelRaw = netForce / m;
            
            // ── DRIVER SKILL: Scale acceleration RESULT by accelFactor ──
            // Only scale POSITIVE acceleration (drive phase).
            // Negative accelRaw means drag > drive (past top speed) → pass through
            // unscaled so car properly decelerates to terminal velocity.
            const accelFactor = this.skillSnapshot ? this.skillSnapshot.accelFactor : 1.0;
            const accel = accelRaw >= 0 ? accelRaw * accelFactor : accelRaw;
            
            const throttlePct = Math.min(100, (effectiveDrive / this.setup.power) * v * 100);
            
            return { accel, throttlePct };
          }
        };
      },
      
      getDefaultColor(id) {
        const colors = [
          '#1e41ff', '#1e41ff', '#e8002d', '#e8002d', '#27f4d2',
          '#27f4d2', '#ff8000', '#ff8000', '#229971', '#229971',
          '#ff87bc', '#ff87bc', '#64c4ff', '#64c4ff', '#6692ff',
          '#6692ff', '#52e252', '#52e252', '#b6babd', '#b6babd'
        ];
        return colors[(id - 1) % colors.length];
      },
      
      // ─────────────────────────────────────────────────────────────────
      // RACE INITIALIZATION
      // ─────────────────────────────────────────────────────────────────
      
      initRace(carConfigs) {
        this.cars = [];
        this._cornerQueues = {};
        this._cornerQueueSets = {};
        this._updateCounter = 0;
        this._cachedPositions = null;
        this._cachedPositionsTime = -1;
        this._carByIdMap = null;
        this._carByIdMapSize = -1;
        CornerDebug.reset();  // reset debug log for new race
        
        // Grid positions: start BEHIND the start/finish line
        // Start line is at Track.startLineS (typically ~100m into first straight)
        // Cars start 10m, 25m, 40m, 55m, 70m behind start line (in first segment)
        const startLinePos = Track.startLineS || 100;
        const gridSpacing = 5;  // meters between cars (realistic F1 grid with 5.5m cars)
        
        for (let i = 0; i < carConfigs.length; i++) {
          const config = carConfigs[i];
          // Position behind start line (further back = lower grid position)
          const gridPosition = startLinePos - 10 - (i * gridSpacing);
          // Ensure positive position (wrap around if needed)
          const safePosition = gridPosition > 0 ? gridPosition : Track.lapLength + gridPosition;
          
          // Stagger grid lanes (odd=left, even=right like real F1 grid)
          const gridLane = (i % 2 === 0) ? -LANE_WIDTH : LANE_WIDTH;
          
          const car = this.createCar(i + 1, {
            ...config,
            startPosition: safePosition,
            startVelocity: 30  // Rolling start at ~30 m/s (108 km/h)
          });
          // Set initial grid lane (staggered like F1 start)
          car.lane = gridLane;
          car.targetLane = gridLane;
          car.visualLane = gridLane;
          
          // Set initial active compound in tire allocation
          if (car.tireAllocation && config.compound) {
            car.tireAllocation.activeCompound = config.compound;
            // Mark first set of this compound as used
            const sets = car.tireAllocation.sets[config.compound];
            if (sets && sets.length > 0) sets[0].used = true;
          }
          this.cars.push(car);
        }
        
        this.isActive = true;
        return this.cars;
      },
      
      // ─────────────────────────────────────────────────────────────────
      // SIMULATION UPDATE (called each physics step for all cars)
      // Lane management runs every step (critical for overlap prevention).
      // Slipstream runs at reduced rate for performance.
      // ─────────────────────────────────────────────────────────────────
      _updateCounter: 0,
      
      update() {
        if (!this.isActive || this.cars.length === 0) return;
        
        this._updateCounter++;
        
        // 1. Lane management: EVERY step (critical for corner gap enforcement)
        this.updateLanes();
        
        // 2. Slipstream: every 5th step (20Hz — O(n²), not safety-critical)
        if (this._updateCounter % 5 === 0) {
          for (const car of this.cars) {
            car.slipstream = this.getSlipstreamForCar(car);
          }
        }
        
        // Note: Physics update is done in Simulation.step()
        // Pit update is done in Simulation.step() for controlled car only
      },
      
      // ─────────────────────────────────────────────────────────────────
      // PIT LANE LOGIC for the controlled car
      // ─────────────────────────────────────────────────────────────────
      updateCarPit(car, simTime) {
        if (!Track.pit.enabled) return;
        if (!car.pit) return;
        
        const pit = Track.pit;
        const sNow = Track.normalize(car.s);
        const prevS = car.prevS || car.s;
        
        const crossedEntry = Track.didCrossLine(prevS, car.s, pit.startS);
        const crossedBox   = Track.didCrossLine(prevS, car.s, pit.stopS);
        const crossedExit  = Track.didCrossLine(prevS, car.s, pit.endS);
        
        // Only sync UI for the controlled car
        const isControlled = car.id === (typeof RaceUI !== 'undefined' ? RaceUI.controlledCarId : 1);
        const syncUI = () => { if (isControlled) UI.syncPitButtons(); };
        
        // Commit when crossing entry line while armed
        if (!car.pit.inLane && car.pit.armed && crossedEntry) {
          car.pit.committed = true;
        }
        
        // Enter pit lane at entry line (if committed)
        if (!car.pit.inLane && car.pit.committed && crossedEntry) {
          car.pit.inLane = true;
          car.pit.limiter = true;
          car.pit.phase = 'entry';
          car.pit.armed = false;
          syncUI();
        }
        
        // In pit lane progression
        if (car.pit.inLane) {
          const limStart = pit.limiterStartS || pit.startS;
          const limEnd = pit.limiterEndS || pit.endS;
          
          // Progressive braking before limiter zone (entry phase)
          if (car.pit.phase === 'entry' || car.pit.phase === 'toBox') {
            const distToLimiter = Track.forwardDistance(sNow, limStart);
            if (distToLimiter > 0 && sNow < limStart) {
              // Brake progressively to pit speed limit before limiter zone
              const brakeDist = Math.max(50, distToLimiter);
              const targetV = pit.speedLimit;
              if (car.v > targetV) {
                const decelNeeded = (car.v * car.v - targetV * targetV) / (2 * brakeDist);
                const maxDecel = car.getBrakingAt(car.v);
                const frac = Math.min(1, decelNeeded / maxDecel);
                car.v = Math.max(targetV, car.v - decelNeeded * SIM_DT * 2);
                car.brake = Math.max(20, frac * 100);
                car.throttle = 0;
              }
            }
          }
          
          // Hard speed limiter in limiter zone
          const inLimiterZone = (sNow >= limStart && sNow <= limEnd);
          if (inLimiterZone) {
            car.pit.limiter = true;
            // Exit phase: accelerate UP TO speed limit within limiter zone
            if (car.pit.phase === 'exit' && car.v < pit.speedLimit) {
              const v = Math.max(car.v, 0.5);
              const m = car.getTotalMass();
              const setup = car.setup;
              const driveForce = setup.power / Math.max(v, 1);
              const cDPit = AeroModel.getEffectiveDrag(setup.cDBody, setup.cDWing, setup.wingAngle);
              const cLPit = AeroModel.getEffectiveLift(setup.cLWing, setup.cLDiffuser, setup.wingAngle, 1.0);
              const dragForce = 0.5 * AIR_DENSITY * cDPit * setup.frontalArea * v * v;
              const downforce = 0.5 * AIR_DENSITY * cLPit * setup.frontalArea * v * v;
              const camberRR_pit = CamberModel.getRollingResistanceFactor(setup.camber);
              const rollResist = setup.cRr * camberRR_pit * (m * GRAVITY + downforce);
              const accel = (driveForce - dragForce - rollResist) / m;
              car.v = Math.min(pit.speedLimit, car.v + accel * SIM_DT);
              car.throttle = 80;
              car.brake = 0;
            } else {
              // Cap at speed limit (entry / toBox)
              car.v = Math.min(car.v, pit.speedLimit);
            }
          }
          
          // After limiter zone: full acceleration to rejoin (exit phase)
          if (sNow > limEnd && car.pit.phase === 'exit') {
            car.pit.limiter = false;
            // Full acceleration — car is still in pit lane (updateCarPhysics returns early)
            const v = Math.max(car.v, 1.0);
            const m = car.getTotalMass();
            const setup = car.setup;
            // Use the same acceleration model as getAccelerationWithThrottle
            const driveForce = setup.power / Math.max(v, 1);
            const cDPitEx = AeroModel.getEffectiveDrag(setup.cDBody, setup.cDWing, setup.wingAngle);
            const cLPitEx = AeroModel.getEffectiveLift(setup.cLWing, setup.cLDiffuser, setup.wingAngle, 1.0);
            const dragForce = 0.5 * AIR_DENSITY * cDPitEx * setup.frontalArea * v * v;
            const downforce = 0.5 * AIR_DENSITY * cLPitEx * setup.frontalArea * v * v;
            const camberRR_pitExit = CamberModel.getRollingResistanceFactor(setup.camber);
            const rollResist = setup.cRr * camberRR_pitExit * (m * GRAVITY + downforce);
            const netForce = driveForce - dragForce - rollResist;
            const accel = Math.max(netForce / m, 0.1); // Small minimum to prevent stalling at low speed
            car.v = car.v + accel * SIM_DT;
            car.throttle = 100;
            car.brake = 0;
          }
          
          if (car.pit.phase === 'entry') {
            car.pit.phase = 'toBox';
            car.pit.stopped = false;
            syncUI();
          }
          
          if (car.pit.phase === 'toBox') {
            const distToBox = Track.forwardDistance(sNow, pit.stopS);
            if (distToBox <= pit.boxStopTolerance || crossedBox) {
              car.s = pit.stopS;
              car.v = 0;
              car.pit.stopped = true;
              car.pit.phase = 'stopped';
              syncUI();
              
              // Apply pending setup changes (only for controlled car)
              if (isControlled && typeof SetupUI !== 'undefined') SetupUI.tryApplyPending();
            }
          }
          
          if (car.pit.phase === 'exit') {
            if (crossedExit || (pit.startS < pit.endS && sNow >= pit.endS)) {
              car.pit.inLane = false;
              car.pit.limiter = false;
              car.pit.committed = false;
              car.pit.phase = 'merge';
              syncUI();
            }
          }
          
          if (car.pit.phase === 'merge') {
            car.pit.phase = 'none';
            syncUI();
          }
        }
      },
      
      // ─────────────────────────────────────────────────────────────────
      // FULL CAR PHYSICS - Complete physics simulation for each car
      // Identical to original Simulation.step() but per-car
      // ─────────────────────────────────────────────────────────────────
      
      // Build braking envelope for a car (proper implicit integration, matching single-car logic)
      buildEnvelopeForCar(car, distTarget, vTarget, key) {
        // ALWAYS build for fixed 400m range with fixed ds
        // This prevents curve instability when rebuilt at different distances
        // (different effectiveDist → different ds → different Euler results)
        const maxEnvelopeDist = 400;
        const ds = 0.75;
        const n = Math.max(1, Math.ceil(maxEnvelopeDist / ds));
        const vMax = new Float64Array(n + 1);

        let v = Math.max(0.1, vTarget);
        vMax[0] = v;

        // Pre-compute constants that don't change with v
        const m = car.getTotalMass();
        const setup = car.setup;
        const trackGrip = Track.gripMultiplier || 1.0;
        const compGrip = Weather.getCompoundGripFactor(car.tire.compound);
        const modeKey = car.skillSnapshot ? car.skillSnapshot.drivingModeKey : 'push';
        const modeGrip = TireModel.getDrivingModeGrip(modeKey);
        const chassisMult = AssemblyParts.getMultiplier(car.assemblyParts, 'grip');
        const baseGrip = setup.tireGrip * car.tire.getGripMultiplier() * trackGrip * compGrip * modeGrip * chassisMult;
        const camberFactor = CamberModel.getFactors(setup.camber).kLong; // Longitudinal camber effect
        const rhoHalfA = 0.5 * AIR_DENSITY * setup.frontalArea;
        
        // ── DRIVER SKILL: decelFactor scales braking in envelope ──
        // Must match getBrakingAt() so envelope reflects actual braking ability
        const decelFactor = car.skillSnapshot ? car.skillSnapshot.decelFactor : 1.0;

        for (let i = 1; i <= n; i++) {
          // Implicit integration: compute braking at current v (use car's own platform lookup)
          const factors = car.getPlatformFactors(v);
          const kMech = factors.kMech;
          const kAero = factors.kAero;
          
          // Effective values at this v (matching single-car buildEnvelope)
          const gripEff = baseGrip * camberFactor * kMech;
          const ClEff = AeroModel.getEffectiveLift(setup.cLWing, setup.cLDiffuser, setup.wingAngle, kAero);
          
          // Downforce and brake force at this v
          const downforce = rhoHalfA * ClEff * v * v;
          const normalForce = m * GRAVITY + downforce;
          // Load-sensitive grip: F = µ * Fz^0.98 (must match getBrakingAt)
          const gripForce = gripEff * Math.pow(normalForce, TIRE_LOAD_SENSITIVITY);
          const effectiveBrake = Math.min(setup.brakeForce, gripForce);
          const b = (effectiveBrake / m) * decelFactor * BRAKE_SAFETY;
          
          // Backward Euler: v increases (we move away from corner)
          const dv = (b / Math.max(0.5, v)) * ds;
          v = v + dv;
          vMax[i] = v;
        }

        return {
          key,
          vMax,
          ds,
          distBuilt: maxEnvelopeDist,
          vTarget,
          builtFuel: car.fuel
        };
      },
      
      // Get envelope speed limit for a car (matches single-car envelopeLimit)
      envelopeLimitForCar(env, distToTarget) {
        if (!env) return Infinity;
        if (distToTarget > env.distBuilt) return Infinity;
        if (distToTarget < 0) return env.vMax[0];
        
        const exactIdx = distToTarget / env.ds;
        const i = Math.floor(exactIdx);
        const frac = exactIdx - i;
        
        if (i >= env.vMax.length - 1) {
          return env.vMax[env.vMax.length - 1];
        }
        
        const v0 = env.vMax[i];
        const v1 = env.vMax[i + 1];
        return v0 + frac * (v1 - v0);
      },
      
      // Full physics step for one car
      updateCarPhysics(car, simTime) {
        // Safety checks to prevent NaN propagation
        if (!car || !car.setup) return;
        if (!Number.isFinite(car.s)) car.s = 0;
        if (!Number.isFinite(car.v)) car.v = 10;
        if (!Number.isFinite(car.fuel)) car.fuel = car.setup.fuelCapacity || 100;
        
        // Initialize per-segment skill snapshots if not yet created
        if (car.skills && !car.segSkillSnapshots) {
          const mode = DrivingMode.current;  // all cars use same driving mode
          car.segSkillSnapshots = DriverSkills.createAllSegmentSnapshots(car.skills, Track.segments.length, mode);
          car.skillSnapshot = car.segSkillSnapshots[0];
          car._lastSkillSegIndex = -1;
        }
        
        car.prevS = car.s;
        const segInfo = Track.atPosition(car.s);
        if (!segInfo || !segInfo.segment) return;
        
        const isCorner = segInfo.segment.kind === 'corner';
        const setup = car.setup;
        
        // ── Update current segment's skill snapshot ──
        // Switch to this segment's pre-computed snapshot when crossing segment boundary
        if (car.segSkillSnapshots && segInfo.index !== car._lastSkillSegIndex) {
          car._lastSkillSegIndex = segInfo.index;
          car.skillSnapshot = car.segSkillSnapshots[segInfo.index] || car.skillSnapshot;
        }
        
        // Skip normal physics for cars in pit lane (handled by pit update logic)
        if (car.pit && car.pit.inLane) {
          car.s += car.v * SIM_DT;
          return;
        }
        
        // ─────────────────────────────────────────────
        // CORNER QUEUE: Match speed of car ahead, maintain safe gap.
        // Instead of freezing to a stop, gradually adjust speed.
        // ─────────────────────────────────────────────
        if (car.frozenAtCornerEntry && car.waitingForCar) {
          const ahead = car.waitingForCar;
          const gap = Track.forwardDistance(car.s, ahead.s);
          const targetGap = MultiCarRace.CORNER_MIN_GAP;
          const aheadSpeed = Math.max(ahead.v, 0.5);
          
          // Speed target: match car ahead, then adjust for gap error
          const gapError = targetGap - gap;  // positive = too close
          const gapCorrection = Math.max(0, gapError * 2.0);  // stronger correction
          const vTarget = Math.max(0.5, aheadSpeed - gapCorrection);
          
          if (car.v > vTarget) {
            const maxDecel = car.getBrakingAt(car.v);
            car.v = Math.max(vTarget, car.v - Math.max(0.5, maxDecel) * SIM_DT);
            car.brake = Math.min(100, ((car.v - vTarget) / Math.max(car.v, 1)) * 200);
          } else {
            car.v = vTarget;
            car.brake = 0;
          }
          car.throttle = car.brake > 0 ? 0 : 20;
          car.a = 0;
          car.s += car.v * SIM_DT;
          
          // ── HARD CLAMP: never pass the car we're waiting for ──
          const gapAfterMove = Track.forwardDistance(car.s, ahead.s);
          if (gapAfterMove < targetGap && gapAfterMove < Track.lapLength / 2) {
            car.s = Track.normalize(ahead.s - targetGap);
            car.v = Math.min(car.v, aheadSpeed);
          }
          
          car._env = null;
          return;
        }
        
        // ─────────────────────────────────────────────
        // CORNER PHYSICS: single file, speed matching + gap enforcement
        // ─────────────────────────────────────────────
        if (isCorner) {
          // Own corner speed based on setup
          const vCornerOwn = car.getCornerSpeed(segInfo.segment.radius);
          
          // ── DIRTY AIR: apply half the downforce loss to own corner speed ──
          // kCL < 1.0 → less downforce → less grip → lower corner speed
          // Halved effect: penalty = (1 - kCL) * 0.5
          // Full overlap kCL ≈ 0.70 → 15% reduction → car targets 85% of clean speed
          const kCL = car.slipstream ? car.slipstream.kCL : 1.0;
          let vCorner = vCornerOwn * (1 - (1 - kCL) * 0.5);
          vCorner = Math.max(vCorner, 5);
          const vCornerAfterDirtyAir = vCorner;  // save before carAhead cap
          
          // Then cap to car ahead's speed (can't go faster than the car in front)
          // Only if carAhead is actually in the SAME corner segment
          if (car.carAhead) {
            const aheadSeg = Track.atPosition(car.carAhead.s);
            if (aheadSeg.index === segInfo.index) {
              const aheadV = car.carAhead.v;
              if (Number.isFinite(aheadV) && aheadV > 0.5) {
                vCorner = Math.min(vCorner, aheadV);
              }
            }
          }
          
          // Ensure vCorner is sane
          if (!Number.isFinite(vCorner) || vCorner < 1) {
            vCorner = Math.max(vCornerOwn, 5);
          }
          
          // Corner speed enforcement: set car.v to vCorner (brake or accelerate)
          // ── CORNER DEBUG: log at corner entry (first step in this corner) ──
          if (segInfo.index === CornerDebug.cornerIdx && (car._dbgLastCornerLap == null || car._dbgLastCornerLap !== car.lap)) {
            car._dbgLastCornerLap = car.lap;
            CornerDebug.logCornerEntry(car, car.lap, {
              vBefore: car.v,
              vCornerOwn,
              kCL,
              vCornerDirty: vCornerAfterDirtyAir,
              vCornerFinal: vCorner,
              muCorner: car.skillSnapshot ? car.skillSnapshot.muCorner : null,
              tireCond: car.tire.condition,
              fuel: car.fuel,
              carAheadV: car.carAhead ? car.carAhead.v : null,
            });
          }
          if (car.v > vCorner) {
            const brakingVal = car.getBrakingAt(car.v) * SIM_DT;
            car.brake = brakingVal > 0 ? Math.min(100, ((car.v - vCorner) / brakingVal) * 100) : 100;
            car.v = vCorner;
          } else if (car.v < vCorner) {
            // Accelerate back toward corner speed (limited by friction circle)
            car.v = Math.min(vCorner, car.v + 3.0 * SIM_DT);  // ~3 m/s² mid-corner accel
            car.brake = 0;
          }
          
          // Maintain speed against resistance
          const v = Math.max(car.v, 0.1);
          const m = car.getTotalMass();
          const dragForce = 0.5 * AIR_DENSITY * car.getEffectiveCDrag() * setup.frontalArea * v * v;
          const downforce = 0.5 * AIR_DENSITY * car.getEffectiveCLift() * setup.frontalArea * v * v;
          const normalForce = m * GRAVITY + downforce;
          const camberRR_corner = CamberModel.getRollingResistanceFactor(setup.camber);
          const rollResist = setup.cRr * camberRR_corner * normalForce;
          const resistanceForce = dragForce + rollResist;
          const powerNeeded = resistanceForce * v;
          car.throttle = Math.min(100, (powerNeeded / setup.power) * 100);
          car.a = 0;
          car.vLimit = null;
          
          car.s += car.v * SIM_DT;
          
          // ── HARD GAP ENFORCEMENT: prevent passing through car ahead ──
          if (car.carAhead && !(car.carAhead.pit && car.carAhead.pit.inLane)) {
            const gapAfterMove = Track.forwardDistance(car.s, car.carAhead.s);
            // If gap is tiny or car has overtaken (gapAfterMove > lapLength/2 means we passed)
            if (gapAfterMove < MultiCarRace.CORNER_MIN_GAP && gapAfterMove < Track.lapLength / 2) {
              // Push car back to maintain minimum gap
              car.s = Track.normalize(car.carAhead.s - MultiCarRace.CORNER_MIN_GAP);
              car.v = Math.min(car.v, car.carAhead.v);
            }
          }
          
          car._env = null;
          
        } else {
          // ─────────────────────────────────────────────
          // STRAIGHT PHYSICS WITH BRAKING ENVELOPE
          // No car-ahead interaction on straights (infinite lanes)
          // ─────────────────────────────────────────────
          const sNow = Track.normalize(car.s);
          const nextCorner = Track.getNextCorner(car.s);
          
          if (nextCorner.found && nextCorner.distance > 0) {
            // ── DRIVER SKILL: Use the NEXT CORNER's skill snapshot for vTarget ──
            // On the straight we already need to know the corner's grip to build
            // the correct braking envelope. Temporarily swap in the corner segment's
            // pre-computed snapshot, then restore the current segment's snapshot.
            const savedSnapshot = car.skillSnapshot;
            if (car.segSkillSnapshots && nextCorner.cornerIndex < car.segSkillSnapshots.length) {
              car.skillSnapshot = car.segSkillSnapshots[nextCorner.cornerIndex];
            }
            let vTarget = car.getCornerSpeed(nextCorner.segment.radius);
            car.skillSnapshot = savedSnapshot;  // restore current segment's snapshot
            
            // ── DIRTY AIR: apply same penalty as in-corner physics ──
            // Without this, the envelope targets clean-air speed but the car
            // enters the corner at dirty-air speed → late braking overshoot
            const kCL_env = car.slipstream ? car.slipstream.kCL : 1.0;
            if (kCL_env < 1.0) {
              vTarget = vTarget * (1 - (1 - kCL_env) * 0.5);
              vTarget = Math.max(vTarget, 5);
            }
            
            // Key-based envelope caching (matching single-car ensureCornerEnvelope)
            // Build once per corner, then NEVER rebuild based on time.
            // Only rebuild when corner changes or fuel changes significantly.
            // This prevents ANY mid-approach oscillation from envelope shifts.
            const envKey = `corner:${nextCorner.cornerIndex}`;
            const needByKey = !car._env || car._env.key !== envKey;
            const needByFuel = !car._env || Math.abs(car.fuel - (car._env.builtFuel || 0)) >= 5.0;
            // Rebuild when tire condition changes significantly (stale grip in envelope)
            const needByTire = !car._env || Math.abs(car.tire.condition - (car._env.builtTireCond || 100)) >= 5.0;
            // Rebuild when dirty air changes significantly (target vCorner shifted)
            const needByDirtyAir = !car._env || Math.abs(kCL_env - (car._env.builtKCL || 1.0)) >= 0.03;
            
            const envRebuilt = needByKey || needByFuel || needByTire || needByDirtyAir;
            if (envRebuilt) {
              car._env = this.buildEnvelopeForCar(car, nextCorner.distance, vTarget, envKey);
              car._env.builtTireCond = car.tire.condition;
              car._env.builtKCL = kCL_env;
              car._lastEnvBuildTime = simTime;
            }
            
            // ── CORNER DEBUG: log approach values (only once per approach, when envelope is first built) ──
            if (nextCorner.cornerIndex === CornerDebug.cornerIdx && envRebuilt) {
              const snapForCorner = (car.segSkillSnapshots && nextCorner.cornerIndex < car.segSkillSnapshots.length)
                ? car.segSkillSnapshots[nextCorner.cornerIndex] : null;
              CornerDebug.logApproach(car, car.lap, {
                vTarget,
                muCorner: snapForCorner ? snapForCorner.muCorner : null,
                decelF: snapForCorner ? snapForCorner.decelFactor : null,
                kCL: kCL_env,
                tireCond: car.tire.condition,
                fuel: car.fuel,
                rebuilt: [needByKey ? 'key' : '', needByFuel ? 'fuel' : '', needByTire ? 'tire' : '', needByDirtyAir ? 'dirtyAir' : ''].filter(Boolean).join('+') || 'none',
              });
            }
            
            const distToEntry = nextCorner.distance;
            const vLimitHere = this.envelopeLimitForCar(car._env, distToEntry);
            car.vLimit = Number.isFinite(vLimitHere) ? vLimitHere : null;
            
            // Final approach safety: when very close to corner, hard-limit to vTarget
            // This prevents any accumulated error from causing a speed spike at entry
            if (distToEntry < car.v * SIM_DT * 3) {
              // Within ~3 timesteps of corner entry: clamp to corner speed
              if (car.v > vTarget) {
                car.v = vTarget;
                car.brake = 50;
                car.throttle = 0;
                car.a = 0;
                car.s += car.v * SIM_DT;
                car._env = null;
                return;
              }
            }
            
            // Get free acceleration
            const { accel: accelFree, throttlePct } = car.getAccelerationWithThrottle();
            
            // Check next step
            const dsStep = car.v * SIM_DT;
            const distNext = distToEntry - dsStep;
            const vLimitNext = this.envelopeLimitForCar(car._env, distNext);
            const vNextFree = car.v + accelFree * SIM_DT;
            
            const overCurveNow = car.v > vLimitHere + ENVELOPE_EPS;
            const overCurveNext = vNextFree > vLimitNext + ENVELOPE_EPS;
            
            if (overCurveNow || overCurveNext) {
              // BRAKING — aim for the envelope limit at the next distance point
              const vAim = Math.max(vTarget, vLimitNext);
              const aNeeded = (vAim - car.v) / SIM_DT;
              
              // Always apply at least light braking when over the curve
              // (prevents brake=0 which could cause gas on next tick)
              const bMax = car.getBrakingAt(car.v);
              if (aNeeded >= 0) {
                // Car is below vAim but still flagged as over curve
                // → Apply light engine braking to smoothly converge
                car.throttle = 0;
                car.brake = 5;  // Light braking to stay on curve
                car.a = -bMax * 0.1;
              } else {
                const frac = Math.min(1, Math.abs(aNeeded) / bMax);
                const m = car.getTotalMass();
                const actualBrakeForce = bMax * frac * m;
                const brakePctOfMax = (actualBrakeForce / setup.brakeForce) * 100;
                
                car.throttle = 0;
                car.brake = Math.max(5, brakePctOfMax);  // Minimum 5% brake
                car.a = -bMax * frac;
              }
              
              car.v = Math.max(0.1, car.v + car.a * SIM_DT);
              car.s += car.v * SIM_DT;
              
            } else {
              // FULL THROTTLE (or Lift & Coast for player/AI)
              const controlledId = typeof RaceUI !== 'undefined' ? RaceUI.controlledCarId : 1;
              const isControlled = car.id === controlledId;
              
              // Check if coasting: manual L&C button OR automatic AI L&C (applies to all cars)
              const playerCoasting = isControlled && typeof LiftCoast !== 'undefined' && LiftCoast.active;
              const aiCoasting = car.ai && car.ai.coastActive;
              
              if (playerCoasting || aiCoasting) {
                // LIFT & COAST: no throttle, only drag deceleration
                const vCoast = Math.max(car.v, 0.1);
                const mCoast = car.getTotalMass();
                const cDCoast = car.getEffectiveCDrag();
                const cLCoast = car.getEffectiveCLift();
                const dragF = 0.5 * AIR_DENSITY * cDCoast * setup.frontalArea * vCoast * vCoast;
                const dfCoast = 0.5 * AIR_DENSITY * cLCoast * setup.frontalArea * vCoast * vCoast;
                const nfCoast = mCoast * GRAVITY + dfCoast;
                const camberRR_coast = CamberModel.getRollingResistanceFactor(setup.camber);
                const coastDecel = (dragF + setup.cRr * camberRR_coast * nfCoast) / mCoast;
                
                car.throttle = 0;
                car.brake = 0;
                car.a = -coastDecel;
                
                car.v = Math.max(0.1, car.v - coastDecel * SIM_DT);
                car.s += car.v * SIM_DT;
                
                // Deactivate L&C if speed too low or at corner
                if (car.v * 3.6 < 80 || distToEntry < 5) {
                  if (playerCoasting) LiftCoast.active = false;
                  if (aiCoasting) car.ai.coastActive = false;
                }
              } else {
                car.throttle = throttlePct;
                car.brake = 0;
                car.a = accelFree;
                
                car.v = Math.max(0.1, car.v + car.a * SIM_DT);
                car.s += car.v * SIM_DT;
              }
            }
            
            // Snap at corner entry
            if (distToEntry < 1.0 && car.v > vTarget) {
              car.v = vTarget;
              car.a = 0;
            }
            
          } else {
            // No corner ahead - full throttle
            const { accel, throttlePct } = car.getAccelerationWithThrottle();
            car.throttle = throttlePct;
            car.brake = 0;
            car.a = accel;
            car.vLimit = null;
            
            car.v = Math.max(0, car.v + accel * SIM_DT);
            car.s += car.v * SIM_DT;
            
            car._env = null;
          }
        }
        
        // ── Safety: cap speed to prevent runaway (physics breakdown) ──
        // 500 km/h = 138.9 m/s — well above any realistic F1 top speed
        if (car.v > 139) car.v = 139;
        
        // ─────────────────────────────────────────────
        // LAP COUNTING & TIMING (sub-ms interpolation)
        // ─────────────────────────────────────────────
        if (car.s >= Track.lapLength) {
          // Interpolate exact crossing fraction within this step
          const overshoot = car.s - Track.lapLength;
          const stepDist = car.s - car.prevS; // always positive this step
          const fraction = stepDist > 0.001 ? overshoot / stepDist : 0;
          const crossTime = simTime + SIM_DT - fraction * SIM_DT; // exact crossing moment

          car.s -= Track.lapLength;
          car.lap++;
          
          // ── DRIVER SKILL: Generate new per-segment skill snapshots ──
          if (car.skills) {
            const mode = DrivingMode.current;  // all cars use same driving mode
            car.segSkillSnapshots = DriverSkills.createAllSegmentSnapshots(car.skills, Track.segments.length, mode);
            car._lastSkillSegIndex = -1;
            // Invalidate braking envelope — muCorner changed, old envelope is stale
            car._env = null;
            // ── CORNER DEBUG: auto-print table after each lap ──
            if (car.id === CornerDebug.carId && CornerDebug.enabled && CornerDebug._rows.length > 0) {
              CornerDebug.print();
            }
          }
          
          // Lap timing with interpolated precision
          if (car.lapStartTime > 0) {
            car.lastLapTime = crossTime - car.lapStartTime;
            car.lastLapFuelUsed = car.fuelAtLapStart - car.fuel;
            
            if (!car.bestLapTime || car.lastLapTime < car.bestLapTime) {
              car.bestLapTime = car.lastLapTime;
            }
            
            // ── Sync Telemetry for controlled car ──
            const controlledId2 = typeof RaceUI !== 'undefined' ? RaceUI.controlledCarId : 1;
            if (car.id === controlledId2 && car.lap > 0) {
              Telemetry.finalizeLap(car.lap - 1, car.lastLapTime);
            }
            
            // Finalize last sector of the completed lap
            const lastSectorTime = crossTime - car.sectorStartTime;
            if (car.currentSector >= 1 && car.currentSector <= 3) {
              car.sectors.current[car.currentSector - 1] = lastSectorTime;
              const pb = car.sectors.personalBest[car.currentSector - 1];
              if (pb === null || lastSectorTime < pb) {
                car.sectors.personalBest[car.currentSector - 1] = lastSectorTime;
              }
            }
            
            // Save sector times from this lap to "last"
            car.sectors.last = [...car.sectors.current];
            car.sectors.current = [null, null, null];
          }
          car.lapStartTime = crossTime;
          car.fuelAtLapStart = car.fuel;
          car.currentSector = 1;
          car.sectorStartTime = crossTime;
        }
        
        // ─────────────────────────────────────────────
        // SECTOR TIMING (sub-ms interpolation)
        // ─────────────────────────────────────────────
        const newSector = Track.getSector(car.s);
        if (newSector !== car.currentSector) {
          // Interpolate exact sector boundary crossing
          const sectorBounds = Track.getSectorBoundaries();
          // The boundary we just crossed is at the start of the new sector
          const boundaryS = sectorBounds[newSector - 1] || 0;
          const stepDist = car.s - car.prevS;
          let crossFrac = 0;
          if (stepDist > 0.001) {
            const distPastBoundary = Track.normalize(car.s) - boundaryS;
            crossFrac = distPastBoundary > 0 ? distPastBoundary / stepDist : 0;
            crossFrac = Math.max(0, Math.min(1, crossFrac));
          }
          const sectorCrossTime = simTime + SIM_DT - crossFrac * SIM_DT;

          const sectorTime = sectorCrossTime - car.sectorStartTime;
          const completedSector = car.currentSector - 1;
          
          if (completedSector >= 0 && completedSector < 3) {
            car.sectors.current[completedSector] = sectorTime;
            
            const pb = car.sectors.personalBest[completedSector];
            if (pb === null || sectorTime < pb) {
              car.sectors.personalBest[completedSector] = sectorTime;
            }
          }
          
          car.currentSector = newSector;
          car.sectorStartTime = sectorCrossTime;
        }
        
        // ─────────────────────────────────────────────
        // FUEL & TIRE CONSUMPTION & PARTS WEAR
        // ─────────────────────────────────────────────
        const deltaS = Math.abs(car.s - car.prevS);
        
        // Assembly parts km tracking
        if (car.assemblyParts) {
          AssemblyParts.update(car.assemblyParts, deltaS);
        }
        
        // Fuel (throttle-dependent, same model as single-car mode)
        // ── DRIVER SKILL: Fuel efficiency multiplier ──
        const skillFuelMult = car.skillSnapshot ? car.skillSnapshot.fuelEffMult : 1.0;
        const fuelRate = 0.04 * (car.throttle / 100) * skillFuelMult;
        car.fuel = Math.max(0, car.fuel - fuelRate * SIM_DT);
        
        // Tire wear (uses same model as original)
        if (car.tire) {
          const v = Math.max(car.v, 0.1);
          const m = car.getTotalMass();
          const downforce = 0.5 * AIR_DENSITY * car.getEffectiveCLift() * setup.frontalArea * v * v;
          const normalForce = m * GRAVITY + downforce;
          
          // Cornering force demand
          const segInfo = Track.atPosition(car.s);
          let lateralForce = 0;
          if (segInfo.segment.kind === 'corner' && segInfo.segment.radius) {
            lateralForce = m * v * v / Math.abs(segInfo.segment.radius);
          }
          
          // Brake force
          const brakeForce = car.brake > 0 ? (car.brake / 100) * setup.brakeForce : 0;
          
          // Total grip used (compound-specific grip for utilization estimate)
          const totalDemand = Math.sqrt(lateralForce * lateralForce + brakeForce * brakeForce);
          const compGripForWear = Weather.getCompoundGripFactor(car.tire.compound);
          const maxGrip = setup.tireGrip * car.tire.getGripMultiplier() * compGripForWear * normalForce;
          const gripUtilization = Math.min(1, totalDemand / Math.max(1, maxGrip));
          
          // Wear: TireModel compound wear mult + driving mode wear mult
          const comp = car.tire.getCompound();
          const utilizationFactor = Math.pow(gripUtilization, 1.4);
          // ── DRIVER SKILL: Tyre wear multiplier ──
          const skillTyreWear = car.skillSnapshot ? car.skillSnapshot.tyreWearMult : 1.0;
          // ── TireModel: compound-specific wear stress multiplier ──
          const tireModelWear = Weather.getCompoundWearMult(car.tire.compound);
          // ── Driving mode wear multiplier ──
          const modeKeyW = car.skillSnapshot ? car.skillSnapshot.drivingModeKey : 'push';
          const modeWear = TireModel.getDrivingModeWear(modeKeyW);
          // ── Platform suspension wear (bouncing/bottoming from this car's setup) ──
          const platformWear = car.getPlatformFactors(v).kWear;
          const wearAmount = deltaS * utilizationFactor * comp.wearRate * skillTyreWear * tireModelWear * modeWear * platformWear;
          car.tire.condition = Math.max(0, car.tire.condition - wearAmount);
          car.tire.distanceTraveled += deltaS;
        }
        
        // ─────────────────────────────────────────────
        // VISUAL SMOOTHING
        // ─────────────────────────────────────────────
        if (car.visualS === undefined) car.visualS = car.s;
        car.visualS += (car.s - car.visualS) * 0.15;
        if (Math.abs(car.visualS - car.s) < 1) car.visualS = car.s;
        
        // Wrap-around
        if (car.visualS < 0) car.visualS += Track.lapLength;
        if (car.visualS >= Track.lapLength) car.visualS -= Track.lapLength;
        
        // Update current lap time
        car.currentLapTime = simTime - car.lapStartTime;
      },
      
      // ─────────────────────────────────────────────────────────────────
      // POSITION SORTING & GAP CALCULATION
      // ─────────────────────────────────────────────────────────────────
      
      // Cached positions array — refreshed once per call to getPositions()
      _cachedPositions: null,
      _cachedPositionsTime: -1,
      
      getPositions() {
        // Cache for the current sim time to avoid repeated sorts
        const t = typeof Simulation !== 'undefined' ? Simulation.time : 0;
        if (this._cachedPositions && this._cachedPositionsTime === t) {
          return this._cachedPositions;
        }
        this._cachedPositions = [...this.cars].sort((a, b) => {
          if (a.lap !== b.lap) return b.lap - a.lap;
          return b.s - a.s;
        });
        this._cachedPositionsTime = t;
        return this._cachedPositions;
      },
      
      getGapToLeader(car) {
        const positions = this.getPositions();
        if (positions[0] === car) return 0;
        
        const leader = positions[0];
        const distanceGap = (leader.lap - car.lap) * Track.lapLength + 
                           (leader.s - car.s);
        const avgSpeed = (leader.v + car.v) / 2 || 1;
        const rawGap = distanceGap / avgSpeed;
        
        if (!car._smoothedLeaderGap || !Number.isFinite(car._smoothedLeaderGap)) {
          car._smoothedLeaderGap = rawGap;
        } else {
          car._smoothedLeaderGap = car._smoothedLeaderGap * 0.85 + rawGap * 0.15;
        }
        return car._smoothedLeaderGap;
      },
      
      getGapToCarAhead(car) {
        const positions = this.getPositions();
        const idx = positions.indexOf(car);
        if (idx <= 0) return null;
        
        const carAhead = positions[idx - 1];
        const distGap = (carAhead.lap - car.lap) * Track.lapLength + 
                   (carAhead.s - car.s);
        const avgSpeed = (carAhead.v + car.v) / 2 || 1;
        const rawGap = distGap / avgSpeed;
        
        if (!car._smoothedIntervalGap || !Number.isFinite(car._smoothedIntervalGap)) {
          car._smoothedIntervalGap = rawGap;
        } else {
          car._smoothedIntervalGap = car._smoothedIntervalGap * 0.85 + rawGap * 0.15;
        }
        return car._smoothedIntervalGap;
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // PLATFORM MODEL - TRUE QUARTER-CAR SIMULATION
    // ═══════════════════════════════════════════════════════════════════════════════
    // Simulates quarter-car dynamics over global track roughness profile
    // Computes physical metrics: avg height, load variation, bottoming %
    // Converts to factors: kAero, kDrag, kMech, kWear
    
    // Global track roughness profile (single profile for whole track)
    // Typische Werte:
    //   Sehr glatt (F1): A = 0.5-2mm, λ = 4-8m
    //   Normal:          A = 2-4mm,   λ = 4-10m  
    //   Bumpy:           A = 5-10mm,  λ = 2-6m
    const TrackRoughness = {
      amplitude: 0.002,    // 2mm bump amplitude - "normal" track
      wavelength: 6.0,     // 6m wavelength - reduces high-frequency excitation
      // Secondary roughness for realism (higher frequency)
      amp2: 0.0005,        // 0.5mm high-frequency
      lambda2: 1.5         // 1.5m wavelength
    };
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // PLATFORM MODEL PARAMETERS - CONFIGURABLE PER VEHICLE CLASS
    // ═══════════════════════════════════════════════════════════════════════════════
    // These parameters define the quarter-car physics model.
    // Adjust per vehicle class (F1, GT3, LMP, Road Car, etc.)
    //
    // WEAR MODEL (realistic factors):
    // - Load variation: vertical oscillation causes uneven tire contact → wear
    // - Bottoming: scrubbing/sliding when chassis bottoms → accelerated wear
    // - Grip utilization: (handled in tire model) high slip angles = more wear
    // - Temperature: (future) hot tires wear faster
    //
    // AERO MODEL:
    // - Ground effect peaks at optimal ride height (venturi effect)
    // - Below optimal: flow chokes, efficiency drops
    // - Above optimal: less ground effect, efficiency falls off
    //
    // GRIP MODEL:
    // - Load variation hurts mechanical grip (tire can't adapt fast enough)
    // - Consistent load = maximum grip potential
    // ═══════════════════════════════════════════════════════════════════════════════
    
    const PlatformParams = {
      // === VEHICLE MASS ===
      mSprung: 180,           // kg (sprung mass per corner, ~vehicle/4)
      
      // ═══════════════════════════════════════════════════════════════════
      // AERO GROUND EFFECT CURVE (realistisch nach CFD/Windkanal-Daten)
      // ═══════════════════════════════════════════════════════════════════
      // Ride Height Bereiche (in mm):
      // - 0-1mm:   STALLING - Luftstrom bricht ab, massiver Downforce-Verlust
      // - 1-10mm:  AUFBAU - Streng monoton steigend zum PEAK bei 10mm
      // - 10mm+:   FALLOFF - Streng monoton fallend, asymptotisch gegen Basis
      //
      // KEIN PLATEAU - nur ein einzelner Peak bei 10mm mit Faktor 1.5
      //
      hStall: 0.001,          // Unter 1mm: Stalling (kAero = 0.4)
      hPeak: 0.010,           // 10mm: SINGLE PEAK (keine Plateau-Zone)
      
      // Aero-Faktoren
      kAeroStall: 0.40,       // Bei Stalling (<1mm): 60% Verlust!
      kAeroMax: 1.50,         // Am Peak (20mm): +50% Bonus
      kAeroBase: 0.85,        // Bei sehr hoher Ride Height: -15%
      
      // ═══════════════════════════════════════════════════════════════════
      // DRAG CURVE
      // ═══════════════════════════════════════════════════════════════════
      // - h<0:    EXTREME Strafe (Aufsetzen)
      // - 0-1mm:  Sehr hoher Drag (Stalling, Turbulenz) - 2.5x!
      // - 4-8mm:  Minimum Drag (optimaler Venturi-Flow)
      // - 8mm+:   Linear steigend (weniger Bodeneffekt)
      hDragMin: 0.006,        // 6mm = Minimum Drag
      kDragStall: 2.50,       // Bei Stalling (h=0): +150% Drag!
      kDragOpt: 0.85,         // Bei optimalem Flow: -15% Drag
      kDragHigh: 1.08,        // Bei hoher Ride Height: +8% Drag
      
      // === GRIP SENSITIVITY ===
      gripBeta: 0.12,         // β für µ-Sättigung (α ≈ 0.9)
      
      // === WEAR MODEL (REDUZIERT) ===
      wearFromLoadVar: 0.08,  // Wear aus Load-Variation (vorher 0.20 - zu hoch)
      wearFromBottoming: 0.3, // Wear aus Bottoming (vorher 0.6 - zu hoch)
      
      // === BOTTOMING ===
      hMin: 0.001             // 1mm = echter Bottoming-Punkt
    };
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // PLATFORM: ANALYTISCHE VIERTELFAHRZEUG-LÖSUNG (eingeschwungener Zustand)
    // ═══════════════════════════════════════════════════════════════════════════════
    const Platform = {
      // Speed points for lookup table: 0 to 110 m/s in 1 km/h steps (~0.28 m/s)
      speedPoints: [],
      
      // Lookup arrays (same length as speedPoints)
      lookupAero: [],
      lookupDrag: [],
      lookupGrip: [],
      lookupWear: [],
      
      // Detailed simulation results for UI (per speed point)
      simResults: [],
      
      // Current interpolated factors
      current: {
        kAero: 1.0,
        kDrag: 1.0,
        kMech: 1.0,
        kWear: 1.0
      },
      
      // Summary stats for UI
      stats: {
        avgAeroBonus: 0,
        avgGripLoss: 0,
        avgWear: 1.0,
        bottomingRisk: 0
      },
      
      reset() {
        this.buildLookupTable({
          rideHeight: CarConfig.rideHeight,
          springK: CarConfig.springK,
          damperC: CarConfig.damperC
        });
      },
      
      // Road profile function: combined roughness
      getRoadHeight(s) {
        const r = TrackRoughness;
        const h1 = r.amplitude * Math.sin(2 * Math.PI * s / r.wavelength);
        const h2 = r.amp2 * Math.sin(2 * Math.PI * s / r.lambda2 + 1.3);
        return h1 + h2;
      },
      
      // Aero efficiency as function of instantaneous height
      // STRENG MONOTON: steigend bis 20mm Peak, dann fallend (KEINE Plateau-Zone)
      // Flüssige Kurve mit Smoothstep für sanfte Übergänge
      getAeroEfficiency(h) {
        const p = PlatformParams;
        
        // ─── STALLING ZONE: < 1mm ───
        if (h < p.hStall) {
          return p.kAeroStall;
        }
        
        // ─── AUFBAU: 1mm bis 20mm - streng monoton steigend zum PEAK ───
        if (h < p.hPeak) {
          // Smooth S-Kurve von Stall zu Peak
          const t = (h - p.hStall) / (p.hPeak - p.hStall);
          // Smootherstep für noch glattere Kurve: 6t^5 - 15t^4 + 10t^3
          const tSmooth = t * t * t * (t * (t * 6 - 15) + 10);
          return p.kAeroStall + (p.kAeroMax - p.kAeroStall) * tSmooth;
        }
        
        // ─── FALLOFF: > 20mm - streng monoton fallend ───
        // Asymptotischer Abfall: kAero → kAeroBase
        // Formel: kAero = kAeroBase + (kAeroMax - kAeroBase) / (1 + α·Δh)²
        // α bestimmt die Abfallrate, ² macht den Abfall steiler am Anfang
        const deltaH = (h - p.hPeak) * 1000;  // in mm für bessere Skalierung
        const alpha = 0.06;  // Kontrolliert Abfallrate
        return p.kAeroBase + (p.kAeroMax - p.kAeroBase) / Math.pow(1 + alpha * deltaH, 1.5);
      },
      
      // Drag efficiency as function of instantaneous height
      // Streng monoton fallend bis 6mm, dann steigend
      // Bei h < 0 (Aufsetzen): EXTREME Drag-Strafe
      getDragEfficiency(h) {
        const p = PlatformParams;
        
        // ─── AUFSETZEN: h < 0 (negativ = ins Chassis gedrückt) ───
        if (h < 0) {
          // Extreme Drag-Strafe: quadratisch steigend mit Eindringtiefe
          const penetration = -h * 1000;  // in mm (positiv)
          // Bei -1mm: +0.5, bei -2mm: +2.0, bei -5mm: +12.5
          return p.kDragStall + 0.5 * penetration * penetration;
        }
        
        // ─── STALLING: 0-1mm ───
        if (h < p.hStall) {
          // Linear von kDragStall bei 0mm zu kDragStall bei 1mm
          const t = h / p.hStall;
          return p.kDragStall;
        }
        
        // ─── RECOVERY: 1-6mm - streng monoton fallend ───
        if (h < p.hDragMin) {
          const t = (h - p.hStall) / (p.hDragMin - p.hStall);
          const tSmooth = t * t * (3 - 2 * t);
          return p.kDragStall - (p.kDragStall - p.kDragOpt) * tSmooth;
        }
        
        // ─── ABOVE 6mm: Asymptotisch steigend ───
        const deltaH = (h - p.hDragMin) * 1000;  // in mm
        const alpha = 0.03;  // Langsamer Anstieg
        return p.kDragOpt + (p.kDragHigh - p.kDragOpt) * (1 - 1 / (1 + alpha * deltaH));
      },
      
      // ═══════════════════════════════════════════════════════════════════════════
      // ANALYTISCHE LÖSUNG: Eingeschwungener Zustand bei harmonischer Anregung
      // ═══════════════════════════════════════════════════════════════════════════
      // Basis-Excitation: mz̈ + c(ż-ṙ) + k(z-r) = 0, r(t) = A·sin(ωt)
      //
      // WICHTIG: Die Ride Height h = z_chassis - z_road = h_static - x_rel
      // wobei x_rel = z - r die relative Auslenkung (Federweg) ist.
      //
      // Transfer-Funktionen:
      // - Tz = |Z/A| = Chassis-Amplitude / Anregungs-Amplitude (displacement transmissibility)
      // - Tx = |X/A| = Relative Auslenkung / Anregungs-Amplitude
      //
      // Für Ride Height Schwankung brauchen wir X (nicht Z)!
      // ═══════════════════════════════════════════════════════════════════════════
      
      // Berechne analytische Lösung für eine Anregungsfrequenz
      computeHarmonicResponse(v, A, lambda, setup) {
        if (v < 0.1) return { Z: 0, X: 0, Famp: 0, hMean: setup.rideHeight, bottomingFrac: 0 };
        
        const m = PlatformParams.mSprung;
        const k = setup.springK;
        const c = setup.damperC;
        const h0 = setup.rideHeight;
        
        // Anregungsfrequenz
        const omega = 2 * Math.PI * v / lambda;
        
        // Eigenfrequenz und Dämpfungsgrad
        const omega_n = Math.sqrt(k / m);
        const zeta = c / (2 * Math.sqrt(k * m));
        const rho = omega / omega_n;  // Frequenzverhältnis
        
        // Nenner D (komplexer Betrag)
        const D2 = Math.pow(1 - rho * rho, 2) + Math.pow(2 * zeta * rho, 2);
        const D = Math.sqrt(D2);
        
        // ─── CHASSIS-AMPLITUDE Tz ───
        // Tz = √(1 + (2ζρ)²) / D
        // Bei ρ << 1: Tz ≈ 1 (Chassis folgt Straße)
        // Bei ρ >> 1: Tz ≈ 0 (Chassis filtert Anregung)
        const Tz_num = Math.sqrt(1 + Math.pow(2 * zeta * rho, 2));
        const Tz = Tz_num / D;
        const Z = A * Tz;  // Chassis-Schwingungsamplitude (absolut)
        
        // ─── RELATIVE AUSLENKUNG Tx ───
        // Tx = ρ² / D
        // Bei ρ << 1: Tx ≈ 0 (Chassis folgt Straße perfekt → keine Federweg-Änderung)
        // Bei ρ >> 1: Tx ≈ 1 (Chassis steht still → volle Federweg-Änderung = A)
        // Bei ρ = 1: Tx = 1/(2ζ) (Resonanz-Verstärkung)
        const Tx = (rho * rho) / D;
        const X = A * Tx;  // Relative Auslenkung (Federweg-Schwankung)
        
        // ─── KRAFTAMPLITUDE ───
        // F = k·x + c·ẋ, also |F| = X · √(k² + (c·ω)²)
        const Famp = X * Math.sqrt(k * k + Math.pow(c * omega, 2));
        
        // ─── AERO-KOMPRESSION ───
        // WICHTIG: Wir modellieren EINE Ecke (1/4 Fahrzeug)
        // Die gesamte Aero-Kraft verteilt sich auf 4 Federn
        // Use setup.cLift/frontalArea if provided (per-car), fallback to CarConfig (single-car)
        const _cLift = setup.cLift || AeroModel.getTotalCLift(CarConfig.cLWing, CarConfig.cLDiffuser, CarConfig.wingAngle);
        const _fArea = setup.frontalArea || CarConfig.frontalArea;
        const Faero_total = 0.5 * AIR_DENSITY * v * v * _cLift * _fArea;
        const Faero = Faero_total / 4;  // Pro Ecke nur 1/4 der Gesamtkraft
        const xAero = Faero / k;
        
        // Mittlere Höhe (komprimiert durch Aero-Last)
        const hMean = h0 - xAero;
        
        // ─── RIDE HEIGHT SCHWANKUNG ───
        // h(t) = hMean - X·sin(ωt + φ)
        // Die Schwankung der Ride Height ist X (NICHT Z)!
        // Minimale Höhe: hMean - X (wenn Feder maximal komprimiert)
        const hMin = hMean - X;
        
        // Anteil der Periode unter Bottoming
        const hBottom = PlatformParams.hMin;
        let bottomingFrac = 0;
        if (X > 0.0001 && hMin < hBottom) {
          // h(θ) = hMean - X·sin(θ) < hBottom
          // sin(θ) > (hMean - hBottom) / X
          const sinTheta = Math.max(-1, Math.min(1, (hMean - hBottom) / X));
          const theta = Math.asin(sinTheta);
          // Anteil mit sin(θ) > sinTheta: (π - 2θ) / (2π)
          bottomingFrac = Math.max(0, (Math.PI - 2 * theta) / (2 * Math.PI));
        }
        
        return { Z, X, Famp, hMean, hMin, bottomingFrac, omega, Faero, Tz, Tx };
      },
      
      // Berechne alle Metriken bei gegebener Geschwindigkeit (mit Superposition beider Wellenlängen)
      computeAtSpeed(v, setup) {
        if (v < 0.1) {
          return {
            speed: v,
            kAero: 1.0,
            kMech: 1.0,
            kDrag: 1.0,
            kWear: 1.0,
            hMean: setup.rideHeight * 1000,
            bottomingPct: 0,
            loadVarPct: 0
          };
        }
        
        const r = TrackRoughness;
        const m = PlatformParams.mSprung;
        const k = setup.springK;
        
        // Harmonische Antwort für beide Wellenlängen
        const resp1 = this.computeHarmonicResponse(v, r.amplitude, r.wavelength, setup);
        const resp2 = this.computeHarmonicResponse(v, r.amp2, r.lambda2, setup);
        
        // Superposition der relativen Auslenkungen (konservativ)
        // X = relative Auslenkung = Federweg-Schwankung = Ride Height Schwankung
        const X_total = resp1.X + resp2.X;
        const Z_total = resp1.Z + resp2.Z;  // Für Debug-Anzeige
        const Famp_total = resp1.Famp + resp2.Famp;
        const hMean = resp1.hMean;  // Gleich für beide
        
        // Statische Last
        const F0 = m * GRAVITY + resp1.Faero;
        
        // ═══════════════════════════════════════════════════════════════════
        // 1) kMech: GRIP-KORREKTURFAKTOR aus Load-Variation
        // ═══════════════════════════════════════════════════════════════════
        // Pacejka-artige µ-Sättigung: µ_eff = µ0 · (Fz / Fz_ref)^(α-1)
        // Bei schwankender Last: mittlere Kraft < F0 wegen Sättigung
        // 
        // Integral über eine Periode: F_avg = ∫ µ(F0 + Famp·sin(θ)) dθ / 2π
        // Mit µ(F) = µ0 · (F/Fref)^(α-1), α < 1
        //
        // Vereinfachung: kMech ≈ 1 - β · (Famp / F0)²
        // β hängt von α ab (typisch β ≈ 0.15 für α = 0.9)
        const loadVarRatio = Famp_total / F0;
        const loadVarPct = loadVarRatio * 100;
        
        // Grip-Verlust durch Load-Variation (quadratisch)
        // REDUZIERT: β = 0.05 statt 0.12 für realistischeren Effekt
        // Bei 50% Load-Variation: kMech = 1 - 0.05*0.25 = 0.9875 (nur -1.25%)
        // Bei 100% Load-Variation: kMech = 1 - 0.05*1.0 = 0.95 (nur -5%)
        const beta = 0.05;  // Reduziert - vorher war der Effekt viel zu stark
        let kMech = 1 - beta * loadVarRatio * loadVarRatio;
        
        // Center of Gravity Effekt (höhere Ride Height = höherer CoG)
        const hRef = 0.035;
        const cogFactor = 1 - 0.6 * (hMean - hRef);
        kMech *= Math.max(0.92, Math.min(1.04, cogFactor));
        
        kMech = Math.max(0.75, Math.min(1.05, kMech));
        
        // ═══════════════════════════════════════════════════════════════════
        // 2) kAero: AERO-KORREKTURFAKTOR aus Height-Integration
        // ═══════════════════════════════════════════════════════════════════
        // Ride Height h(t) = hMean - X·sin(ωt)
        // X ist die relative Auslenkung (Federweg-Schwankung)
        //
        // Numerische Integration über Sinus-Periode
        const nSamples = 32;
        let aeroSum = 0;
        let dragSum = 0;
        for (let i = 0; i < nSamples; i++) {
          const theta = 2 * Math.PI * i / nSamples;
          // h = hMean - X·sin(θ) (MINUS weil Feder-Kompression = niedrigere Ride Height)
          const h = hMean - X_total * Math.sin(theta);
          aeroSum += this.getAeroEfficiency(h);
          dragSum += this.getDragEfficiency(h);
        }
        let kAero = aeroSum / nSamples;
        let kDrag = dragSum / nSamples;
        
        // ═══════════════════════════════════════════════════════════════════
        // 3) BOTTOMING: Anteil der Zeit unter hMin
        // ═══════════════════════════════════════════════════════════════════
        // Minimale Ride Height = hMean - X_total (bei maximaler Feder-Kompression)
        const p = PlatformParams;
        const hMinActual = hMean - X_total;
        let bottomingPct = 0;
        
        if (hMinActual < p.hMin && X_total > 0.0001) {
          // h(θ) = hMean - X·sin(θ) < hMin
          // sin(θ) > (hMean - hMin) / X
          const sinTheta = Math.max(-1, Math.min(1, (hMean - p.hMin) / X_total));
          const theta = Math.asin(sinTheta);
          bottomingPct = Math.max(0, (Math.PI - 2 * theta) / (2 * Math.PI)) * 100;
        }
        
        // Bottoming reduziert Grip (bereits in Aero/Drag-Kurven enthalten, hier nur leicht)
        if (bottomingPct > 0) {
          kMech *= (1 - 0.002 * bottomingPct);
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // 4) kWear: VERSCHLEISS-FAKTOR
        // ═══════════════════════════════════════════════════════════════════
        // Wear aus Load-Variation (ungleichmäßiger Kontakt)
        let kWear = 1 + p.wearFromLoadVar * loadVarRatio;
        
        // Wear aus Bottoming (nur bei echtem Aufsetzen, <1mm)
        if (bottomingPct > 0) {
          kWear += p.wearFromBottoming * (bottomingPct / 100);
        }
        kWear = Math.min(2.0, kWear);
        
        return {
          speed: v,
          speedKmh: v * 3.6,
          kAero,
          kMech,
          kDrag,
          kWear,
          hMean: hMean * 1000,
          hMin: hMinActual * 1000,
          X: X_total * 1000,  // Relative Auslenkung = Ride Height Schwankung
          Z: Z_total * 1000,  // Chassis-Amplitude (für Debug)
          Famp: Famp_total,
          F0,
          loadVarPct,
          bottomingPct,
          // Aliases für UI-Kompatibilität (Graphen)
          // X ist die Ride Height Schwankung (nicht Z!)
          avgHeight: hMean * 1000,
          heightRange: X_total * 1000 * 2,  // Range = 2×X
          minHeight: (hMean - X_total) * 1000,
          maxHeight: (hMean + X_total) * 1000,
          loadVariationPct: loadVarPct
        };
      },
      
      // Build complete lookup table mit 1 km/h Auflösung
      // Also stored globally for single-car mode and UI
      buildLookupTable(setup) {
        const lut = this.buildLookupFor(setup);
        // Store globally for single-car mode + UI
        this.speedPoints = lut._speedPoints;
        this.lookupAero = lut.lookupAero;
        this.lookupDrag = lut.lookupDrag;
        this.lookupGrip = lut.lookupGrip;
        this.lookupWear = lut.lookupWear;
        this.simResults = lut._simResults;
        this.stats = lut.stats;
        console.log('Platform lookup built (analytical):', this.stats);
      },
      
      // Build a standalone lookup table for a specific car setup
      // setup must include: rideHeight, springK, damperC, cLift, frontalArea
      // Returns a compact lookup object usable with getFactorsFromLookup()
      buildLookupFor(setup) {
        const speedPoints = [];
        const dv = 1 / 3.6;
        for (let vKmh = 0; vKmh <= 400; vKmh++) {
          speedPoints.push(vKmh * dv);
        }
        
        const lookupAero = [];
        const lookupDrag = [];
        const lookupGrip = [];
        const lookupWear = [];
        const simResults = [];
        
        for (const v of speedPoints) {
          const result = this.computeAtSpeed(v, setup);
          simResults.push(result);
          lookupAero.push(result.kAero);
          lookupDrag.push(result.kDrag);
          lookupGrip.push(result.kMech);
          lookupWear.push(result.kWear);
        }
        
        // Summary stats
        let sumAero = 0, sumGrip = 0, sumWear = 0, sumBottom = 0, totalW = 0;
        for (let i = 0; i < speedPoints.length; i++) {
          const vKmh = speedPoints[i] * 3.6;
          const w = vKmh < 50 ? 0.3 : (vKmh < 200 ? 1.0 : 0.7);
          sumAero += lookupAero[i] * w;
          sumGrip += lookupGrip[i] * w;
          sumWear += lookupWear[i] * w;
          sumBottom += simResults[i].bottomingPct * w;
          totalW += w;
        }
        
        return {
          lookupAero, lookupDrag, lookupGrip, lookupWear,
          _speedPoints: speedPoints,
          _simResults: simResults,
          stats: {
            avgAeroBonus: ((sumAero / totalW) - 1) * 100,
            avgGripLoss: (1 - (sumGrip / totalW)) * 100,
            avgWear: sumWear / totalW,
            bottomingRisk: sumBottom / totalW
          }
        };
      },
      
      // Get factors from a per-car lookup table at given speed
      getFactorsFromLookup(lut, v) {
        const vKmh = v * 3.6;
        const vClamped = Math.max(0, Math.min(400, vKmh));
        const i = Math.min(Math.floor(vClamped), 399);
        const t = vClamped - i;
        if (i >= lut.lookupAero.length - 1) {
          return {
            kAero: lut.lookupAero[lut.lookupAero.length - 1],
            kDrag: lut.lookupDrag[lut.lookupDrag.length - 1],
            kMech: lut.lookupGrip[lut.lookupGrip.length - 1],
            kWear: lut.lookupWear[lut.lookupWear.length - 1]
          };
        }
        return {
          kAero: lut.lookupAero[i] + t * (lut.lookupAero[i + 1] - lut.lookupAero[i]),
          kDrag: lut.lookupDrag[i] + t * (lut.lookupDrag[i + 1] - lut.lookupDrag[i]),
          kMech: lut.lookupGrip[i] + t * (lut.lookupGrip[i + 1] - lut.lookupGrip[i]),
          kWear: lut.lookupWear[i] + t * (lut.lookupWear[i + 1] - lut.lookupWear[i])
        };
      },
      
      // Interpolate factors for current speed
      // Mit 1 km/h Auflösung: Index = v * 3.6 (gerundet)
      getFactorsAtSpeed(v) {
        const vKmh = v * 3.6;
        const maxKmh = 400;
        const vClamped = Math.max(0, Math.min(maxKmh, vKmh));
        
        // Direkte Index-Berechnung statt Suche (weil 1 km/h Schritte)
        const i = Math.min(Math.floor(vClamped), maxKmh - 1);
        const t = vClamped - i;  // Fraktionaler Teil für Interpolation
        
        if (i >= this.lookupAero.length - 1) {
          return {
            kAero: this.lookupAero[this.lookupAero.length - 1],
            kDrag: this.lookupDrag[this.lookupDrag.length - 1],
            kMech: this.lookupGrip[this.lookupGrip.length - 1],
            kWear: this.lookupWear[this.lookupWear.length - 1]
          };
        }
        
        // Linear interpolation
        return {
          kAero: this.lookupAero[i] + t * (this.lookupAero[i + 1] - this.lookupAero[i]),
          kDrag: this.lookupDrag[i] + t * (this.lookupDrag[i + 1] - this.lookupDrag[i]),
          kMech: this.lookupGrip[i] + t * (this.lookupGrip[i + 1] - this.lookupGrip[i]),
          kWear: this.lookupWear[i] + t * (this.lookupWear[i + 1] - this.lookupWear[i])
        };
      },
      
      // Get detailed sim result for specific speed (for UI)
      getSimResultAtSpeed(v) {
        const vKmh = v * 3.6;
        const maxKmh = 400;
        const vClamped = Math.max(0, Math.min(maxKmh, vKmh));
        
        // Nächster Index
        const i = Math.min(Math.round(vClamped), this.simResults.length - 1);
        return this.simResults[i] || this.simResults[this.simResults.length - 1];
      },
      
      // Update current factors based on speed
      updateFromSpeed(v) {
        const f = this.getFactorsAtSpeed(v);
        this.current.kAero = f.kAero;
        this.current.kDrag = f.kDrag;
        this.current.kMech = f.kMech;
        this.current.kWear = f.kWear;
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // SENSITIVITY ANALYSIS — Analytical Lap Time Estimator
    // ═══════════════════════════════════════════════════════════════════════════════
    // Computes estimated lap time for any parameter configuration.
    // Uses velocity-profile approach (forward accel + backward brake pass).
    // Fresh soft tires, constant fuel weight, no weather, no slipstream.
    // ═══════════════════════════════════════════════════════════════════════════════

    const SensitivityAnalysis = {
      DS: 2.0,            // distance step for velocity profile (meters)
      BRAKE_SAFETY: 0.96,

      // Build a complete config from defaults + overrides
      makeConfig(overrides = {}) {
        return {
          mass:        overrides.mass        ?? CarDefaults.mass,
          fuel:        overrides.fuel         ?? CarDefaults.fuelCapacity,
          power:       overrides.power        ?? CarDefaults.power,
          cLWing:      overrides.cLWing       ?? CarDefaults.cLWing,
          cLDiffuser:  overrides.cLDiffuser   ?? CarDefaults.cLDiffuser,
          cDBody:      overrides.cDBody       ?? CarDefaults.cDBody,
          cDWing:      overrides.cDWing       ?? CarDefaults.cDWing,
          cRr:         overrides.cRr          ?? CarDefaults.cRr,
          frontalArea: overrides.frontalArea  ?? CarDefaults.frontalArea,
          tireGrip:    overrides.tireGrip     ?? CarDefaults.tireGrip,
          brakeForce:  overrides.brakeForce   ?? CarDefaults.brakeForce,
          camber:      overrides.camber       ?? CarDefaults.camber,
          wingAngle:   overrides.wingAngle    ?? CarDefaults.wingAngle,
          rideHeight:  overrides.rideHeight   ?? CarDefaults.rideHeight,
          springK:     overrides.springK      ?? CarDefaults.springK,
          damperC:     overrides.damperC      ?? CarDefaults.damperC,
          // Driver skills (0-99)
          skBraking:   overrides.skBraking    ?? 99,
          skCornering: overrides.skCornering  ?? 99,
          skAccel:     overrides.skAccel      ?? 99,
        };
      },

      // Compute derived physics factors for a config
      deriveFactors(cfg) {
        const totalMass = cfg.mass + cfg.fuel;
        // Wing factors
        const dragComp = AeroModel.getDragComponents(cfg.cDBody, cfg.cDWing, cfg.wingAngle);
        const totalCL = AeroModel.getTotalCLift(cfg.cLWing, cfg.cLDiffuser, cfg.wingAngle);
        // Platform lookup
        const platLookup = Platform.buildLookupFor({
          rideHeight: cfg.rideHeight,
          springK: cfg.springK,
          damperC: cfg.damperC,
          cLift: totalCL,
          frontalArea: cfg.frontalArea
        });
        // Camber factors
        const camberF = CamberModel.getFactors(cfg.camber);
        const camberRR = CamberModel.getRollingResistanceFactor(cfg.camber);
        // Driver skill factors
        const decelFactor = DriverSkills.ratingToDecelFactor(cfg.skBraking);
        const muCorner    = DriverSkills.ratingToGripFactor(cfg.skCornering);
        const accelFactor = DriverSkills.ratingToAccelFactor(cfg.skAccel);

        return { totalMass, dragComp, platLookup, camberF, camberRR,
                 decelFactor, muCorner, accelFactor };
      },

      // Get platform factors at speed from a lookup
      getPlatF(platLookup, v) {
        return Platform.getFactorsFromLookup(platLookup, v);
      },

      // Compute max corner speed for given config & derived factors
      cornerSpeed(radius, cfg, df) {
        const r = Math.abs(radius);
        const m = df.totalMass;
        const baseGrip = cfg.tireGrip;  // fresh soft = condition 1.0, compound grip 1.0
        const camberLat = df.camberF.kLat;
        const muBase = baseGrip * camberLat;

        // Step 1: without suspension
        const cLnoPlat = AeroModel.getEffectiveLift(cfg.cLWing, cfg.cLDiffuser, cfg.wingAngle, 1.0);
        const A = cfg.frontalArea;
        const vBase = calcCornerSpeed(muBase, m, r, cLnoPlat, A, AIR_DENSITY_REF);

        // Step 2: with suspension at vBase
        const pf = this.getPlatF(df.platLookup, vBase);
        const muEff = muBase * pf.kMech * df.muCorner;
        const cLEff = AeroModel.getEffectiveLift(cfg.cLWing, cfg.cLDiffuser, cfg.wingAngle, pf.kAero);
        return calcCornerSpeed(muEff, m, r, cLEff, A, AIR_DENSITY_REF);
      },

      // Compute acceleration at speed v (m/s) for a config
      getAccel(v, cfg, df) {
        v = Math.max(v, 0.5);
        const m = df.totalMass;
        const pf = this.getPlatF(df.platLookup, v);
        const cD = df.dragComp.body * pf.kDrag + df.dragComp.wing;
        const cL = AeroModel.getEffectiveLift(cfg.cLWing, cfg.cLDiffuser, cfg.wingAngle, pf.kAero);
        const A = cfg.frontalArea;

        const dragF  = 0.5 * AIR_DENSITY_REF * cD * A * v * v;
        const downF   = 0.5 * AIR_DENSITY_REF * cL * A * v * v;
        const Fz      = m * GRAVITY + downF;
        const rollF   = cfg.cRr * df.camberRR * Fz;
        const driveF  = cfg.power / v;
        const maxTrac = cfg.tireGrip * Math.pow(Fz, TIRE_LOAD_SENSITIVITY);
        const effDrive = Math.min(driveF, maxTrac);
        const net = effDrive - dragF - rollF;
        const a = net / m;
        return (a >= 0 ? a * df.accelFactor : a);
      },

      // Compute braking deceleration at speed v (positive = deceleration magnitude)
      getBraking(v, cfg, df) {
        v = Math.max(v, 0.5);
        const m = df.totalMass;
        const pf = this.getPlatF(df.platLookup, v);
        const cL = AeroModel.getEffectiveLift(cfg.cLWing, cfg.cLDiffuser, cfg.wingAngle, pf.kAero);
        const A = cfg.frontalArea;
        const downF = 0.5 * AIR_DENSITY_REF * cL * A * v * v;
        const Fz = m * GRAVITY + downF;
        const gripF = cfg.tireGrip * df.camberF.kLat * pf.kMech * df.muCorner
                      * Math.pow(Fz, TIRE_LOAD_SENSITIVITY);
        const effBrake = Math.min(cfg.brakeForce, gripF);
        return (effBrake / m) * df.decelFactor * this.BRAKE_SAFETY;
      },

      // Estimate lap time for a given config
      estimateLapTime(config) {
        const cfg = this.makeConfig(config);
        const df = this.deriveFactors(cfg);
        const segs = Track.segments;
        if (!segs || segs.length === 0) return { time: NaN, details: [] };

        // 1. Build segment list with lengths and corner speeds
        const segInfo = [];
        for (const seg of segs) {
          if (seg.kind === 'corner') {
            const arcLen = seg.radius * seg.angleDeg * Math.PI / 180;
            const vApex = this.cornerSpeed(seg.radius, cfg, df);
            segInfo.push({ kind: 'corner', length: arcLen, vApex, name: seg.name || 'Corner' });
          } else {
            segInfo.push({ kind: 'straight', length: seg.length, name: seg.name || 'Straight' });
          }
        }
        const nSeg = segInfo.length;

        // 2. Determine entry/exit speeds for straights
        // Each straight's entry speed = vApex of preceding corner
        // Each straight's exit speed = vApex of following corner
        // (wrap around for circuits)
        const getCornerBefore = (idx) => {
          for (let k = 1; k <= nSeg; k++) {
            const j = (idx - k + nSeg) % nSeg;
            if (segInfo[j].kind === 'corner') return segInfo[j].vApex;
          }
          return 50; // fallback
        };
        const getCornerAfter = (idx) => {
          for (let k = 1; k <= nSeg; k++) {
            const j = (idx + k) % nSeg;
            if (segInfo[j].kind === 'corner') return segInfo[j].vApex;
          }
          return 50;
        };

        // 3. Compute time for each segment
        const ds = this.DS;
        let totalTime = 0;
        const details = [];

        for (let si = 0; si < nSeg; si++) {
          const seg = segInfo[si];
          if (seg.kind === 'corner') {
            // Simple: time = arcLength / vApex
            const t = seg.length / seg.vApex;
            totalTime += t;
            details.push({ name: seg.name, kind: 'corner', time: t, vApex: seg.vApex });
          } else {
            // Straight: velocity profile with forward+backward pass
            const L = seg.length;
            const n = Math.max(1, Math.ceil(L / ds));
            const step = L / n;
            const vEntry = getCornerBefore(si);
            const vExit  = getCornerAfter(si);

            // Forward pass (accelerating from vEntry)
            const vFwd = new Float64Array(n + 1);
            vFwd[0] = vEntry;
            for (let i = 0; i < n; i++) {
              const v = Math.max(vFwd[i], 0.5);
              const a = this.getAccel(v, cfg, df);
              // v² = v₀² + 2·a·ds
              const v2 = v * v + 2 * a * step;
              vFwd[i + 1] = v2 > 0 ? Math.sqrt(v2) : v;
            }

            // Backward pass (braking to vExit)
            const vBwd = new Float64Array(n + 1);
            vBwd[n] = vExit;
            for (let i = n; i > 0; i--) {
              const v = Math.max(vBwd[i], 0.5);
              const b = this.getBraking(v, cfg, df);
              // v² = v₀² + 2·b·ds  (going backward: increasing speed)
              const v2 = v * v + 2 * b * step;
              vBwd[i - 1] = v2 > 0 ? Math.sqrt(v2) : v;
            }

            // Take min of forward and backward at each point
            let segTime = 0;
            let vMax = 0, vMin = 999;
            for (let i = 0; i < n; i++) {
              const v = Math.max(Math.min(vFwd[i], vBwd[i]), 0.5);
              segTime += step / v;
              vMax = Math.max(vMax, v);
              vMin = Math.min(vMin, v);
            }
            totalTime += segTime;
            details.push({ name: seg.name, kind: 'straight', time: segTime, vMax, vMin, length: L });
          }
        }

        return { time: totalTime, details };
      },

      // ── Parameter definitions for sweep ──
      getParameterDefs() {
        return [
          // === Setup Parameters ===
          { key: 'camber',     label: 'Camber',       unit: '°',     min: -4.0, max: 0,     step: 0.1,  fmt: v => v.toFixed(1),    group: 'Setup' },
          { key: 'wingAngle',  label: 'Wing Angle',   unit: '°',     min: 0,    max: 25,    step: 0.1,  fmt: v => v.toFixed(1),    group: 'Setup' },
          { key: 'rideHeight', label: 'Ride Height',  unit: 'mm',    min: 0.020,max: 0.050, step: 0.001,fmt: v => (v*1000).toFixed(0), group: 'Setup' },
          { key: 'springK',    label: 'Spring Rate',  unit: 'N/mm',  min: 40000,max: 500000,step: 5000, fmt: v => (v/1000).toFixed(0), group: 'Setup' },
          { key: 'damperC',    label: 'Damper',       unit: 'Ns/mm', min: 100,  max: 20000, step: 100,  fmt: v => (v/1000).toFixed(1), group: 'Setup' },
          // === Car Physics ===
          { key: 'mass',       label: 'Mass',         unit: 'kg',    min: 700,  max: 900,   step: 10,   fmt: v => v.toFixed(0), group: 'Physics' },
          { key: 'power',      label: 'Power',        unit: 'kW',    min: 600000,max:900000, step:10000, fmt: v => (v/1000).toFixed(0), group: 'Physics' },
          { key: 'cDBody',      label: 'Body CD',      unit: '',      min: 0.4,  max: 1.0,   step: 0.01, fmt: v => v.toFixed(2), group: 'Physics' },
          { key: 'cDWing',      label: 'Wing CD',      unit: '',      min: 0.10, max: 0.40,  step: 0.005,fmt: v => v.toFixed(3), group: 'Physics' },
          { key: 'cLWing',      label: 'Wing CL',      unit: '',      min: 1.0,  max: 2.5,   step: 0.01, fmt: v => v.toFixed(2), group: 'Physics' },
          { key: 'cLDiffuser',  label: 'Diffuser CL',  unit: '',      min: 1.0,  max: 3.0,   step: 0.05, fmt: v => v.toFixed(2), group: 'Physics' },
          { key: 'cRr',        label: 'cRr (Roll.R.)',unit: '',      min: 0.010,max: 0.020, step: 0.001,fmt: v => v.toFixed(3), group: 'Physics' },
          { key: 'frontalArea',label: 'Frontal Area', unit: 'm²',    min: 1.4,  max: 2.2,   step: 0.1,  fmt: v => v.toFixed(1), group: 'Physics' },
          { key: 'tireGrip',   label: 'Tire Grip µ',  unit: '',      min: 1.0,  max: 2.0,   step: 0.05, fmt: v => v.toFixed(2), group: 'Physics' },
          { key: 'brakeForce', label: 'Brake Force',  unit: 'kN',    min: 25000,max: 45000, step: 1000, fmt: v => (v/1000).toFixed(0), group: 'Physics' },
          // === Driver Skills ===
          { key: 'skBraking',  label: '🧠 Braking',   unit: '',      min: 0,  max: 99,  step: 1, fmt: v => v.toFixed(0), group: 'Driver' },
          { key: 'skCornering', label: '🧠 Cornering', unit: '',      min: 0,  max: 99,  step: 1, fmt: v => v.toFixed(0), group: 'Driver' },
          { key: 'skAccel',    label: '🧠 Accel',     unit: '',      min: 0,  max: 99,  step: 1, fmt: v => v.toFixed(0), group: 'Driver' },
        ];
      },

      // Sweep a single parameter across its range, return array of {val, time}
      SWEEP_POINTS: 25,

      sweepParameter(paramDef) {
        const pts = this.SWEEP_POINTS;
        const range = paramDef.max - paramDef.min;
        const data = [];
        for (let i = 0; i <= pts; i++) {
          const val = paramDef.min + (i / pts) * range;
          const result = this.estimateLapTime({ [paramDef.key]: val });
          data.push({ val, time: result.time });
        }
        return data;
      },

      // Run full sweep with curve data for all parameters
      runFullAnalysis() {
        const params = this.getParameterDefs();
        const refResult = this.estimateLapTime({});
        const refTime = refResult.time;

        const results = [];
        for (const p of params) {
          const def = this.makeConfig({})[p.key];
          const curve = this.sweepParameter(p);
          const times = curve.map(c => c.time);
          const minTime = Math.min(...times);
          const maxTime = Math.max(...times);
          // Delta at param min/max boundaries
          const deltaMin = curve[0].time - refTime;
          const deltaMax = curve[curve.length - 1].time - refTime;
          results.push({
            ...p,
            default: def,
            refTime,
            curve,
            minTime: curve[0].time,
            maxTime: curve[curve.length - 1].time,
            bestTime: minTime,
            worstTime: maxTime,
            deltaMin,
            deltaMax,
            range: maxTime - minTime,
          });
        }

        // Sort by total range (most sensitive first)
        results.sort((a, b) => b.range - a.range);
        return { refTime, refDetails: refResult.details, results };
      },

      // ── Draw sweep curve on a canvas ──
      drawSweepGraph(canvas, r) {
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const W = canvas.clientWidth;
        const H = canvas.clientHeight;
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        ctx.scale(dpr, dpr);

        const pad = { top: 22, right: 16, bottom: 30, left: 58 };
        const gW = W - pad.left - pad.right;
        const gH = H - pad.top - pad.bottom;

        // Clear
        ctx.fillStyle = '#0d1017';
        ctx.fillRect(0, 0, W, H);

        const curve = r.curve;
        if (!curve || curve.length < 2) return;

        const vals = curve.map(c => c.val);
        const times = curve.map(c => c.time);
        const xMin = vals[0], xMax = vals[vals.length - 1];
        const tMin = Math.min(...times);
        const tMax = Math.max(...times);
        const tPad = Math.max((tMax - tMin) * 0.08, 0.01);
        const yMin = tMin - tPad;
        const yMax = tMax + tPad;

        const xScale = (v) => pad.left + ((v - xMin) / (xMax - xMin)) * gW;
        const yScale = (t) => pad.top + (1 - (t - yMin) / (yMax - yMin)) * gH;

        // Grid lines (horizontal)
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        const nGrid = 5;
        ctx.font = '10px JetBrains Mono, monospace';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'right';
        for (let i = 0; i <= nGrid; i++) {
          const t = yMin + (i / nGrid) * (yMax - yMin);
          const y = yScale(t);
          ctx.beginPath();
          ctx.moveTo(pad.left, y);
          ctx.lineTo(W - pad.right, y);
          ctx.stroke();
          ctx.fillText(this.fmtTime(t), pad.left - 4, y + 3);
        }

        // Grid lines (vertical) + x labels
        ctx.textAlign = 'center';
        const nXGrid = 5;
        for (let i = 0; i <= nXGrid; i++) {
          const v = xMin + (i / nXGrid) * (xMax - xMin);
          const x = xScale(v);
          ctx.strokeStyle = 'rgba(255,255,255,0.06)';
          ctx.beginPath();
          ctx.moveTo(x, pad.top);
          ctx.lineTo(x, H - pad.bottom);
          ctx.stroke();
          ctx.fillStyle = '#666';
          ctx.fillText(r.fmt(v), x, H - pad.bottom + 14);
        }

        // Axis labels
        ctx.fillStyle = '#888';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(r.label + (r.unit ? ' (' + r.unit + ')' : ''), pad.left + gW / 2, H - 2);

        // Reference line (default value)
        const xDef = xScale(r.default);
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.setLineDash([4, 4]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(xDef, pad.top);
        ctx.lineTo(xDef, H - pad.bottom);
        ctx.stroke();
        ctx.setLineDash([]);
        // Default label
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.font = '9px sans-serif';
        ctx.fillText('Default', xDef, pad.top - 4);

        // Reference lap time horizontal line
        const yRef = yScale(r.refTime);
        ctx.strokeStyle = 'rgba(0,255,136,0.2)';
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(pad.left, yRef);
        ctx.lineTo(W - pad.right, yRef);
        ctx.stroke();
        ctx.setLineDash([]);

        // Main curve
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 2.5;
        ctx.lineJoin = 'round';
        ctx.beginPath();
        for (let i = 0; i < curve.length; i++) {
          const x = xScale(curve[i].val);
          const y = yScale(curve[i].time);
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Fill under curve with gradient
        ctx.lineTo(xScale(curve[curve.length - 1].val), H - pad.bottom);
        ctx.lineTo(xScale(curve[0].val), H - pad.bottom);
        ctx.closePath();
        const grad = ctx.createLinearGradient(0, pad.top, 0, H - pad.bottom);
        grad.addColorStop(0, 'rgba(0,212,255,0.12)');
        grad.addColorStop(1, 'rgba(0,212,255,0.01)');
        ctx.fillStyle = grad;
        ctx.fill();

        // Data dots
        ctx.fillStyle = '#00d4ff';
        for (const pt of curve) {
          const x = xScale(pt.val);
          const y = yScale(pt.time);
          ctx.beginPath();
          ctx.arc(x, y, 2.5, 0, Math.PI * 2);
          ctx.fill();
        }

        // Best time marker (green)
        const best = curve.reduce((a, b) => a.time < b.time ? a : b);
        ctx.fillStyle = '#00ff88';
        ctx.beginPath();
        ctx.arc(xScale(best.val), yScale(best.time), 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#00ff88';
        ctx.font = 'bold 10px JetBrains Mono, monospace';
        ctx.textAlign = 'left';
        const bestX = xScale(best.val);
        const bestLabelX = bestX + 8 > W - pad.right - 60 ? bestX - 8 : bestX + 8;
        ctx.textAlign = bestX + 8 > W - pad.right - 60 ? 'right' : 'left';
        ctx.fillText(this.fmtTime(best.time) + ' @ ' + r.fmt(best.val), bestLabelX, yScale(best.time) - 6);

        // Worst time marker (red)
        const worst = curve.reduce((a, b) => a.time > b.time ? a : b);
        ctx.fillStyle = '#ff4444';
        ctx.beginPath();
        ctx.arc(xScale(worst.val), yScale(worst.time), 4, 0, Math.PI * 2);
        ctx.fill();

        // Title bar
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(r.label, pad.left, 14);
        ctx.fillStyle = '#888';
        ctx.font = '10px JetBrains Mono, monospace';
        ctx.textAlign = 'right';
        ctx.fillText('Range: ' + r.range.toFixed(3) + 's', W - pad.right, 14);
      },

      // ── UI ──
      showModal() {
        const modal = document.getElementById('sensitivityModal');
        if (!modal) return;
        modal.classList.add('open');
        document.getElementById('saTrackName').textContent = Track.name || 'Custom';
        document.getElementById('saLapLength').textContent = (Track.lapLength / 1000).toFixed(2) + ' km';
        const fuelKg = CarDefaults.fuelCapacity;
        document.getElementById('saFuelInfo').textContent = fuelKg + ' kg (' + (CarDefaults.mass + fuelKg) + ' kg total)';
      },

      closeModal() {
        const modal = document.getElementById('sensitivityModal');
        if (modal) modal.classList.remove('open');
      },

      renderResults(analysis) {
        const { refTime, results } = analysis;
        document.getElementById('saRefTime').textContent = this.fmtTime(refTime);
        document.getElementById('saStatus').style.display = 'none';
        const tbody = document.getElementById('saTableBody');
        tbody.innerHTML = '';

        // Find max range for bar scaling
        const maxRange = Math.max(...results.map(r => r.range), 0.001);

        let lastGroup = '';
        for (let ri = 0; ri < results.length; ri++) {
          const r = results[ri];
          // Group header
          if (r.group !== lastGroup) {
            lastGroup = r.group;
            const gRow = document.createElement('tr');
            gRow.innerHTML = `<td colspan="7" style="padding:10px 8px 4px; font-size:11px; font-weight:700; color:var(--accent-cyan); border-bottom:1px solid rgba(0,212,255,0.2); letter-spacing:1px;">${r.group.toUpperCase()}</td>`;
            tbody.appendChild(gRow);
          }

          // Summary row
          const tr = document.createElement('tr');
          tr.style.borderBottom = '1px solid rgba(255,255,255,0.06)';
          tr.style.cursor = 'pointer';
          tr.title = 'Klicken für Diagramm';

          const dMinCol = r.deltaMin < -0.005 ? '#00ff88' : r.deltaMin > 0.005 ? '#ff4444' : '#888';
          const dMaxCol = r.deltaMax < -0.005 ? '#00ff88' : r.deltaMax > 0.005 ? '#ff4444' : '#888';
          const barPct = Math.min(100, (r.range / maxRange) * 100);
          const barColor = r.range > maxRange * 0.5 ? '#ff4444' :
                           r.range > maxRange * 0.2 ? '#ffcc00' : '#00ff88';

          tr.innerHTML = `
            <td style="padding:5px 8px; color:#ddd;"><span style="color:#555; font-size:9px;">▶</span> ${r.label} <span style="color:#666; font-size:10px;">${r.unit}</span></td>
            <td style="padding:5px 8px; text-align:center; color:#fff; font-weight:700;">${r.fmt(r.default)}</td>
            <td style="padding:5px 8px; text-align:center; color:#888;">${r.fmt(r.min)}</td>
            <td style="padding:5px 8px; text-align:center; color:#888;">${r.fmt(r.max)}</td>
            <td style="padding:5px 8px; text-align:right; color:${dMinCol}; font-weight:600;">${this.fmtDelta(r.deltaMin)}</td>
            <td style="padding:5px 8px; text-align:right; color:${dMaxCol}; font-weight:600;">${this.fmtDelta(r.deltaMax)}</td>
            <td style="padding:5px 8px;">
              <div style="display:flex; align-items:center; gap:6px;">
                <div style="flex:1; height:10px; background:rgba(255,255,255,0.06); border-radius:4px; overflow:hidden;">
                  <div style="width:${barPct}%; height:100%; background:${barColor}; border-radius:4px; transition:width 0.3s;"></div>
                </div>
                <span style="font-size:10px; color:#aaa; min-width:45px; text-align:right;">${r.range.toFixed(3)}s</span>
              </div>
            </td>
          `;
          tbody.appendChild(tr);

          // Graph row (hidden by default)
          const graphRow = document.createElement('tr');
          graphRow.style.display = 'none';
          graphRow.innerHTML = `<td colspan="7" style="padding:4px 8px 12px;">
            <canvas class="sa-graph" data-idx="${ri}" style="width:100%; height:180px; border-radius:8px; display:block;"></canvas>
          </td>`;
          tbody.appendChild(graphRow);

          // Toggle graph on click
          const self = this;
          tr.addEventListener('click', function() {
            const isOpen = graphRow.style.display !== 'none';
            if (isOpen) {
              graphRow.style.display = 'none';
              tr.querySelector('td').querySelector('span').textContent = '▶';
            } else {
              graphRow.style.display = '';
              tr.querySelector('td').querySelector('span').textContent = '▼';
              const canvas = graphRow.querySelector('canvas');
              // Small delay so layout is settled
              requestAnimationFrame(() => self.drawSweepGraph(canvas, r));
            }
          });
        }
      },

      fmtTime(t) {
        if (isNaN(t)) return '—';
        const min = Math.floor(t / 60);
        const sec = (t % 60).toFixed(3);
        return min + ':' + (sec < 10 ? '0' : '') + sec;
      },

      fmtDelta(d) {
        if (Math.abs(d) < 0.001) return '±0.000';
        const sign = d > 0 ? '+' : '';
        return sign + d.toFixed(3) + 's';
      },

      init() {
        document.getElementById('sensitivityBtn')?.addEventListener('click', () => this.showModal());
        document.getElementById('sensitivityClose')?.addEventListener('click', () => this.closeModal());
        document.getElementById('saRunBtn')?.addEventListener('click', () => {
          const status = document.getElementById('saStatus');
          status.style.display = 'block';
          status.textContent = '⏳ Berechne (16 × 26 = 416 Simulationen)...';
          setTimeout(() => {
            try {
              const t0 = performance.now();
              const analysis = this.runFullAnalysis();
              const elapsed = ((performance.now() - t0) / 1000).toFixed(1);
              // Re-sort by group order for display
              const groupOrder = { Setup: 0, Physics: 1, Driver: 2 };
              analysis.results.sort((a, b) => {
                const gd = (groupOrder[a.group] ?? 9) - (groupOrder[b.group] ?? 9);
                if (gd !== 0) return gd;
                return b.range - a.range;
              });
              this.renderResults(analysis);
              status.style.display = 'block';
              status.textContent = `✅ Fertig in ${elapsed}s — Klicke eine Zeile für das Diagramm.`;
              status.style.color = '#00ff88';
            } catch (e) {
              status.textContent = '❌ Fehler: ' + e.message;
              status.style.color = '#ff4444';
              console.error('SensitivityAnalysis error:', e);
            }
          }, 50);
        });
        document.getElementById('sensitivityModal')?.addEventListener('click', (e) => {
          if (e.target.id === 'sensitivityModal') this.closeModal();
        });
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // CAR STATE
    // ═══════════════════════════════════════════════════════════════════════════════
    const Car = {

      s: 0,
      v: 0,
      a: 0,
      vLimit: null,
      fuel: CarConfig.fuelCapacity,

      throttle: 0,
      brake: 0,

      pit: {
        armed: false,
        committed: false,
        inLane: false,
        limiter: false,
        stopped: false,
        phase: 'none',
        exitRequested: false
      },

      lap: 0,
      lapStartTime: 0,
      currentLapTime: 0,
      lastLapTime: null,
      bestLapTime: null,

      visualS: 0,
      prevS: 0,

      reset() {
        this.s = 0;
        this.v = 0;
        this.a = 0;
        this.vLimit = null;

        this.visualS = 0;
        this.prevS = 0;

        this.fuel = CarConfig.fuelCapacity;

        this.throttle = 0;
        this.brake = 0;

        this.pit = {
          armed:false, committed:false, inLane:false, limiter:false,
          stopped:false, phase:'none', exitRequested:false
        };

        this.lap = 0;
        this.lapStartTime = 0;
        this.currentLapTime = 0;
        this.lastLapTime = null;
        this.bestLapTime = null;
        this.fuelAtLapStart = CarConfig.fuelCapacity;
        this.lastLapFuelUsed = null;
      },

      getTotalMass() { return CarConfig.mass + this.fuel; },

      // Get setup-only aero (wing angle ONLY, no platform/diffuser correction)
      getSetupCLift() {
        return AeroModel.getEffectiveLift(CarConfig.cLWing, CarConfig.cLDiffuser, CarConfig.wingAngle, 1.0);
      },

      getSetupCDrag() {
        return AeroModel.getEffectiveDrag(CarConfig.cDBody, CarConfig.cDWing, CarConfig.wingAngle);
      },

      // Get effective cLift with wing angle + diffuser (platform kAero)
      getEffectiveCLift() {
        return AeroModel.getEffectiveLift(CarConfig.cLWing, CarConfig.cLDiffuser, CarConfig.wingAngle, Platform.current.kAero);
      },
      
      // Get effective cDrag with wing angle + platform adjustment
      // Platform kDrag affects body drag only, not wing drag
      getEffectiveCDrag() {
        const dc = AeroModel.getDragComponents(CarConfig.cDBody, CarConfig.cDWing, CarConfig.wingAngle);
        return dc.body * Platform.current.kDrag + dc.wing;
      },

      // Get effective tire grip (base grip * tire condition * camber * platform * TireModel)
      // mode: 'lateral' for corners, 'longitudinal' for straights, 'mixed' for weighted blend
      getEffectiveGrip(mode = 'mixed', Fx = 0, Fy = 0) {
        const trackGrip = Track.gripMultiplier || 1.0;
        const compGrip = Weather.getCompoundGripFactor(Tire.compound);
        const modeGrip = TireModel.getDrivingModeGrip(DrivingMode.current);
        const baseGrip = CarConfig.tireGrip * Tire.getGripMultiplier() * trackGrip * compGrip * modeGrip;
        const camber = CarConfig.camber;
        
        let camberFactor = 1.0;
        if (mode === 'lateral') {
          camberFactor = CamberModel.getFactors(camber).kLat;
        } else if (mode === 'longitudinal') {
          camberFactor = CamberModel.getFactors(camber).kLong;
        } else {
          // Mixed mode: use force-weighted blend
          camberFactor = CamberModel.getEffectiveFactor(camber, Fx, Fy);
        }
        
        // Apply platform mechanical grip factor
        return baseGrip * camberFactor * Platform.current.kMech;
      },
      
      // ═══════════════════════════════════════════════════════════════════════════════
      // TIRE FORCE - Degressives Modell: F = µ * Fz^0.98
      // Bei hoher Last (Downforce) sinkt der effektive Reibwert leicht
      // ═══════════════════════════════════════════════════════════════════════════════
      getTireForce(mu, Fz) {
        return mu * Math.pow(Fz, TIRE_LOAD_SENSITIVITY);
      },

      getAcceleration() {
        const v = Math.max(this.v, 0.1);
        const m = this.getTotalMass();
        const grip = this.getEffectiveGrip('longitudinal'); // Use longitudinal camber factor

        const powerAccel = CarConfig.power / (m * v);

        const dragForce = 0.5 * AIR_DENSITY * this.getEffectiveCDrag() * CarConfig.frontalArea * v * v;
        const dragDecel = dragForce / m;

        // Rolling resistance: Frr = Crr * Fz
        const downforce = 0.5 * AIR_DENSITY * this.getEffectiveCLift() * CarConfig.frontalArea * v * v;
        const normalForce = m * GRAVITY + downforce;
        const camberRR_sa = CamberModel.getRollingResistanceFactor(CarConfig.camber);
        const rollResistForce = CarConfig.cRr * camberRR_sa * normalForce;
        const rollResistDecel = rollResistForce / m;

        // Degressive tire force model: F = µ * Fz^0.9
        const maxTractionForce = this.getTireForce(grip, normalForce);
        const maxTraction = maxTractionForce / m;

        const accel = Math.min(powerAccel, maxTraction) - dragDecel - rollResistDecel;
        return Math.max(accel, 0.1);
      },

      // braking decel at arbitrary speed (m/s²)
      // Returns: { decel, gripLimited, brakePct }
      getBrakingAt(v) {
        const m = this.getTotalMass();
        const grip = this.getEffectiveGrip('longitudinal');

        const downforce = 0.5 * AIR_DENSITY * this.getEffectiveCLift() * CarConfig.frontalArea * v * v;
        const normalForce = m * GRAVITY + downforce;
        
        // Max braking force from brake system
        const maxBrakeForce = CarConfig.brakeForce;
        
        // Grip-limited braking force
        const gripForce = this.getTireForce(grip, normalForce);
        const effectiveBrake = Math.min(maxBrakeForce, gripForce);
        
        // Ist die Bremsung grip-limitiert?
        const gripLimited = gripForce < maxBrakeForce;

        return effectiveBrake / m;
      },
      
      // Gibt zurück wie viel % der Bremsanlage wir tatsächlich nutzen können
      // (kann < 100% sein wenn grip-limitiert)
      getMaxBrakePct(v) {
        const m = this.getTotalMass();
        const grip = this.getEffectiveGrip('longitudinal');
        const downforce = 0.5 * AIR_DENSITY * this.getEffectiveCLift() * CarConfig.frontalArea * v * v;
        const normalForce = m * GRAVITY + downforce;
        const gripForce = this.getTireForce(grip, normalForce);
        
        // Wie viel % der Bremsanlage können wir nutzen?
        return Math.min(100, (gripForce / CarConfig.brakeForce) * 100);
      },

      // ══════════════════════════════════════════════════════════════════════
      // CORNER SPEED - Zweistufige Berechnung mit Suspension-Korrektur
      // ══════════════════════════════════════════════════════════════════════
      // Step 1: Berechne v_kurve mit ALLEN Faktoren AUSSER Suspension
      //         (Aero-Setup, Camber, Tire Condition)
      // Step 2: Mit dieser v die Suspension-Korrekturfaktoren suchen
      // Step 3: Nochmal v berechnen MIT Suspension-Faktoren
      //         Das ist v_kurve
      // ══════════════════════════════════════════════════════════════════════
      
      // Step 1: Kurvengeschwindigkeit OHNE Suspension-Faktoren
      // Enthält: Aero-Setup (Wing), Camber, Tire Condition
      getCornerSpeedBase(radius) {
        const r = Math.abs(radius);
        const m = this.getTotalMass();
        const trackGrip = Track.gripMultiplier || 1.0;
        
        // TireModel: compound-specific grip
        const compGrip = Weather.getCompoundGripFactor(Tire.compound);
        const modeGrip = TireModel.getDrivingModeGrip(DrivingMode.current);
        
        const baseGrip = CarConfig.tireGrip * Tire.getGripMultiplier() * trackGrip * compGrip * modeGrip;
        const camberFactor = CamberModel.getFactors(CarConfig.camber).kLat;
        const mu = baseGrip * camberFactor;
        
        // Aero: Wings only (kAero=1.0, no diffuser/platform)
        const Cl = this.getSetupCLift();
        const A = CarConfig.frontalArea;
        
        // Analytisch mit Load Sensitivity (2-Schritt)
        return calcCornerSpeed(mu, m, r, Cl, A, AIR_DENSITY);
      },
      
      // Finale Kurvengeschwindigkeit MIT Suspension-Korrektur
      getCornerSpeed(radius) {
        const r = Math.abs(radius);
        // Step 1: Basis v berechnen (ohne Suspension)
        const vBase = this.getCornerSpeedBase(r);
        
        // Step 2: Platform-Faktoren bei vBase holen
        const factors = Platform.getFactorsAtSpeed(vBase);
        const kMech = factors.kMech;
        const kAero = factors.kAero;
        
        // Step 3: v nochmal berechnen MIT Suspension-Faktoren
        const m = this.getTotalMass();
        const trackGrip = Track.gripMultiplier || 1.0;
        const compGrip = Weather.getCompoundGripFactor(Tire.compound);
        const modeGrip = TireModel.getDrivingModeGrip(DrivingMode.current);
        const baseGrip = CarConfig.tireGrip * Tire.getGripMultiplier() * trackGrip * compGrip * modeGrip;
        const camberFactor = CamberModel.getFactors(CarConfig.camber).kLat;
        const muEff = baseGrip * camberFactor * kMech;
        // Full cLift with diffuser effect via kAero
        const ClEff = AeroModel.getEffectiveLift(CarConfig.cLWing, CarConfig.cLDiffuser, CarConfig.wingAngle, kAero);
        const A = CarConfig.frontalArea;

        // Analytisch mit Load Sensitivity (2-Schritt)
        return calcCornerSpeed(muEff, m, r, ClEff, A, AIR_DENSITY);
      },

      // Returns acceleration AND throttle percentage based on actual power usage
      getAccelerationWithThrottle() {
        const v = Math.max(this.v, 0.1);
        const m = this.getTotalMass();
        const grip = this.getEffectiveGrip('longitudinal'); // Use longitudinal camber factor

        const powerAccel = CarConfig.power / (m * v);

        const dragForce = 0.5 * AIR_DENSITY * this.getEffectiveCDrag() * CarConfig.frontalArea * v * v;
        const dragDecel = dragForce / m;

        // Rolling resistance: Frr = Crr * Fz
        const downforce = 0.5 * AIR_DENSITY * this.getEffectiveCLift() * CarConfig.frontalArea * v * v;
        const normalForce = m * GRAVITY + downforce;
        const camberRR_sv = CamberModel.getRollingResistanceFactor(CarConfig.camber);
        const rollResistForce = CarConfig.cRr * camberRR_sv * normalForce;
        const rollResistDecel = rollResistForce / m;

        // Degressive tire force model
        const maxTractionForce = this.getTireForce(grip, normalForce);
        const maxTraction = maxTractionForce / m;

        // Determine if traction-limited
        let usedAccel, throttlePct;
        if (powerAccel <= maxTraction) {
          // Full power can be used
          usedAccel = powerAccel;
          throttlePct = 100;
        } else {
          // Traction-limited: only use what grip allows
          usedAccel = maxTraction;
          throttlePct = (maxTraction / powerAccel) * 100;
        }

        const accel = Math.max(usedAccel - dragDecel - rollResistDecel, 0.1);
        return { accel, throttlePct };
      },

      getWorldPos() {
        return Track.getPointPitAware(this.visualS, this.pit.inLane);
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // TELEMETRY
    // ═══════════════════════════════════════════════════════════════════════════════
    const Telemetry = {
      laps: [],
      _lastSampleD: 0,
      sampleStepM: 2.0,
      MAX_KEPT_LAPS: 15,  // Only keep point data for last N laps (saves ~170MB+ in long races)

      reset() { this.laps = []; this._lastSampleD = 0; },

      ensureLap(lapIndex) {
        while (this.laps.length <= lapIndex) this.laps.push({ 
          lapIndex: this.laps.length, 
          points: [], 
          lapTime: null,
          setup: null
        });
        return this.laps[lapIndex];
      },

      // Call when lap completes to store lap time and setup snapshot
      finalizeLap(lapIndex, lapTime) {
        const lap = this.ensureLap(lapIndex);
        lap.lapTime = lapTime;
        lap.setup = structuredClone(CarConfig);
        lap.setup.pitSpeed = Track.pit.speedLimit * 3.6;
        lap.setup.pitOffset = Track.pit.offset;
        // Store tire state if available
        if (typeof Tire !== 'undefined') {
          lap.setup.tireCondition = Tire.condition;
        }
        
        // ── MEMORY GUARD: evict point data from old laps ──
        // Keep lap metadata (lapTime, setup) but release the large points array
        const evictBefore = lapIndex - this.MAX_KEPT_LAPS;
        if (evictBefore >= 0 && this.laps[evictBefore]) {
          this.laps[evictBefore].points = null;  // Release ~2900 objects
          this.laps[evictBefore].setup = null;
        }
      },

      sample() {
        const absoluteD = Track.normalize(Car.s);
        // Store distance relative to start/finish line (so lap starts at 0)
        const d = Track.normalize(absoluteD - Track.startLineS + Track.lapLength);
        const lap = this.ensureLap(Car.lap);

        const delta = Math.abs(d - this._lastSampleD);
        if (lap.points.length > 0 && delta < this.sampleStepM && !(delta > Track.lapLength * 0.5)) return;

        this._lastSampleD = d;
        
        // Calculate fuel consumption rate (kg/s)
        const fuelRate = 0.04 * (Car.throttle / 100);
        
        lap.points.push({
          d,
          v: Car.v * 3.6,
          vLim: (Car.vLimit == null ? null : Car.vLimit * 3.6),
          a: Car.a,
          thr: Car.throttle,
          brk: Car.brake,
          fuelCons: fuelRate * 3600, // kg/h for display
          t: Simulation.time - Car.lapStartTime // time in lap for delta calculation
        });
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // LIFT & COAST
    // ═══════════════════════════════════════════════════════════════════════════════
    const LiftCoast = {
      active: false, // Currently coasting
      
      // Get the controlled car (or fallback to global Car)
      getControlledCar() {
        if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
          const controlled = MultiCarRace.cars.find(c => c.id === (RaceUI?.controlledCarId || 1));
          if (controlled) return controlled;
        }
        return Car;
      },
      
      // Check if L&C can be activated:
      // - On straight
      // - Distance to next corner < 300m
      // - Speed >= 100 km/h
      // - Not in pit lane
      canActivate() {
        const car = this.getControlledCar();
        const pitState = car.pit || Car.pit;
        
        if (pitState.inLane) return false;
        
        const segInfo = Track.atPosition(car.s);
        if (segInfo.segment.kind !== 'straight') return false;
        
        const nextCorner = Track.getNextCorner(car.s);
        if (!nextCorner.found) return false;
        if (nextCorner.distance > 500) return false;
        
        if (car.v * 3.6 < 100) return false;
        
        return true;
      },
      
      // Update button state
      syncButton() {
        const btn = document.getElementById('liftCoastBtn');
        if (!btn) return;
        
        if (this.active) {
          btn.disabled = false;
          btn.textContent = '🌊 L&C ACTIVE';
          btn.classList.add('primary');
        } else if (this.canActivate()) {
          btn.disabled = false;
          btn.textContent = '🌊 LIFT & COAST';
          btn.classList.remove('primary');
        } else {
          btn.disabled = true;
          btn.textContent = '🌊 LIFT & COAST';
          btn.classList.remove('primary');
        }
      },
      
      // Toggle L&C mode
      toggle() {
        if (this.active) {
          this.active = false;
        } else if (this.canActivate()) {
          this.active = true;
        }
        this.syncButton();
      },
      
      // Get coasting deceleration (drag + rolling resistance, no power)
      getCoastDecel() {
        const car = this.getControlledCar();
        const v = Math.max(car.v, 0.1);
        const m = car.getTotalMass ? car.getTotalMass() : Car.getTotalMass();
        
        const cDrag = car.getEffectiveCDrag ? car.getEffectiveCDrag() : Car.getEffectiveCDrag();
        const cLift = car.getEffectiveCLift ? car.getEffectiveCLift() : Car.getEffectiveCLift();
        const setup = car.setup || CarConfig;
        
        const dragForce = 0.5 * AIR_DENSITY * cDrag * setup.frontalArea * v * v;
        const dragDecel = dragForce / m;
        
        // Rolling resistance
        const downforce = 0.5 * AIR_DENSITY * cLift * setup.frontalArea * v * v;
        const normalForce = m * GRAVITY + downforce;
        const camberRR_lc = CamberModel.getRollingResistanceFactor(setup.camber || CarConfig.camber);
        const rollResistDecel = (setup.cRr * camberRR_lc * normalForce) / m;
        
        return dragDecel + rollResistDecel;
      },
      
      reset() {
        this.active = false;
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // SIMULATION (Brake Envelope + Pit Envelope)
    // ═══════════════════════════════════════════════════════════════════════════════
    const Simulation = {
      running: false,
      time: 0,
      speed: 1,
      lastFrameTime: 0,
      accumulator: 0,

      // Corner envelope cache
      _env: null,
      _lastEnvBuildTime: -999,

      // Pit envelope cache (entry speed limit)
      _envPit: null,
      _lastPitEnvBuildTime: -999,

      reset() {
        this.running = false;
        this.time = 0;
        this.accumulator = 0;
        this._env = null;
        this._envPit = null;
        this._lastEnvBuildTime = -999;
        this._lastPitEnvBuildTime = -999;

        Car.reset();
        Tire.reset();
        Platform.reset();
        Telemetry.reset();
        LiftCoast.reset();
        RaceFinish.reset();
        Weather.reset();
        AIR_DENSITY = Weather.airDensity;
        Renderer.tracks = [];
        Renderer._lastTrackSampleS = 0;
        UI.syncPitButtons();
        
        // Reset Multi-Car Race (only if RaceUI is defined)
        if (typeof RaceUI !== 'undefined' && typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
          RaceUI.initRace();
        }
        
        // Build speed-based platform lookup table
        Platform.buildLookupTable({
          rideHeight: CarConfig.rideHeight,
          springK: CarConfig.springK,
          damperC: CarConfig.damperC
        });
      },

      // ══════════════════════════════════════════════════════════════════════
      // BRAKING ENVELOPE - Implizite Rückwärts-Simulation
      // ══════════════════════════════════════════════════════════════════════
      // Problem: Parameter (kMech, kAero, Downforce) sind geschwindigkeitsabhängig
      // Lösung: In jedem Rückwärts-Schritt Parameter bei aktuellem v aktualisieren
      //
      // Physik Rückwärts:
      //   dv/ds = b(v) / v  →  v(s+ds) = v(s) + (b(v)/v) * ds
      //   wobei b(v) die Bremsverzögerung bei v ist (abhängig von Downforce, kMech)
      // ══════════════════════════════════════════════════════════════════════
      buildEnvelope(distToTarget, vTarget, key) {
        // ALWAYS build for fixed 400m range with fixed ds
        // This prevents curve instability when rebuilt at different distances
        const maxEnvelopeDist = 400;
        const ds = 0.75;
        const n = Math.max(1, Math.ceil(maxEnvelopeDist / ds));
        const vMax = new Float32Array(n + 1);

        let v = Math.max(0.1, vTarget);
        vMax[0] = v;

        // Konstanten die sich nicht mit v ändern
        const m = Car.getTotalMass();
        const trackGrip = Track.gripMultiplier || 1.0;
        const compGrip = Weather.getCompoundGripFactor(Tire.compound);
        const modeGrip = TireModel.getDrivingModeGrip(DrivingMode.current);
        const baseGrip = CarConfig.tireGrip * Tire.getGripMultiplier() * trackGrip * compGrip * modeGrip;
        const camberFactor = CamberModel.getFactors(CarConfig.camber).kLong;
        const rhoHalfA = 0.5 * AIR_DENSITY * CarConfig.frontalArea;

        for (let i = 1; i <= n; i++) {
          // ─── IMPLIZIT: Parameter bei aktuellem v holen ───
          const factors = Platform.getFactorsAtSpeed(v);
          const kMech = factors.kMech;
          const kAero = factors.kAero;
          
          // Effektive Werte bei diesem v
          const gripEff = baseGrip * camberFactor * kMech;
          const ClEff = AeroModel.getEffectiveLift(CarConfig.cLWing, CarConfig.cLDiffuser, CarConfig.wingAngle, kAero);
          
          // Downforce und Bremskraft bei diesem v
          const downforce = rhoHalfA * ClEff * v * v;
          const normalForce = m * GRAVITY + downforce;
          // Load-sensitive grip: F = µ * Fz^0.98
          const gripForce = gripEff * Math.pow(normalForce, TIRE_LOAD_SENSITIVITY);
          const effectiveBrake = Math.min(CarConfig.brakeForce, gripForce);
          const b = (effectiveBrake / m) * BRAKE_SAFETY;
          
          // Rückwärts-Euler: v steigt (wir gehen von Kurve weg)
          const dv = (b / Math.max(0.5, v)) * ds;
          v = v + dv;
          vMax[i] = v;
        }

        return {
          key,
          ds,
          vMax,
          distBuilt: maxEnvelopeDist,
          vTarget,
          builtAtTime: this.time,
          builtFuel: Car.fuel
        };
      },

      // Interpolierte Geschwindigkeitsgrenze aus der Bremskurve
      envelopeLimit(env, distToTarget) {
        if (!env) return Infinity;
        
        // If beyond envelope range, no limit needed yet
        if (distToTarget > env.distBuilt) return Infinity;
        if (distToTarget < 0) return env.vMax[0];
        
        // Exakter Index (mit Nachkommastellen)
        const exactIdx = distToTarget / env.ds;
        const i = Math.floor(exactIdx);
        const frac = exactIdx - i;
        
        // Interpolation zwischen zwei Punkten
        if (i >= env.vMax.length - 1) {
          return env.vMax[env.vMax.length - 1];
        }
        
        const v0 = env.vMax[i];
        const v1 = env.vMax[i + 1];
        return v0 + frac * (v1 - v0);
      },

      ensureCornerEnvelope(nextCorner) {
        if (!nextCorner?.found || nextCorner.distance <= 0) { this._env = null; return; }

        const vTarget = Car.getCornerSpeed(nextCorner.segment.radius);
        const key = `corner:${nextCorner.cornerIndex}`;

        // Build once per corner, never rebuild based on time.
        // Only rebuild when corner changes, fuel changes, or tire degrades.
        const needByKey = (!this._env || this._env.key !== key);
        const needByFuel = (!this._env || Math.abs(Car.fuel - this._env.builtFuel) >= 5.0);
        const needByTire = (!this._env || Math.abs(Tire.condition - (this._env.builtTireCond || 100)) >= 5.0);

        if (needByKey || needByFuel || needByTire) {
          this._env = this.buildEnvelope(nextCorner.distance, vTarget, key);
          this._env.builtTireCond = Tire.condition;
          this._lastEnvBuildTime = this.time;
        }
      },

      ensurePitEnvelope(distToEntry) {
        if (!Track.pit.enabled || distToEntry <= 0) { this._envPit = null; return; }

        const vTarget = Track.pit.speedLimit; // must hit pit limit at pit start
        const key = `pitEntry:${Math.round(Track.pit.startS)}`;

        const needByKey = (!this._envPit || this._envPit.key !== key);
        const needByTime = (this.time - this._lastPitEnvBuildTime) >= ENVELOPE_REBUILD_PERIOD;
        const needByFuel = (!this._envPit || Math.abs(Car.fuel - this._envPit.builtFuel) >= 1.0);

        if (needByKey || needByTime || needByFuel) {
          this._envPit = this.buildEnvelope(distToEntry, vTarget, key);
          this._lastPitEnvBuildTime = this.time;
        }
      },

      // Compute brake fraction for one tick to land near vAim
      // Returns: frac (0-1 of grip-limited max), bMax, brakePctOfMax (% of CarConfig.brakeForce)
      brakeFracToAim(vAim) {
        const bMax = Car.getBrakingAt(Car.v) * BRAKE_SAFETY;
        const aReq = (Car.v - vAim) / SIM_DT;     // positive
        const frac = Math.max(0, Math.min(1, aReq / Math.max(1e-6, bMax)));
        
        // Berechne % von max Bremsanlage
        const m = Car.getTotalMass();
        const actualBrakeForce = bMax * frac * m;
        const brakePctOfMax = (actualBrakeForce / CarConfig.brakeForce) * 100;
        
        return { frac, bMax, brakePctOfMax };
      },

      updatePit(prevS) {
        if (!Track.pit.enabled) return;

        const pit = Track.pit;
        const sNow = Track.normalize(Car.s);

        const crossedEntry = Track.didCrossLine(prevS, Car.s, pit.startS);
        const crossedBox   = Track.didCrossLine(prevS, Car.s, pit.stopS);
        const crossedExit  = Track.didCrossLine(prevS, Car.s, pit.endS);

        // Commit when crossing entry line while armed
        if (!Car.pit.inLane && Car.pit.armed && crossedEntry) {
          Car.pit.committed = true;
        }

        // Enter pit lane at entry line (if committed)
        if (!Car.pit.inLane && Car.pit.committed && crossedEntry) {
          Car.pit.inLane = true;
          Car.pit.limiter = true;
          Car.pit.phase = 'entry';
          Car.pit.armed = false;
          UI.syncPitButtons();
        }

        // In pit lane progression
        if (Car.pit.inLane) {
          if (Car.pit.limiter) {
            // limiter clamp (still keep it as hard cap)
            Car.v = Math.min(Car.v, pit.speedLimit);
          }

          if (Car.pit.phase === 'entry') {
            Car.pit.phase = 'toBox';
            Car.pit.stopped = false;
            UI.syncPitButtons();
          }

          if (Car.pit.phase === 'toBox') {
            const distToBox = Track.forwardDistance(sNow, pit.stopS);
            if (distToBox <= pit.boxStopTolerance || crossedBox) {
              Car.s = pit.stopS;
              Car.v = 0;

              Car.pit.stopped = true;
              Car.pit.phase = 'stopped';
              UI.syncPitButtons();
              
              // Apply any pending setup changes when entering box
              SetupUI.tryApplyPending();
            }
          }

          if (Car.pit.phase === 'exit') {
            if (crossedExit || (pit.startS < pit.endS && sNow >= pit.endS)) {
              Car.pit.inLane = false;
              Car.pit.limiter = false;
              Car.pit.committed = false;
              Car.pit.phase = 'merge';
              UI.syncPitButtons();
            }
          }

          if (Car.pit.phase === 'merge') {
            Car.pit.phase = 'none';
            UI.syncPitButtons();
          }
        }
      },

      step() {
        // ═══════════════════════════════════════════════════════════════
        // MULTIPLAYER CLIENT: Skip all physics — server sends world state
        // ═══════════════════════════════════════════════════════════════
        if (Multiplayer.isMultiplayerRace && !Multiplayer.isHost) {
          // Client: no physics, no simulation. All state comes from server.
          // Just advance time for telemetry display.
          this.time += SIM_DT;
          return;
        }
        
        // ═══════════════════════════════════════════════════════════════
        // MULTI-CAR RACE MODE: All physics handled by MultiCarRace
        // (Server in MP mode, or single-player)
        // ═══════════════════════════════════════════════════════════════
        
        // ── WEATHER: Full update (wetness, air density, track temp, track grip, compound cache, timeline) ──
        Weather.update(SIM_DT);
        AIR_DENSITY = Weather.airDensity;
        
        if (MultiCarRace.isActive && MultiCarRace.cars.length > 0) {
          // Update multi-car race system (lane management, slipstream)
          MultiCarRace.update();
          
          const controlledId = typeof RaceUI !== 'undefined' ? RaceUI.controlledCarId : 1;
          const controlled = MultiCarRace.cars.find(c => c.id === controlledId);
          
          // ── AI DRIVER UPDATE (for all non-controlled cars) ──
          // In multiplayer: NO AI — all cars are player-controlled via commands
          // In single-player: AI drives all non-controlled cars
          if (!Multiplayer.isMultiplayerRace) {
            const leaderLap = Math.max(...MultiCarRace.cars.map(c => c.lap));
            for (const car of MultiCarRace.cars) {
              if (!car.ai) continue;
              if (car.id === controlledId) {
                // Player car: only evaluate L&C (same fuel logic as AI)
                // Skip pit strategy — player controls pit manually
                car.ai.evaluateLiftCoast(car, car.lap, Track.totalLaps);
              } else {
                car.ai.update(car, this.time, MultiCarRace.cars, car.lap, Track.totalLaps);
              }
              MultiCarRace.updateCarPit(car, this.time);
            }
          }
          
          // In multiplayer SERVER mode: update pit for ALL cars (players control via commands)
          // In single-player: update pit for controlled car only
          if (Multiplayer.isMultiplayerRace && Multiplayer.isHost) {
            for (const car of MultiCarRace.cars) {
              MultiCarRace.updateCarPit(car, this.time);
            }
          } else {
            if (controlled) {
              MultiCarRace.updateCarPit(controlled, this.time);
            }
          }
          
          // Handle pit box stopped state for controlled car
          if (controlled && controlled.pit.inLane && controlled.pit.phase === 'stopped') {
            // Car is in box - apply pending setup
            if (typeof SetupUI !== 'undefined' && SetupUI.tryApplyPending) {
              SetupUI.tryApplyPending();
            }
            
            if (controlled.pit.exitRequested) {
              controlled.pit.exitRequested = false;
              controlled.pit.stopped = false;
              controlled.pit.phase = 'exit';
              
              // Rebuild this car's platform lookup table
              controlled.rebuildPlatformLookup();
              
              controlled.v = Math.max(controlled.v, Track.pit.speedLimit * 0.5);
              controlled.a = 0;
              UI.syncPitButtons();
            } else {
              controlled.v = 0;
              controlled.a = 0;
              controlled.throttle = 0;
              controlled.brake = 100;
            }
          }
          
          // All cars use the same physics engine (SERVER runs all)
          for (const car of MultiCarRace.cars) {
            // Skip physics for cars that finished the race
            if (car._raceFinished) {
              car.v = Math.max(car.v - 2 * SIM_DT, 0); // Slow down after finish
              car.s += car.v * SIM_DT;
              if (car.s >= Track.lapLength) car.s -= Track.lapLength;
              continue;
            }
            // Skip physics for car in box
            if (car.pit && car.pit.inLane && car.pit.phase === 'stopped') {
              // Handle pit box exit (AI in single-player, or player command in MP)
              if (car.pit.exitRequested) {
                car.pit.exitRequested = false;
                car.pit.stopped = false;
                car.pit.phase = 'exit';
                car.v = Math.max(car.v, Track.pit.speedLimit * 0.5);
                car.a = 0;
              } else {
                car.v = 0;
                car.a = 0;
              }
              continue;
            }
            MultiCarRace.updateCarPhysics(car, this.time);
            // NaN guard
            if (!Number.isFinite(car.v)) car.v = 10;
            if (!Number.isFinite(car.s)) car.s = car.prevS || 0;
          }
          
          // Sync the CONTROLLED car's state TO the global Car object
          if (controlled) {
            Car.s = controlled.s;
            Car.v = controlled.v;
            Car.a = controlled.a;
            Car.lap = controlled.lap;
            Car.throttle = controlled.throttle;
            Car.brake = controlled.brake;
            Car.lastLapTime = controlled.lastLapTime;
            Car.bestLapTime = controlled.bestLapTime;
            Car.fuel = controlled.fuel;
            Car.currentLapTime = controlled.currentLapTime;
            Car.visualS = controlled.visualS;
            Car.prevS = controlled.prevS;
            Car.lapStartTime = controlled.lapStartTime;
            Car.fuelAtLapStart = controlled.fuelAtLapStart;
            Car.lastLapFuelUsed = controlled.lastLapFuelUsed;
            Car.vLimit = controlled.vLimit;  // Sync braking envelope limit
            
            // Sync pit state to global Car.pit
            Car.pit.armed = controlled.pit.armed;
            Car.pit.committed = controlled.pit.committed;
            Car.pit.inLane = controlled.pit.inLane;
            Car.pit.limiter = controlled.pit.limiter;
            Car.pit.stopped = controlled.pit.stopped;
            Car.pit.phase = controlled.pit.phase;
            Car.pit.exitRequested = controlled.pit.exitRequested;
            
            if (controlled.tire && typeof Tire !== 'undefined') {
              Tire.condition = controlled.tire.condition;
              Tire.compound = controlled.tire.compound;
            }
          }
          
          // Update platform based on controlled car speed
          Platform.updateFromSpeed(Car.v);
          
          Telemetry.sample();
          this.time += SIM_DT;
          
          // Check race finish
          RaceFinish.check();
          
          return; // Skip single-car physics below
        }
        
        // ═══════════════════════════════════════════════════════════════
        // SINGLE-CAR MODE (original physics for backwards compatibility)
        // ═══════════════════════════════════════════════════════════════
        const prevS = Car.s;
        Car.prevS = Car.s;

        const segInfo = Track.atPosition(Car.s);
        const isCorner = segInfo.segment.kind === 'corner';

        // Pit stopped (box)
        if (Car.pit.inLane && Car.pit.phase === 'stopped') {
          Car.vLimit = null;

          // Try to apply pending setup changes when in box
          if (typeof SetupUI !== 'undefined' && SetupUI.tryApplyPending) {
            SetupUI.tryApplyPending();
          }

          if (Car.pit.exitRequested) {
            Car.pit.exitRequested = false;
            Car.pit.stopped = false;
            Car.pit.phase = 'exit';

            // Rebuild speed-based platform lookup table with current setup
            Platform.buildLookupTable({
              rideHeight: CarConfig.rideHeight,
              springK: CarConfig.springK,
              damperC: CarConfig.damperC
            });
            console.log('Platform lookup table rebuilt for stint');

            Car.v = Math.max(Car.v, Track.pit.speedLimit * 0.5);
            Car.a = 0;
            UI.syncPitButtons();
          } else {
            Car.v = 0;
            Car.a = 0;
            Car.throttle = 0;
            Car.brake = 100;

            Car.currentLapTime = this.time - Car.lapStartTime;
            Telemetry.sample();
            this.time += SIM_DT;
            return;
          }
        }

        // ─────────────────────────────────────────────
        // MAIN CONTROL
        // ─────────────────────────────────────────────
        if (!Car.pit.inLane) {
          if (isCorner) {
            // Deactivate L&C when entering corner
            LiftCoast.active = false;
            
            const vCorner = Car.getCornerSpeed(segInfo.segment.radius);
            if (Car.v > vCorner) Car.v = vCorner;

            // In corner: need throttle to maintain speed against drag + rolling resistance
            const v = Math.max(Car.v, 0.1);
            const m = Car.getTotalMass();
            const dragForce = 0.5 * AIR_DENSITY * Car.getEffectiveCDrag() * CarConfig.frontalArea * v * v;
            const downforce = 0.5 * AIR_DENSITY * Car.getEffectiveCLift() * CarConfig.frontalArea * v * v;
            const normalForce = m * GRAVITY + downforce;
            const camberRR_sc = CamberModel.getRollingResistanceFactor(CarConfig.camber);
            const rollResistForce = CarConfig.cRr * camberRR_sc * normalForce;
            const resistanceForce = dragForce + rollResistForce;
            
            // Power needed to maintain speed = F * v
            const powerNeeded = resistanceForce * v;
            const throttlePct = Math.min(100, (powerNeeded / CarConfig.power) * 100);
            
            Car.throttle = throttlePct;
            Car.brake = 0;
            Car.a = 0;  // Constant speed in corner
            Car.vLimit = null;

            Car.s += Car.v * SIM_DT;

            this._env = null;
            this._envPit = null;

          } else {
            // Decide envelope target:
            // 1) If PIT ARMED => target is pit entry speed limit at pit.startS (this ensures not too fast into pit/box)
            // 2) Else => target is next corner entry speed
            const sNow = Track.normalize(Car.s);

            if (Track.pit.enabled && Car.pit.armed) {
              const distToPitEntry = Track.forwardDistance(sNow, Track.pit.startS);

              // Build pit envelope so we can still reach speedLimit at pit entry.
              this.ensurePitEnvelope(distToPitEntry);

              const vLimit = this.envelopeLimit(this._envPit, distToPitEntry);
              Car.vLimit = Number.isFinite(vLimit) ? vLimit : null;

              if (Car.v > vLimit + ENVELOPE_EPS) {
                const vAim = vLimit + (ENVELOPE_EPS * 0.20);
                const { frac, bMax, brakePctOfMax } = this.brakeFracToAim(vAim);

                Car.throttle = 0;
                Car.brake = brakePctOfMax;  // % von max Bremsanlage

                const accel = -bMax * frac;
                Car.a = accel;

                Car.v = Math.max(0, Car.v + accel * SIM_DT);
                Car.s += Car.v * SIM_DT;
              } else {
                const { accel, throttlePct } = Car.getAccelerationWithThrottle();
                Car.throttle = throttlePct;
                Car.brake = 0;
                Car.a = accel;

                Car.v = Math.max(0, Car.v + accel * SIM_DT);
                Car.s += Car.v * SIM_DT;
              }

            } else {
              const nextCorner = Track.getNextCorner(Car.s);

              if (nextCorner.found && nextCorner.distance > 0) {
                this.ensureCornerEnvelope(nextCorner);

                const distToEntry = nextCorner.distance;
                const vTarget = Car.getCornerSpeed(nextCorner.segment.radius);
                const vLimitHere = this.envelopeLimit(this._env, distToEntry);
                Car.vLimit = Number.isFinite(vLimitHere) ? vLimitHere : null;

                // ══════════════════════════════════════════════════════════════
                // PRÄZISES BREMSEN: Immer genau auf der Bremskurve bleiben
                // ══════════════════════════════════════════════════════════════
                // 1. Berechne hypothetisches Vollgas
                // 2. Prüfe ob wir danach über der Bremskurve wären
                // 3. Falls ja: Schaue welche v wir am nächsten Punkt haben dürfen
                // 4. Bremse genau so, dass wir diese v erreichen
                // ══════════════════════════════════════════════════════════════
                
                const { accel: accelFree, throttlePct } = Car.getAccelerationWithThrottle();
                
                // Wo wären wir im nächsten Step?
                const dsStep = Car.v * SIM_DT;
                const distNext = distToEntry - dsStep;
                
                // Welche v ist dort erlaubt? (interpoliert)
                const vLimitNext = this.envelopeLimit(this._env, distNext);
                
                // Hypothetische v nach Vollgas
                const vNextFree = Car.v + accelFree * SIM_DT;
                
                // Sind wir aktuell schon über der Kurve ODER würden wir drüber kommen?
                const overCurveNow = Car.v > vLimitHere + ENVELOPE_EPS;
                const overCurveNext = vNextFree > vLimitNext + ENVELOPE_EPS;
                
                if (overCurveNow || overCurveNext) {
                  // ─── BREMSEN: Ziel-v = erlaubte v am nächsten Punkt ───
                  LiftCoast.active = false;
                  
                  // vAim = interpolierte Grenze am nächsten Punkt
                  const vAim = Math.max(vTarget, vLimitNext);
                  
                  // Benötigte Beschleunigung (negativ = Bremsen)
                  // a = (vAim - v) / dt
                  const aNeeded = (vAim - Car.v) / SIM_DT;
                  
                  if (aNeeded >= 0) {
                    // Eigentlich könnten wir beschleunigen, aber wir sind über der Kurve
                    // → Rollen lassen (kein Gas, kein Bremsen)
                    Car.throttle = 0;
                    Car.brake = 0;
                    Car.a = -Car.getBrakingAt(Car.v) * 0.1;  // Leichte Engine-Bremse
                  } else {
                    // Bremsen mit genau der nötigen Kraft
                    const bMax = Car.getBrakingAt(Car.v);  // Grip-limitierte max Verzögerung
                    const frac = Math.min(1, Math.abs(aNeeded) / bMax);
                    
                    // Tatsächliche Bremskraft als % von CarConfig.brakeForce
                    // bMax = effectiveBrake / m, also effectiveBrake = bMax * m
                    const m = Car.getTotalMass();
                    const actualBrakeForce = bMax * frac * m;
                    const brakePctOfMax = (actualBrakeForce / CarConfig.brakeForce) * 100;
                    
                    Car.throttle = 0;
                    Car.brake = brakePctOfMax;  // % von max Bremsanlage
                    Car.a = -bMax * frac;
                  }
                  
                  Car.v = Math.max(0.1, Car.v + Car.a * SIM_DT);
                  Car.s += Car.v * SIM_DT;

                } else if (LiftCoast.active) {
                  // Lift & Coast active - coast (no throttle, only drag decel)
                  const coastDecel = LiftCoast.getCoastDecel();
                  Car.throttle = 0;
                  Car.brake = 0;
                  Car.a = -coastDecel;

                  Car.v = Math.max(0.1, Car.v - coastDecel * SIM_DT);
                  Car.s += Car.v * SIM_DT;

                } else {
                  // ─── VOLLGAS ───
                  Car.throttle = throttlePct;
                  Car.brake = 0;
                  Car.a = accelFree;

                  Car.v = Math.max(0.1, Car.v + accelFree * SIM_DT);
                  Car.s += Car.v * SIM_DT;
                }

                // Snap auf vTarget wenn sehr nah an Kurve
                if (distToEntry < 1.0 && Car.v > vTarget) {
                  Car.v = vTarget;
                  Car.a = 0;
                }

              } else {
                const { accel, throttlePct } = Car.getAccelerationWithThrottle();
                Car.throttle = throttlePct;
                Car.brake = 0;
                Car.a = accel;
                Car.vLimit = null;

                Car.v = Math.max(0, Car.v + accel * SIM_DT);
                Car.s += Car.v * SIM_DT;

                this._env = null;
              }
            }
          }
        } else {
          // PIT LANE CONTROL:
          // - limiter clamps to speedLimit
          // - AND: when approaching the box, brake so we actually stop (not "teleport fast")
          Car.vLimit = null;
          this._env = null;
          this._envPit = null;

          const pit = Track.pit;
          const sNow = Track.normalize(Car.s);

          if (Car.pit.phase === 'toBox') {
            const distToBox = Track.forwardDistance(sNow, pit.stopS);

            // Compute stopping need under max braking
            const bMax = Car.getBrakingAt(Car.v) * BRAKE_SAFETY;
            const needDist = (Car.v * Car.v) / (2 * Math.max(1e-6, bMax));

            if (distToBox <= Math.max(1.0, needDist * 1.02)) {
              // brake to aim near zero
              const { frac, bMax: b2, brakePctOfMax } = this.brakeFracToAim(PIT_BOX_V_AIM);
              const useFrac = Math.max(frac, 0.25); // ensure "hard" braking when in box approach
              
              // Berechne % von max Bremsanlage für Anzeige
              const m = Car.getTotalMass();
              const actualBrakeForce = b2 * useFrac * m;
              const brakePctDisplay = (actualBrakeForce / CarConfig.brakeForce) * 100;

              Car.throttle = 0;
              Car.brake = brakePctDisplay;  // % von max Bremsanlage
              Car.a = -b2 * useFrac;

              Car.v = Math.max(0, Car.v + Car.a * SIM_DT);
              Car.s += Car.v * SIM_DT;
            } else {
              // gentle creep towards box (and limiter will cap)
              if (Car.v < pit.speedLimit * 0.92) {
                const accel = Car.getAcceleration() * 0.10;
                Car.throttle = 18;
                Car.brake = 0;
                Car.a = accel;
                Car.v = Math.max(0, Car.v + accel * SIM_DT);
              } else {
                Car.throttle = 6;
                Car.brake = 0;
                Car.a = 0;
              }
              Car.s += Car.v * SIM_DT;
            }
          } else {
            // entry/exit/merge phases
            const limit = pit.speedLimit;
            if (Car.v < limit * 0.97) {
              const accel = Car.getAcceleration() * 0.12;
              Car.throttle = 20;
              Car.brake = 0;
              Car.a = accel;
              Car.v = Math.max(0, Car.v + accel * SIM_DT);
            } else {
              Car.throttle = 8;
              Car.brake = 0;
              Car.a = 0;
            }
            Car.s += Car.v * SIM_DT;
          }
        }

        // ── Safety: cap speed to prevent runaway (physics breakdown) ──
        if (Car.v > 139) Car.v = 139;  // 500 km/h hard cap
        
        // Fuel
        const fuelRate = 0.04 * (Car.throttle / 100);
        Car.fuel = Math.max(0, Car.fuel - fuelRate * SIM_DT);

        // Tire wear update - based on grip UTILIZATION (how much of available grip is used)
        // Key insight: more downforce = more available grip = LOWER utilization = LESS wear
        const distDelta = Math.abs(Car.s - prevS);
        const v = Math.max(Car.v, 0.1);
        const m = Car.getTotalMass();
        const downforce = 0.5 * AIR_DENSITY * Car.getEffectiveCLift() * CarConfig.frontalArea * v * v;
        const normalForce = m * GRAVITY + downforce;
        const maxGripForce = Car.getEffectiveGrip() * normalForce;
        
        // Calculate demanded force vs available grip
        const tireSegInfo = Track.atPosition(Car.s);
        let demandedForce = 0;
        
        if (tireSegInfo.segment.kind === 'corner') {
          // In corner: lateral force = m * v² / r (this is the demanded force)
          demandedForce = m * v * v / Math.abs(tireSegInfo.segment.radius);
        } else {
          // On straight: longitudinal force
          // For braking: brake is at limit, tire may not be
          // For accel: engine/traction limits apply
          if (Car.brake > 0) {
            // Braking: actual brake force used (may be less than grip allows)
            const brakeForceDemanded = Car.getBrakingAt(v) * m * (Car.brake / 100);
            demandedForce = brakeForceDemanded;
          } else if (Car.throttle > 0) {
            // Acceleration: power-limited or traction-limited
            const powerForce = CarConfig.power / v;
            const tractionLimit = maxGripForce;
            // If power < traction limit, we're power-limited (tire not working hard)
            // If power >= traction limit, we're traction-limited (tire at limit)
            demandedForce = Math.min(powerForce, tractionLimit) * (Car.throttle / 100);
          }
        }
        
        // Grip utilization: how much of available grip is being used
        // This correctly models: more downforce = more grip available = lower utilization = less wear
        const gripUtilization = Math.min(1, demandedForce / maxGripForce);
        
        // Apply camber wear multiplier (more |camber| = more inner edge wear)
        // Apply platform wear multiplier (bouncing/bottoming increases wear)
        const camberWearMult = CamberModel.getWearFactor(CarConfig.camber);
        const platformWearMult = Platform.current.kWear;
        // TireModel: compound-specific wear stress + driving mode wear
        const tireModelWearMult = Weather.getCompoundWearMult(Tire.compound);
        const modeWearMult = TireModel.getDrivingModeWear(DrivingMode.current);
        Tire.update(distDelta, gripUtilization * Math.sqrt(camberWearMult) * platformWearMult * tireModelWearMult * modeWearMult);

        // Update platform factors based on current speed (live interpolation)
        Platform.updateFromSpeed(Car.v);

        // Pit update after motion (handles entry, clamp, box stop, exit)
        this.updatePit(prevS);

        // Lap timing (sub-ms interpolation)
        if (Track.didCrossLine(prevS, Car.s, Track.startLineS)) {
          // Interpolate exact S/F crossing moment
          const dTotal = Track.forwardDistance(prevS, Car.s);
          const dToLine = Track.forwardDistance(prevS, Track.startLineS);
          const fraction = dTotal > 0.001 ? (dTotal - dToLine) / dTotal : 0;
          const crossTime = this.time + SIM_DT - fraction * SIM_DT;

          const lapTime = crossTime - Car.lapStartTime;

          if (this.time > 0.05) {
            Car.lastLapTime = lapTime;
            Car.lastLapFuelUsed = Car.fuelAtLapStart - Car.fuel;
            if (Car.lap > 0) {
              Telemetry.finalizeLap(Car.lap, lapTime);
            }
            if (Car.lap > 0) {
              if (!Car.bestLapTime || lapTime < Car.bestLapTime) Car.bestLapTime = lapTime;
            }
          }

          Car.lap++;
          Car.lapStartTime = crossTime;
          Car.fuelAtLapStart = Car.fuel;
          Telemetry._lastSampleD = 0;

          if (typeof LiftCoast !== 'undefined') {
            LiftCoast.active = false;
          }

          this._lastEnvBuildTime = -999;
          this._lastPitEnvBuildTime = -999;
          this._env = null;
          this._envPit = null;
        }

        Car.currentLapTime = this.time - Car.lapStartTime;

        Telemetry.sample();
        this.time += SIM_DT;
        
        // Note: Multi-car physics is handled at the start of step() with early return
      },

      interpolate(alpha) {
        let diff = Car.s - Car.prevS;
        if (diff < -Track.lapLength / 2) diff += Track.lapLength;

        Car.visualS = Car.prevS + diff * alpha;
        Car.visualS = Track.normalize(Car.visualS);
        
        // Also interpolate all MultiCarRace cars
        if (MultiCarRace.isActive) {
          for (const car of MultiCarRace.cars) {
            let cDiff = car.s - (car.prevS || car.s);
            if (cDiff < -Track.lapLength / 2) cDiff += Track.lapLength;
            car.visualS = (car.prevS || car.s) + cDiff * alpha;
            car.visualS = Track.normalize(car.visualS);
          }
        }
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // RENDERER
    // ═══════════════════════════════════════════════════════════════════════════════
    const Renderer = {
      canvas: null,
      ctx: null,
      zoom: 1.0,
      panX: 0,
      panY: 0,
      isDragging: false,
      dragStartX: 0,
      dragStartY: 0,
      
      // Follow camera mode
      followMode: false,
      followZoom: 8.0,     // Zoom level for follow mode (close-up)
      followSmooth: 0.08,  // Camera smoothing factor

      tracks: [],
      maxTrackPoints: 900,
      trackSampleDist: 0.6,
      _lastTrackSampleS: 0,

      _initialized: false,
      
      init() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');

        // Only bind event listeners once to prevent accumulation on re-init
        if (!this._initialized) {
          this._initialized = true;
          
          this.resize();
          window.addEventListener('resize', () => this.resize());

          this.canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = this.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.3, Math.min(15, this.zoom * zoomFactor));

            this.panX = mouseX - (mouseX - this.panX) * (newZoom / this.zoom);
            this.panY = mouseY - (mouseY - this.panY) * (newZoom / this.zoom);
            this.zoom = newZoom;

            document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
          }, { passive: false });

          this.canvas.addEventListener('mousedown', (e) => {
            this.isDragging = true;
            this.dragStartX = e.clientX - this.panX;
            this.dragStartY = e.clientY - this.panY;
            this.canvas.style.cursor = 'grabbing';
          });

          this.canvas.addEventListener('mousemove', (e) => {
            if (this.isDragging) {
              this.panX = e.clientX - this.dragStartX;
              this.panY = e.clientY - this.dragStartY;
            }
          });

          this.canvas.addEventListener('mouseup', () => {
            this.isDragging = false;
            this.canvas.style.cursor = 'grab';
          });

          this.canvas.addEventListener('mouseleave', () => {
            this.isDragging = false;
            this.canvas.style.cursor = 'grab';
          });

          this.canvas.style.cursor = 'grab';
        } else {
          this.resize();
        }
      },

      resize() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
        this.centerTrack();
      },

      centerTrack() {
        const points = Track.generatePoints();
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

        for (const p of points) {
          minX = Math.min(minX, p.x);
          maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y);
        }

        const pit = Track.pit;
        if (pit.enabled) {
          minX = Math.min(minX, minX + pit.offset);
          maxX = Math.max(maxX, maxX + pit.offset);
          minY = Math.min(minY, minY + pit.offset);
          maxY = Math.max(maxY, maxY + pit.offset);
        }

        const trackW = maxX - minX;
        const trackH = maxY - minY;
        const W = this.canvas.width;
        const H = this.canvas.height;

        this.zoom = Math.min((W - 80) / trackW, (H - 80) / trackH) * 0.9;
        this.panX = W / 2 - (minX + trackW / 2) * this.zoom;
        this.panY = H / 2 - (minY + trackH / 2) * this.zoom;

        document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
      },

      pushTrackSample() {
        const ds = Math.abs(Car.s - this._lastTrackSampleS);
        if (ds < this.trackSampleDist && !(ds > Track.lapLength * 0.5)) return;

        this._lastTrackSampleS = Car.s;

        const p = Car.getWorldPos();
        this.tracks.push({ x: p.x, y: p.y, heading: p.heading, brake: Car.brake, alpha: 1 });

        for (let i = 0; i < this.tracks.length; i++) this.tracks[i].alpha *= 0.997;
        while (this.tracks.length > this.maxTrackPoints) this.tracks.shift();
      },

      renderTracks() {
        const ctx = this.ctx;
        const zoom = this.zoom, panX = this.panX, panY = this.panY;

        if (this.tracks.length < 3) return;

        const halfWidth = 0.75;  // realistic tire track half-width
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        for (let i = 1; i < this.tracks.length; i++) {
          const a = this.tracks[i - 1];
          const b = this.tracks[i];
          const alpha = Math.min(a.alpha, b.alpha);

          const k = Math.min(1, 0.15 + (Math.max(a.brake, b.brake) / 100) * 0.85);
          ctx.strokeStyle = `rgba(0,0,0,${alpha * 0.22 * k})`;
          ctx.lineWidth = Math.max(1, 2.2 * zoom);

          const nxA = Math.cos(a.heading + Math.PI / 2);
          const nyA = Math.sin(a.heading + Math.PI / 2);
          const nxB = Math.cos(b.heading + Math.PI / 2);
          const nyB = Math.sin(b.heading + Math.PI / 2);

          const axL = (a.x + nxA * halfWidth) * zoom + panX;
          const ayL = (a.y + nyA * halfWidth) * zoom + panY;
          const bxL = (b.x + nxB * halfWidth) * zoom + panX;
          const byL = (b.y + nyB * halfWidth) * zoom + panY;

          ctx.beginPath();
          ctx.moveTo(axL, ayL);
          ctx.lineTo(bxL, byL);
          ctx.stroke();

          const axR = (a.x - nxA * halfWidth) * zoom + panX;
          const ayR = (a.y - nyA * halfWidth) * zoom + panY;
          const bxR = (b.x - nxB * halfWidth) * zoom + panX;
          const byR = (b.y - nyB * halfWidth) * zoom + panY;

          ctx.beginPath();
          ctx.moveTo(axR, ayR);
          ctx.lineTo(bxR, byR);
          ctx.stroke();
        }
      },

      render() {
        const W = this.canvas.width;
        const H = this.canvas.height;
        const ctx = this.ctx;
        
        // Follow camera mode: center on controlled car
        if (this.followMode && typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
          const controlledId = typeof RaceUI !== 'undefined' ? RaceUI.controlledCarId : 1;
          const targetCar = MultiCarRace.cars.find(c => c.id === controlledId);
          
          if (targetCar) {
            // Use ideal line + lane offset for smooth camera following
            let worldX, worldY;
            const renderS = targetCar.visualS || targetCar.s;
            const idealPos = TrackRenderer.getIdealLinePos ? TrackRenderer.getIdealLinePos(renderS) : null;
            if (idealPos && Number.isFinite(idealPos.x)) {
              const vLane = targetCar.visualLane || 0;
              const perpX = Math.cos(idealPos.heading + Math.PI / 2) * vLane;
              const perpY = Math.sin(idealPos.heading + Math.PI / 2) * vLane;
              worldX = idealPos.x + perpX;
              worldY = idealPos.y + perpY;
            } else {
              const pos = Track.getPointCorrected(renderS);
              worldX = pos.x;
              worldY = pos.y;
            }
            
            // Target camera position (centered on car)
            const targetPanX = W / 2 - worldX * this.followZoom;
            const targetPanY = H / 2 - worldY * this.followZoom;
            
            // Smooth camera movement
            this.panX += (targetPanX - this.panX) * this.followSmooth;
            this.panY += (targetPanY - this.panY) * this.followSmooth;
            this.zoom += (this.followZoom - this.zoom) * this.followSmooth;
          }
        }
        
        const zoom = this.zoom;
        const panX = this.panX;
        const panY = this.panY;

        // Clear canvas with landscape colour
        ctx.fillStyle = '#1a3a1a';
        ctx.fillRect(0, 0, W, H);

        // ─── TRACK (pre-rendered offscreen image, blitted every frame) ───
        if (!TrackRenderer.ready) {
          TrackRenderer.build(Track);
        }
        TrackRenderer.draw(ctx, zoom, panX, panY);

        this.pushTrackSample();
        this.renderTracks();

        // ─────────────────────────────────────────────────────────────────
        // RENDER ALL MULTI-CAR RACE CARS (unified size for all cars)
        // ─────────────────────────────────────────────────────────────────
        if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive && MultiCarRace.cars.length > 0) {
          this.renderMultiCars();
          return; // All cars rendered via renderMultiCars, skip legacy single-car rendering
        }

        // Legacy single-car rendering (only when MultiCarRace is not active)
        const carPos = Car.getWorldPos();
        const cx = carPos.x * zoom + panX;
        const cy = carPos.y * zoom + panY;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(carPos.heading);

        const L = 5.5 * zoom;    // realistic F1 length (5.5m)
        const Wc = 2.0 * zoom;    // realistic F1 width (2.0m)
        const wheelR = 0.66 * zoom;
        const wheelW = 0.36 * zoom;

        const bodyCol = CarConfig.color;
        const accent = CarConfig.teamColor;

        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.beginPath();
        ctx.ellipse(1.2 * zoom, 1.6 * zoom, (L * 0.55), (Wc * 0.42), 0, 0, Math.PI * 2);
        ctx.fill();

        function drawWheel(x, y) {
          ctx.save();
          ctx.translate(x, y);
          ctx.fillStyle = '#0b0b10';
          ctx.beginPath();
          ctx.roundRect(-wheelR, -wheelW, wheelR * 2, wheelW * 2, 2);
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.10)';
          ctx.beginPath();
          ctx.roundRect(-wheelR * 0.55, -wheelW * 0.55, wheelR * 1.1, wheelW * 1.1, 2);
          ctx.fill();
          ctx.restore();
        }

        drawWheel(L * 0.30, Wc * 0.55);
        drawWheel(L * 0.30, -Wc * 0.55);
        drawWheel(-L * 0.35, Wc * 0.55);
        drawWheel(-L * 0.35, -Wc * 0.55);

        ctx.fillStyle = '#12131a';
        ctx.beginPath();
        ctx.roundRect(-L * 0.48, -Wc * 0.34, L * 0.86, Wc * 0.68, 8);
        ctx.fill();

        const grad = ctx.createLinearGradient(-L * 0.55, 0, L * 0.55, 0);
        grad.addColorStop(0, 'rgba(255,255,255,0.08)');
        grad.addColorStop(0.18, bodyCol);
        grad.addColorStop(0.70, bodyCol);
        grad.addColorStop(1, 'rgba(0,0,0,0.25)');

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.roundRect(-L * 0.45, -Wc * 0.28, L * 0.80, Wc * 0.56, 10);
        ctx.fill();

        ctx.fillStyle = accent;
        ctx.beginPath();
        ctx.roundRect(L * 0.18, -Wc * 0.15, L * 0.25, Wc * 0.30, 8);
        ctx.fill();

        ctx.fillStyle = '#0f1118';
        ctx.beginPath();
        ctx.roundRect(L * 0.36, -Wc * 0.55, L * 0.18, Wc * 1.10, 10);
        ctx.fill();

        ctx.fillStyle = 'rgba(0,0,0,0.22)';
        ctx.beginPath();
        ctx.roundRect(-L * 0.15, -Wc * 0.40, L * 0.50, Wc * 0.22, 8);
        ctx.roundRect(-L * 0.15, Wc * 0.18, L * 0.50, Wc * 0.22, 8);
        ctx.fill();

        ctx.fillStyle = '#07080d';
        ctx.beginPath();
        ctx.roundRect(-L * 0.08, -Wc * 0.17, L * 0.30, Wc * 0.34, 10);
        ctx.fill();

        ctx.strokeStyle = 'rgba(255,255,255,0.10)';
        ctx.lineWidth = Math.max(1, 1.4 * zoom);
        ctx.beginPath();
        ctx.roundRect(-L * 0.06, -Wc * 0.15, L * 0.26, Wc * 0.30, 10);
        ctx.stroke();

        ctx.fillStyle = accent;
        ctx.beginPath();
        ctx.roundRect(-L * 0.54, -Wc * 0.60, L * 0.16, Wc * 1.20, 10);
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.font = `900 ${Math.max(3, Wc * 0.38)}px system-ui`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(CarConfig.number, -L * 0.12, 0);

        if (Car.brake > 0) {
          ctx.fillStyle = `rgba(255, 55, 55, ${Math.min(0.9, Car.brake / 110)})`;
          ctx.beginPath();
          ctx.arc(-L * 0.52, 0, 2.8 * zoom, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      },
      
      // Render all cars from MultiCarRace (unified rendering for all cars)
      _laneDebugTimer: 0,
      renderMultiCars() {
        const ctx = this.ctx;
        const zoom = this.zoom;
        const panX = this.panX;
        const panY = this.panY;
        
        // Safety check
        if (!MultiCarRace.cars || MultiCarRace.cars.length === 0) return;
        
        // DEBUG: log lane values every 2 seconds
        const now = performance.now();
        if (now - this._laneDebugTimer > 2000) {
          this._laneDebugTimer = now;
          const lanes = MultiCarRace.cars.slice(0, 5).map(c => 
            `Car${c.id}: lane=${c.lane?.toFixed(2)} tgt=${c.targetLane?.toFixed(2)} vis=${c.visualLane?.toFixed(2)}`
          );
          console.log('LANE DEBUG:', lanes.join(' | '));
        }
        
        const controlledId = typeof RaceUI !== 'undefined' ? RaceUI.controlledCarId : 1;
        
        // Sort cars by position so front cars render on top
        const sortedCars = [...MultiCarRace.cars].sort((a, b) => a.s - b.s);
        
        for (const car of sortedCars) {
          // Safety check - skip cars with invalid positions
          if (!Number.isFinite(car.s) || !Number.isFinite(car.v)) {
            continue;
          }
          
          // Render ALL cars with the same style (no special treatment for controlled car)
          const isControlled = car.id === controlledId;
          
          // Use visualS for smooth rendering (interpolated position)
          let renderS = car.visualS !== undefined ? car.visualS : car.s;
          
          // Safety check for visualS
          if (!Number.isFinite(renderS)) {
            renderS = car.s;
            if (!Number.isFinite(renderS)) renderS = 0;
          }
          
          // Use pit-aware position for cars in pit lane
          const inPit = car.pit && car.pit.inLane;
          let cx, cy, carHeading;
          if (inPit) {
            const worldPos = Track.getPointPitAware(renderS, true);
            cx = worldPos.x * zoom + panX;
            cy = worldPos.y * zoom + panY;
            carHeading = worldPos.heading;
          } else {
            // Drive on the ideal line + lateral lane offset for overtaking
            const visualLane = car.visualLane !== undefined ? car.visualLane : car.lane;
            let idealPos = null;
            try { idealPos = TrackRenderer.getIdealLinePos(renderS); } catch(e) { /* fallback */ }
            if (idealPos && Number.isFinite(idealPos.x)) {
              // Apply lane offset perpendicular to ideal line heading
              const laneOff = (visualLane !== null && visualLane !== undefined && !isNaN(visualLane)) ? visualLane : 0;
              const perpX = Math.cos(idealPos.heading + Math.PI / 2) * laneOff;
              const perpY = Math.sin(idealPos.heading + Math.PI / 2) * laneOff;
              cx = (idealPos.x + perpX) * zoom + panX;
              cy = (idealPos.y + perpY) * zoom + panY;
              carHeading = idealPos.heading;
            } else {
              const worldPos = Track.getPointCorrected(renderS);
              const laneOff = visualLane || 0;
              const perpX = Math.cos(worldPos.heading + Math.PI / 2) * laneOff;
              const perpY = Math.sin(worldPos.heading + Math.PI / 2) * laneOff;
              cx = (worldPos.x + perpX) * zoom + panX;
              cy = (worldPos.y + perpY) * zoom + panY;
              carHeading = worldPos.heading;
            }
          }
          
          ctx.save();
          ctx.translate(cx, cy);
          ctx.rotate(carHeading);
          
          const L = 5.5 * zoom;    // realistic F1 length (5.5m)
          const Wc = 2.0 * zoom;    // realistic F1 width (2.0m)
          
          // Ground shadow
          ctx.fillStyle = 'rgba(0,0,0,0.22)';
          ctx.beginPath();
          ctx.ellipse(1.5 * zoom, 1.5 * zoom, L * 0.48, Wc * 0.38, 0, 0, Math.PI * 2);
          ctx.fill();

          // 4 Wheels (dark rubber)
          const wheelL = L * 0.12;
          const wheelW = Wc * 0.14;
          ctx.fillStyle = '#1a1a1a';
          // Front wheels
          ctx.fillRect(L * 0.28, -Wc * 0.5, wheelL, wheelW);
          ctx.fillRect(L * 0.28, Wc * 0.36, wheelL, wheelW);
          // Rear wheels
          ctx.fillRect(-L * 0.4, -Wc * 0.52, wheelL * 1.1, wheelW * 1.2);
          ctx.fillRect(-L * 0.4, Wc * 0.35, wheelL * 1.1, wheelW * 1.2);
          
          // Wheel highlights
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(L * 0.30, -Wc * 0.48, wheelL * 0.4, wheelW * 0.6);
          ctx.fillRect(L * 0.30, Wc * 0.38, wheelL * 0.4, wheelW * 0.6);
          
          // Main body (tapered monocoque shape)
          const bodyGrad = ctx.createLinearGradient(-L * 0.5, 0, L * 0.5, 0);
          bodyGrad.addColorStop(0, 'rgba(0,0,0,0.3)');
          bodyGrad.addColorStop(0.15, car.color);
          bodyGrad.addColorStop(0.5, car.color);
          bodyGrad.addColorStop(0.85, car.color);
          bodyGrad.addColorStop(1, 'rgba(255,255,255,0.15)');
          
          ctx.fillStyle = bodyGrad;
          ctx.beginPath();
          // Tapered nose shape
          ctx.moveTo(L * 0.35, 0);
          ctx.lineTo(L * 0.25, -Wc * 0.15);
          ctx.lineTo(-L * 0.1, -Wc * 0.22);
          ctx.lineTo(-L * 0.35, -Wc * 0.28);
          ctx.lineTo(-L * 0.42, -Wc * 0.25);
          ctx.lineTo(-L * 0.42, Wc * 0.25);
          ctx.lineTo(-L * 0.35, Wc * 0.28);
          ctx.lineTo(-L * 0.1, Wc * 0.22);
          ctx.lineTo(L * 0.25, Wc * 0.15);
          ctx.closePath();
          ctx.fill();
          
          // Sidepods
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.beginPath();
          ctx.roundRect(-L * 0.15, -Wc * 0.35, L * 0.25, Wc * 0.13, 2);
          ctx.fill();
          ctx.beginPath();
          ctx.roundRect(-L * 0.15, Wc * 0.22, L * 0.25, Wc * 0.13, 2);
          ctx.fill();

          // Cockpit / Halo area
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.beginPath();
          ctx.ellipse(L * 0.05, 0, L * 0.1, Wc * 0.1, 0, 0, Math.PI * 2);
          ctx.fill();
          // Halo ring
          ctx.strokeStyle = 'rgba(200,200,200,0.4)';
          ctx.lineWidth = 1 * zoom;
          ctx.beginPath();
          ctx.arc(L * 0.05, 0, Wc * 0.1, 0, Math.PI * 2);
          ctx.stroke();
          
          // Front wing (wide, thin)
          ctx.fillStyle = '#0a0a0f';
          ctx.beginPath();
          ctx.roundRect(L * 0.33, -Wc * 0.52, L * 0.1, Wc * 1.04, 3);
          ctx.fill();
          // Front wing endplates (team color)
          ctx.fillStyle = car.color;
          ctx.fillRect(L * 0.34, -Wc * 0.54, L * 0.06, Wc * 0.06);
          ctx.fillRect(L * 0.34, Wc * 0.48, L * 0.06, Wc * 0.06);
          
          // Rear wing
          ctx.fillStyle = '#0a0a0f';
          ctx.beginPath();
          ctx.roundRect(-L * 0.46, -Wc * 0.42, L * 0.06, Wc * 0.84, 2);
          ctx.fill();
          // Rear wing DRS plate (team color)
          ctx.fillStyle = car.color;
          ctx.beginPath();
          ctx.roundRect(-L * 0.48, -Wc * 0.44, L * 0.04, Wc * 0.88, 2);
          ctx.fill();
          
          // Engine cover fin
          ctx.fillStyle = car.color;
          ctx.fillRect(-L * 0.38, -Wc * 0.015, L * 0.3, Wc * 0.03);
          
          // Number on nose (compact, scaled to car)
          ctx.fillStyle = '#fff';
          ctx.font = `900 ${Math.max(3, Wc * 0.38)}px system-ui`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(car.number, L * 0.12, 0);
          
          // Brake light if braking
          if (car.brake > 10 || car.mustWait || car.v < 5) {
            ctx.fillStyle = 'rgba(255, 40, 40, 0.9)';
            ctx.shadowColor = 'rgba(255,0,0,0.6)';
            ctx.shadowBlur = 6 * zoom;
            ctx.beginPath();
            ctx.arc(-L * 0.47, 0, 2.5 * zoom, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          }
          
          // Headlight glow (subtle)
          ctx.fillStyle = 'rgba(255,255,200,0.15)';
          ctx.beginPath();
          ctx.arc(L * 0.38, 0, 1.5 * zoom, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
          
          // Draw Saturn ring slipstream/dirty-air indicator
          const hasDragBenefit = car.slipstream && car.slipstream.kDrag < 0.97;
          const hasDirtyAir = car.slipstream && car.slipstream.kCL < 0.97;
          if (hasDragBenefit || hasDirtyAir) {
            const dragRed = 1 - (car.slipstream.kDrag || 1);   // 0..~0.38
            const dfLoss  = 1 - (car.slipstream.kCL || 1);     // 0..~0.12
            // Intensity based on whichever effect is stronger
            const intensity = Math.min(1, Math.max(dragRed * 3, dfLoss * 6));  // 0..1
            
            // Saturn ring: tilted ellipse around car
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(carHeading);
            
            // Ring color: green = drag benefit (slipstream), orange/red = dirty air only
            let r, g, b;
            if (hasDragBenefit) {
              // Green with orange tint if also dirty air
              r = Math.round(dfLoss > 0.03 ? 255 * Math.min(1, dfLoss * 8) : 0);
              g = Math.round(200 + 55 * intensity);
              b = Math.round(dfLoss > 0.03 ? 50 : 136);
            } else {
              // Pure dirty air (corners): orange/red ring
              r = Math.round(200 + 55 * Math.min(1, dfLoss * 5));
              g = Math.round(120 - 40 * Math.min(1, dfLoss * 5));
              b = 30;
            }
            const alpha = 0.3 + intensity * 0.5;
            
            // Outer glow ring
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.4})`;
            ctx.lineWidth = Math.max(2, 3.5 * zoom);
            ctx.beginPath();
            ctx.ellipse(0, 0, L * (0.45 + intensity * 0.15), Wc * (0.55 + intensity * 0.1), 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner sharp ring
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
            ctx.lineWidth = Math.max(1, 1.8 * zoom);
            ctx.beginPath();
            ctx.ellipse(0, 0, L * (0.42 + intensity * 0.12), Wc * (0.50 + intensity * 0.08), 0, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
          }
          
          // Show lane value as small text above car (debug + visual feedback)
          if (Math.abs(car.visualLane || 0) > 0.1) {
            ctx.save();
            ctx.fillStyle = 'rgba(255,255,0,0.85)';
            ctx.font = `bold ${Math.max(8, 3 * zoom)}px monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText((car.visualLane || 0).toFixed(1), cx, cy - 4 * zoom);
            ctx.restore();
          }
        }
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // UI (Pit rules)
    // ═══════════════════════════════════════════════════════════════════════════════
    const UI = {
      syncPitButtons() {
        const pitBtn = document.getElementById('pitBtn');
        if (!pitBtn) return;

        // Get the controlled car's pit state
        let pitState = Car.pit;
        let carS = Car.s;
        
        if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
          const controlled = MultiCarRace.cars.find(c => c.id === (RaceUI?.controlledCarId || 1));
          if (controlled) {
            pitState = controlled.pit;
            carS = controlled.s;
          }
        }

        const inBox = pitState.inLane && pitState.phase === 'stopped';
        const inPitButNotBox = pitState.inLane && !inBox;

        // Different modes for the pit button:
        // 1. In box: "EXIT PIT" (red, enabled)
        // 2. In pit lane but not box: show phase (disabled)
        // 3. Near pit entry (300m before to 100m after): disabled
        // 4. Normal: "PIT THIS LAP" (enabled, toggles armed state)
        
        if (inBox) {
          // In box - button becomes EXIT
          pitBtn.disabled = false;
          pitBtn.textContent = '🔴 EXIT PIT';
          pitBtn.className = 'btn danger';
          return;
        }
        
        if (inPitButNotBox) {
          // In pit lane but moving - show status, disabled
          pitBtn.disabled = true;
          pitBtn.textContent = `🟡 PIT (${pitState.phase.toUpperCase()})`;
          pitBtn.className = 'btn warn';
          return;
        }
        
        // Check pit zone (300m before to 100m after entry)
        const inPitZone = (function() {
          if (!Track.pit.enabled) return false;
          const sNow = Track.normalize(carS);
          const pit = Track.pit;
          
          // Distance to pit entry (forward)
          const distToPitEntry = Track.forwardDistance(sNow, pit.startS);
          // Distance from pit entry (how far past entry are we)
          const distFromPitEntry = Track.forwardDistance(pit.startS, sNow);
          
          // Disable if within 300m BEFORE pit entry
          if (distToPitEntry <= 300 && distToPitEntry > 0) return true;
          
          // Disable if within 100m AFTER pit entry (but not in pit lane yet)
          if (distFromPitEntry <= 100 && distFromPitEntry > 0) return true;
          
          return false;
        })();

        // Normal racing mode
        pitBtn.disabled = inPitZone;
        pitBtn.className = pitState.armed ? 'btn danger' : 'btn warn';
        pitBtn.textContent = pitState.armed ? '🔴 PIT ARMED (click to cancel)' : '🟡 PIT THIS LAP';
      }
    };

    function formatTime(seconds) {
      if (seconds === null || seconds === undefined) return '--:--.---';
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins.toString().padStart(2, '0')}:${secs.toFixed(3).padStart(6, '0')}`;
    }

    function updateUI() {
      document.getElementById('timer').textContent = formatTime(Simulation.time);

      // Session clock (HH:MM:SS)
      const sessionClockEl = document.getElementById('sessionClock');
      if (sessionClockEl) {
        const t = Simulation.time;
        const hh = Math.floor(t / 3600);
        const mm = Math.floor((t % 3600) / 60);
        const ss = Math.floor(t % 60);
        sessionClockEl.textContent = `🕐 ${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
      }

      // Get controlled car's pit state
      let pitState = Car.pit;
      if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
        const controlled = MultiCarRace.cars.find(c => c.id === (RaceUI?.controlledCarId || 1));
        if (controlled && controlled.pit) pitState = controlled.pit;
      }

      const pitLimitKph = Math.round(Track.pit.speedLimit * 3.6);
      let pitStatus = `Pit: off (limit ${pitLimitKph})`;
      if (pitState.armed) pitStatus = `Pit: ARMED (limit ${pitLimitKph})`;
      if (pitState.inLane) pitStatus = `Pit: ${pitState.phase.toUpperCase()} (limit ${pitLimitKph})`;

      const mode = Simulation.running ? `Racing at ${Simulation.speed}×` : 'Paused';
      document.getElementById('status').textContent = `${mode}\n${pitStatus}`;
      
      // Disable weather controls during race
      const _ws = document.getElementById('weatherSelect');
      const _wt = document.getElementById('weatherTemp');
      if (_ws) _ws.disabled = Simulation.running;
      if (_wt) _wt.disabled = Simulation.running;

      const segInfo = Track.atPosition(Car.s);
      const seg = segInfo ? segInfo.segment : null;

      document.getElementById('infoSpeed').textContent = Math.round(Car.v * 3.6) + ' km/h';
      document.getElementById('infoPos').textContent = Math.round(Track.normalize(Car.s)) + ' m';
      document.getElementById('infoSegment').textContent = seg ? seg.name : '—';

      const segRemain = seg ? Math.max(0, seg.length - segInfo.offset) : 0;
      document.getElementById('infoSegRemain').textContent = Math.round(segRemain) + ' m';

      document.getElementById('infoVLimit').textContent =
        (Car.vLimit == null ? '—' : (Car.vLimit * 3.6).toFixed(0) + ' km/h');

      document.getElementById('infoLap').textContent = Car.lap;
      document.getElementById('infoLapTime').textContent = formatTime(Car.currentLapTime);
      document.getElementById('infoBestLap').textContent = formatTime(Car.bestLapTime);

      document.getElementById('infoMass').textContent = `${Math.round(Car.getTotalMass())} kg`;
      document.getElementById('infoFuel').textContent = `${Car.fuel.toFixed(1)} / ${CarConfig.fuelCapacity.toFixed(0)} kg`;
      document.getElementById('infoTire').textContent = `${Tire.condition.toFixed(1)}%`;
      
      // Parts condition
      const partsEl = document.getElementById('infoParts');
      if (partsEl && typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
        const controlled = MultiCarRace.cars.find(c => c.id === (RaceUI?.controlledCarId || 1));
        if (controlled && controlled.assemblyParts) {
          const overall = AssemblyParts.getOverallCondition(controlled.assemblyParts);
          partsEl.textContent = `${Math.round(overall)}%`;
          partsEl.style.color = overall > 80 ? '#4f4' : overall > 50 ? '#ff4' : '#f44';
        }
      }
      document.getElementById('infoGrip').textContent = `${Car.getEffectiveGrip().toFixed(2)}`;

      document.getElementById('infoThrottle').textContent = Math.round(Car.throttle) + '%';
      document.getElementById('infoBrake').textContent = Math.round(Car.brake) + '%';
      document.getElementById('infoAccel').textContent = `${Car.a.toFixed(2)} m/s²`;

      const pitText = pitState.inLane
        ? `${pitState.phase.toUpperCase()}${pitState.limiter ? ' (LIMIT)' : ''}`
        : (pitState.armed ? 'ARMED' : '—');
      document.getElementById('infoPit').textContent = pitText;
      
      // Fuel per lap display
      const fuelPerLapEl = document.getElementById('infoFuelPerLap');
      if (fuelPerLapEl) {
        fuelPerLapEl.textContent = Car.lastLapFuelUsed !== null 
          ? `${Car.lastLapFuelUsed.toFixed(2)} kg` 
          : '— kg';
      }

      // Weather display
      const weatherEl = document.getElementById('infoWeather');
      if (weatherEl) {
        const icon = Weather.condition === 'sunny' ? '☀' : Weather.condition === 'cloudy' ? '☁' : Weather.condition === 'light_rain' ? '🌦' : '🌧';
        const condName = Weather.condition === 'sunny' ? 'Sunny' : Weather.condition === 'cloudy' ? 'Cloudy' : Weather.condition === 'light_rain' ? 'Light Rain' : 'Heavy Rain';
        weatherEl.textContent = `${icon} ${condName} ${Weather.airTemp.toFixed(0)}°C`;
      }
      // Sync sidebar weather controls (reflects timeline changes)
      if (_ws) _ws.value = Weather.condition;
      if (_wt && document.activeElement !== _wt) _wt.value = Math.round(Weather.airTemp);
      // Track temperature
      const trackTempEl = document.getElementById('infoTrackTemp');
      if (trackTempEl) {
        trackTempEl.textContent = `${Weather.trackTemp.toFixed(0)}°C`;
        trackTempEl.style.color = Weather.trackTemp > 45 ? '#f66' : Weather.trackTemp > 30 ? '#ff4' : '#4af';
      }
      const trackGripEl = document.getElementById('infoTrackGrip');
      if (trackGripEl) {
        const compGrip = Weather.getCompoundGripFactor(Tire.compound);
        const g = compGrip * 100;
        trackGripEl.textContent = `${g.toFixed(0)}%`;
        trackGripEl.style.color = g > 95 ? '#4f4' : g > 80 ? '#ff4' : '#f44';
      }
      // Track rubber level
      const trackRubberEl = document.getElementById('infoTrackRubber');
      if (trackRubberEl) {
        const rPct = (Weather.trackRubberLevel * 100);
        trackRubberEl.textContent = `${rPct.toFixed(0)}%`;
        trackRubberEl.style.color = rPct > 50 ? '#4f4' : rPct > 20 ? '#ff4' : '#aaa';
      }
      // Track wetness
      const trackWetnessEl = document.getElementById('infoTrackWetness');
      if (trackWetnessEl) {
        const wPct = (Weather.wetness * 100);
        trackWetnessEl.textContent = `${wPct.toFixed(0)}%`;
        trackWetnessEl.style.color = wPct > 30 ? '#48f' : wPct > 10 ? '#8af' : '#aaa';
      }
      
      // Physics breakdown (transparency)
      updateUI._updatePhysicsBreakdown();
      

      
      // Lap times list
      const lapTimesList = document.getElementById('lapTimesList');
      if (lapTimesList && Telemetry.laps.length > 0) {
        let html = '';
        for (let i = 0; i < Telemetry.laps.length; i++) {
          const lap = Telemetry.laps[i];
          if (!lap || lap.lapTime == null) continue;
          const isBest = Car.bestLapTime && Math.abs(lap.lapTime - Car.bestLapTime) < 0.001;
          const color = isBest ? '#a855f7' : '#ccc';
          html += `<div style="color:${color}; padding:1px 4px;">L${i} ${formatTime(lap.lapTime)}</div>`;
        }
        lapTimesList.innerHTML = html;
        // Auto-scroll to bottom
        lapTimesList.scrollTop = lapTimesList.scrollHeight;
      }

      document.getElementById('lapNum').textContent = Car.lap;
      document.getElementById('totalLaps').textContent = Track.totalLaps;
      
      // Update pit button state continuously
      UI.syncPitButtons();
    }

    // Physics breakdown helper (updates sidebar multiplier values)
    updateUI._updatePhysicsBreakdown = function() {
      const fmtMult = (v) => {
        const pct = (v * 100).toFixed(1);
        const col = v >= 0.99 ? '#4f4' : v >= 0.95 ? '#ff4' : '#f44';
        return `<span style="color:${col}">${pct}%</span>`;
      };
      const fmtWear = (v) => {
        const col = v <= 1.01 ? '#4f4' : v <= 1.10 ? '#ff4' : '#f44';
        return `<span style="color:${col}">×${v.toFixed(2)}</span>`;
      };

      const setEl = (id, html) => { const e = document.getElementById(id); if (e) e.innerHTML = html; };
      
      // TireModel factors for current compound
      const cf = Weather.getCompoundFactors(Tire.compound);

      // Driving mode µ
      const modeGrip = TireModel.getDrivingModeGrip(DrivingMode.current);
      setEl('phModeGrip', fmtMult(modeGrip));
      // Tire compound base grip
      setEl('phTireGrip', fmtMult(Tire.getCompound().baseGrip));
      // Tire condition multiplier
      setEl('phTireCond', fmtMult(Tire.getGripMultiplier() / Tire.getCompound().baseGrip));
      // TireModel: F_rubber, F_wet, F_temp
      setEl('phRubber', fmtMult(cf.F_rubber));
      setEl('phTireWeather', fmtMult(cf.F_wet));
      setEl('phTrackTemp', fmtMult(cf.F_temp));
      // Camber
      const camber = typeof CarConfig !== 'undefined' ? CarConfig.camber : -4;
      const camberF = CamberModel.getFactors(camber);
      setEl('phCamber', `<span style="color:#aaf">${(camberF.kLat*100).toFixed(1)}%/${(camberF.kLong*100).toFixed(1)}%</span>`);

      // Parts multipliers
      let parts = null;
      if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
        const ctrl = MultiCarRace.cars.find(c => c.id === (typeof RaceUI !== 'undefined' ? RaceUI.controlledCarId : 1));
        if (ctrl) parts = ctrl.assemblyParts;
      }
      setEl('phPartsPower', fmtMult(AssemblyParts.getMultiplier(parts, 'power')));
      setEl('phPartsGrip', fmtMult(AssemblyParts.getMultiplier(parts, 'grip')));
      setEl('phPartsAero', fmtMult(AssemblyParts.getMultiplier(parts, 'aero')));
      // Air density
      setEl('phAirDensity', `<span style="color:#aaf">${Weather.airDensity.toFixed(3)} kg/m³</span>`);
      // Wear multipliers
      setEl('phWearMult', fmtWear(cf.wearMult));
      const modeWear = TireModel.getDrivingModeWear(DrivingMode.current);
      setEl('phModeWear', fmtWear(modeWear));

      // Platform suspension factors at current speed
      if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
        const ctrl = MultiCarRace.cars.find(c => c.id === (typeof RaceUI !== 'undefined' ? RaceUI.controlledCarId : 1));
        if (ctrl && ctrl.getPlatformFactors) {
          const pf = ctrl.getPlatformFactors(ctrl.v);
          setEl('phPlatDrag', `<span style="color:${pf.kDrag > 1.05 ? '#f88' : pf.kDrag < 0.95 ? '#8f8' : '#aaf'}">${pf.kDrag.toFixed(3)}</span>`);
          setEl('phPlatAero', `<span style="color:${pf.kAero > 1.2 ? '#8f8' : pf.kAero < 0.8 ? '#f88' : '#aaf'}">${pf.kAero.toFixed(3)}</span>`);
          setEl('phPlatGrip', `<span style="color:${pf.kMech < 0.95 ? '#f88' : '#aaf'}">${pf.kMech.toFixed(3)}</span>`);
          setEl('phRideH', `<span style="color:#aaf">${(ctrl.setup.rideHeight * 1000).toFixed(1)}mm</span>`);
        }
      } else {
        const pf = Platform.getFactorsAtSpeed(Car.v);
        setEl('phPlatDrag', `<span style="color:${pf.kDrag > 1.05 ? '#f88' : pf.kDrag < 0.95 ? '#8f8' : '#aaf'}">${pf.kDrag.toFixed(3)}</span>`);
        setEl('phPlatAero', `<span style="color:${pf.kAero > 1.2 ? '#8f8' : pf.kAero < 0.8 ? '#f88' : '#aaf'}">${pf.kAero.toFixed(3)}</span>`);
        setEl('phPlatGrip', `<span style="color:${pf.kMech < 0.95 ? '#f88' : '#aaf'}">${pf.kMech.toFixed(3)}</span>`);
        setEl('phRideH', `<span style="color:#aaf">${(CarConfig.rideHeight * 1000).toFixed(1)}mm</span>`);
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // TELEMETRY UI (Zoom/Pan) + vLimit line
    // ═══════════════════════════════════════════════════════════════════════════════
    const TelemetryUI = {
      modal: null,
      canvas: null,
      ctx: null,
      selA: null,
      selB: null,
      liveFrozen: false,
      _deltaYAxisInfo: null,

      view: { zoomX: 1, panXPx: 0 },
      drag: { active: false, startX: 0, startPan: 0 },

      init() {
        if (this._initialized) return;
        this._initialized = true;
        this.modal = document.getElementById('telemetryModal');
        this.canvas = document.getElementById('telemetryCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.selA = document.getElementById('lapSelectA');
        this.selB = document.getElementById('lapSelectB');

        document.getElementById('telemetryBtn').addEventListener('click', () => this.open());
        document.getElementById('telemetryClose').addEventListener('click', () => this.close());
        this.modal.addEventListener('click', (e) => { if (e.target === this.modal) this.close(); });

        this.selA.addEventListener('change', () => this.draw());
        this.selB.addEventListener('change', () => this.draw());

        document.getElementById('telemetryFreeze').addEventListener('click', () => { this.liveFrozen = true; this.draw(); });
        document.getElementById('telemetryUnfreeze').addEventListener('click', () => { this.liveFrozen = false; this.draw(); });

        document.getElementById('telemetryResetView').addEventListener('click', () => {
          this.view.zoomX = 1;
          this.view.panXPx = 0;
          this.draw();
        });

        this.canvas.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
        this.canvas.addEventListener('mousedown', (e) => this.onDown(e));
        window.addEventListener('mousemove', (e) => this.onMove(e));
        window.addEventListener('mouseup', () => this.onUp());
        this.canvas.addEventListener('mouseleave', () => this.onUp());
        this.canvas.addEventListener('dblclick', () => {
          this.view.zoomX = 1;
          this.view.panXPx = 0;
          this.draw();
        });
      },

      open() {
        this.refreshLapOptions();
        this.modal.classList.add('open');
        this.modal.setAttribute('aria-hidden', 'false');
        this.draw();
      },

      close() {
        this.modal.classList.remove('open');
        this.modal.setAttribute('aria-hidden', 'true');
      },

      isOpen() { return this.modal.classList.contains('open'); },

      refreshLapOptions() {
        const n = Telemetry.laps.length;
        const mkOpt = (value, label) => `<option value="${value}">${label}</option>`;
        
        // Format lap time for display
        const formatLapTime = (lapTime) => {
          if (lapTime === null || lapTime === undefined) return '';
          const mins = Math.floor(lapTime / 60);
          const secs = lapTime % 60;
          return ` (${mins}:${secs.toFixed(3).padStart(6, '0')})`;
        };
        
        const opts = [mkOpt('live', 'Live (current lap)')]
          .concat(n ? Array.from({ length: n }, (_, i) => {
            const lap = Telemetry.laps[i];
            const timeStr = lap && lap.lapTime ? formatLapTime(lap.lapTime) : '';
            return mkOpt(String(i), `Lap ${i}${timeStr}`);
          }) : [mkOpt('', '—')])
          .join('');
        this.selA.innerHTML = opts;
        this.selB.innerHTML = opts;
        this.selA.value = 'live';
        this.selB.value = n >= 1 ? String(n - 1) : 'live';
      },

      getLapPoints(selection) {
        if (selection === 'live') return Telemetry.ensureLap(Car.lap).points;
        const idx = parseInt(selection, 10);
        if (Number.isNaN(idx) || !Telemetry.laps[idx]) return null;
        return Telemetry.laps[idx].points;
      },

      clampView(plotW) {
        this.view.zoomX = Math.max(1, Math.min(25, this.view.zoomX));
        const maxPan = Math.max(0, (this.view.zoomX - 1) * plotW);
        this.view.panXPx = Math.max(-maxPan, Math.min(0, this.view.panXPx));
      },

      onWheel(e) {
        if (!this.isOpen()) return;
        e.preventDefault();

        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;

        const padL = 70, padR = 20;
        const plotW = this.canvas.width - padL - padR;

        const xInPlot = mx - padL;
        if (xInPlot < 0 || xInPlot > plotW) return;

        const oldZoom = this.view.zoomX;
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = oldZoom * factor;

        const world = (xInPlot - this.view.panXPx) / oldZoom;

        this.view.zoomX = newZoom;
        this.view.panXPx = xInPlot - world * this.view.zoomX;

        this.clampView(plotW);
        this.draw();
      },

      onDown(e) {
        if (!this.isOpen()) return;

        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;

        const padL = 70, padR = 20;
        const plotW = this.canvas.width - padL - padR;

        const xInPlot = mx - padL;
        if (xInPlot < 0 || xInPlot > plotW) return;

        this.drag.active = true;
        this.drag.startX = e.clientX;
        this.drag.startPan = this.view.panXPx;
        this.canvas.classList.add('dragging');
      },

      onMove(e) {
        if (!this.drag.active || !this.isOpen()) return;

        const padL = 70, padR = 20;
        const plotW = this.canvas.width - padL - padR;

        const dx = e.clientX - this.drag.startX;
        this.view.panXPx = this.drag.startPan + dx;

        this.clampView(plotW);
        this.draw();
      },

      onUp() {
        if (!this.drag.active) return;
        this.drag.active = false;
        this.canvas.classList.remove('dragging');
      },

      draw() {
        const ctx = this.ctx;
        const W = this.canvas.width;
        const H = this.canvas.height;

        ctx.clearRect(0, 0, W, H);

        ctx.fillStyle = 'rgba(255,255,255,0.03)';
        for (let x = 0; x < W; x += 50) ctx.fillRect(x, 0, 1, H);
        for (let y = 0; y < H; y += 50) ctx.fillRect(0, y, W, 1);

        const selA = this.selA.value;
        const selB = this.selB.value;
        const ptsA = this.getLapPoints(selA);
        const ptsB = this.getLapPoints(selB);

        const liveActive = (!this.liveFrozen) && (selA === 'live' || selB === 'live');
        document.getElementById('liveBadge').textContent = `LIVE: ${liveActive ? 'on' : 'off'}`;

        if (!ptsA || ptsA.length < 2) {
          ctx.fillStyle = 'rgba(255,255,255,0.75)';
          ctx.font = '16px system-ui';
          ctx.fillText('Noch keine Telemetrie – fahre mindestens 1 Runde.', 18, 30);
          return;
        }

        const maxV = Math.max(
          ...ptsA.map(p => p.v ?? 0),
          ...(ptsB ? ptsB.map(p => p.v ?? 0) : [0]),
          50
        );

        const padL = 70, padR = 20, padT = 40, padB = 50;
        const plotW = W - padL - padR;
        const plotH = H - padT - padB;

        this.clampView(plotW);

        const hSpeed = plotH * 0.35;
        const hDelta = plotH * 0.30;
        const hCtl = plotH * 0.35;

        const ySpeed0 = padT;
        const yDelta0 = padT + hSpeed;
        const yCtl0 = padT + hSpeed + hDelta;

        const baseX = (d) => (d / Track.lapLength) * plotW;
        const xOfD = (d) => padL + (baseX(d) * this.view.zoomX) + this.view.panXPx;

        const yOfSpeed = (v) => ySpeed0 + hSpeed - (v / maxV) * hSpeed;
        const yOfPct = (pct) => yCtl0 + hCtl - (pct / 100) * hCtl;

        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.font = '12px system-ui';
        ctx.fillText(`Speed (km/h)`, 12, ySpeed0 + 14);
        ctx.fillText(`Time Delta (s)`, 12, yDelta0 + 14);
        ctx.fillText(`THR/BRK (%)`, 12, yCtl0 + 14);

        ctx.fillStyle = 'rgba(255,255,255,0.55)';
        ctx.font = '11px system-ui';
        for (let i = 0; i <= 4; i++) {
          const v = (maxV * i) / 4;
          const y = yOfSpeed(v);
          ctx.fillRect(padL - 6, y, 6, 1);
          ctx.fillText(`${Math.round(v)}`, 18, y + 4);
        }

        for (let i = 0; i <= 4; i++) {
          const pct = i * 25;
          const y = yOfPct(pct);
          ctx.fillRect(padL - 6, y, 6, 1);
          ctx.fillText(`${pct}`, 26, y + 4);
        }

        // Static placeholder for delta Y-axis (actual values drawn after clip restore)
        ctx.fillStyle = 'rgba(255,0,255,0.4)';
        ctx.font = '10px system-ui';
        ctx.fillText(`(select 2 laps)`, 12, yDelta0 + hDelta/2 + 4);

        // Separator lines between panels
        ctx.strokeStyle = 'rgba(255,255,255,0.10)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padL, yDelta0);
        ctx.lineTo(padL + plotW, yDelta0);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(padL, yCtl0);
        ctx.lineTo(padL + plotW, yCtl0);
        ctx.stroke();

        ctx.fillStyle = 'rgba(255,255,255,0.55)';
        ctx.font = '11px system-ui';
        const tickCount = 4;
        for (let i = 0; i <= tickCount; i++) {
          const d = (Track.lapLength * i) / tickCount;
          const x = xOfD(d);
          if (x < padL - 2 || x > padL + plotW + 2) continue;
          ctx.fillRect(x, padT, 1, plotH);
          ctx.fillText(`${Math.round(d)} m`, x - 18, H - 18);
        }
        ctx.fillStyle = 'rgba(255,255,255,0.75)';
        ctx.font = '12px system-ui';
        ctx.fillText(`Distanz (m) • ZoomX ${this.view.zoomX.toFixed(2)}×`, padL + 8, H - 8);

        ctx.save();
        ctx.beginPath();
        ctx.rect(padL, padT, plotW, plotH);
        ctx.clip();

        // Helper: detect distance wrap (new lap boundary)
        const isDistGap = (d0, d1) => Math.abs(d1 - d0) > Track.lapLength * 0.4;

        const plotSpeed = (pts, style) => {
          ctx.setLineDash(style.dash);

          ctx.strokeStyle = style.speed;
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            const x = xOfD(p.d);
            const y = yOfSpeed(p.v);
            if (i === 0 || isDistGap(pts[i-1].d, p.d)) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          }
          ctx.stroke();

          ctx.setLineDash([]);
        };

        const plotControls = (pts, style) => {
          ctx.setLineDash(style.dash);

          ctx.strokeStyle = style.thr;
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            const x = xOfD(p.d);
            const y = yOfPct(p.thr);
            if (i === 0 || isDistGap(pts[i-1].d, p.d)) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          }
          ctx.stroke();

          ctx.strokeStyle = style.brk;
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            const x = xOfD(p.d);
            const y = yOfPct(p.brk);
            if (i === 0 || isDistGap(pts[i-1].d, p.d)) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          }
          ctx.stroke();

          ctx.setLineDash([]);
        };

        // Calculate time delta between A and B at each distance
        const calcTimeDelta = (ptsA, ptsB) => {
          if (!ptsA || !ptsB || ptsA.length < 2 || ptsB.length < 2) return [];
          const deltas = [];
          
          // Build a map from distance -> time for lap B
          const bTimeByD = new Map();
          for (const p of ptsB) {
            if (p.t !== undefined) bTimeByD.set(Math.round(p.d), p.t);
          }
          
          // For each point in A, find corresponding B time and compute delta
          for (const p of ptsA) {
            if (p.t === undefined) continue;
            const dRound = Math.round(p.d);
            const bTime = bTimeByD.get(dRound);
            if (bTime !== undefined) {
              deltas.push({ d: p.d, delta: p.t - bTime }); // positive = A slower than B
            }
          }
          return deltas;
        };

        // Plot time delta (A vs B) in dedicated panel
        const plotTimeDelta = (deltas) => {
          if (!deltas || deltas.length < 2) return;
          
          // Find actual min and max delta values
          const minDelta = Math.min(...deltas.map(d => d.delta));
          const maxDelta = Math.max(...deltas.map(d => d.delta));
          
          // Add small padding and ensure some range
          const range = Math.max(maxDelta - minDelta, 0.1);
          const padding = range * 0.1;
          const displayMin = minDelta - padding;
          const displayMax = maxDelta + padding;
          const displayRange = displayMax - displayMin;
          
          // Y mapping: displayMax at top, displayMin at bottom
          const yOfDelta = (delta) => yDelta0 + 5 + (1 - (delta - displayMin) / displayRange) * (hDelta - 10);
          const yZero = yOfDelta(0);
          
          // Draw zero line if visible
          if (displayMin < 0 && displayMax > 0) {
            ctx.strokeStyle = 'rgba(255,0,255,0.30)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4,4]);
            ctx.beginPath();
            ctx.moveTo(padL, yZero);
            ctx.lineTo(padL + plotW, yZero);
            ctx.stroke();
            ctx.setLineDash([]);
          }
          
          // Y-axis ticks stored for drawing outside clip
          this._deltaYAxisInfo = { displayMin, displayMax, displayRange, yOfDelta, yZero };
          
          // Draw delta curve
          ctx.strokeStyle = 'rgba(255,0,255,0.90)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let i = 0; i < deltas.length; i++) {
            const d = deltas[i];
            const x = xOfD(d.d);
            const y = yOfDelta(d.delta);
            if (i === 0 || isDistGap(deltas[i-1].d, d.d)) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          }
          ctx.stroke();

          // Draw current absolute delta value label at end of curve
          if (deltas.length > 0) {
            const last = deltas[deltas.length - 1];
            const lastX = xOfD(last.d);
            const lastY = yOfDelta(last.delta);
            const sign = last.delta >= 0 ? '+' : '';
            const col = last.delta < 0 ? '#00ff88' : '#ff5050';
            ctx.fillStyle = col;
            ctx.font = 'bold 13px Consolas, monospace';
            ctx.fillText(`${sign}${last.delta.toFixed(3)}s`, lastX + 6, lastY + 4);
          }
          
          // Fill area (green when ahead/negative, red when behind/positive)
          for (let i = 1; i < deltas.length; i++) {
            const d0 = deltas[i-1];
            const d1 = deltas[i];
            const x0 = xOfD(d0.d);
            const x1 = xOfD(d1.d);
            const y0 = yOfDelta(d0.delta);
            const y1 = yOfDelta(d1.delta);
            const yZ = (displayMin < 0 && displayMax > 0) ? yZero : (d0.delta < 0 ? yDelta0 + hDelta : yDelta0);
            
            // Fill triangle from zero line
            ctx.fillStyle = d0.delta < 0 ? 'rgba(0,255,136,0.15)' : 'rgba(255,80,80,0.15)';
            ctx.beginPath();
            ctx.moveTo(x0, yZ);
            ctx.lineTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.lineTo(x1, yZ);
            ctx.closePath();
            ctx.fill();
          }
        };

        // Plot fuel consumption
        const plotFuelCons = (pts, style) => {
          if (!pts || pts.length < 2) return;
          const maxFuel = Math.max(...pts.map(p => p.fuelCons ?? 0), 10);
          
          ctx.setLineDash(style.dash);
          ctx.strokeStyle = style.fuel;
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            if (p.fuelCons === undefined) continue;
            const x = xOfD(p.d);
            const y = yCtl0 + hCtl - (p.fuelCons / maxFuel) * (hCtl * 0.3);
            if (i === 0 || isDistGap(pts[i-1].d, pts[i].d)) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          }
          ctx.stroke();
          ctx.setLineDash([]);
        };

        plotSpeed(ptsA, { dash: [], speed: 'rgba(0,212,255,0.95)' });
        plotControls(ptsA, { dash: [], thr: 'rgba(0,255,136,0.90)', brk: 'rgba(255,80,80,0.90)' });
        plotFuelCons(ptsA, { dash: [], fuel: 'rgba(255,165,0,0.75)' });

        if (ptsB && ptsB.length > 1) {
          plotSpeed(ptsB, { dash: [8,6], speed: 'rgba(255,215,0,0.90)' });
          plotControls(ptsB, { dash: [8,6], thr: 'rgba(0,255,136,0.55)', brk: 'rgba(255,80,80,0.55)' });
          plotFuelCons(ptsB, { dash: [8,6], fuel: 'rgba(255,165,0,0.45)' });
          
          // Plot time delta between A and B
          const deltas = calcTimeDelta(ptsA, ptsB);
          plotTimeDelta(deltas);
        }

        ctx.restore();

        // ── Draw time delta Y-axis labels (outside clip so they're visible) ──
        if (this._deltaYAxisInfo) {
          const di = this._deltaYAxisInfo;
          ctx.fillStyle = 'rgba(255,0,255,0.7)';
          ctx.font = '10px Consolas, monospace';
          for (let i = 0; i <= 4; i++) {
            const deltaVal = di.displayMin + (di.displayRange * i) / 4;
            const y = di.yOfDelta(deltaVal);
            ctx.fillRect(padL - 6, y, 6, 1);
            const sign = deltaVal >= 0 ? '+' : '';
            ctx.fillText(`${sign}${deltaVal.toFixed(2)}`, 4, y + 4);
          }
          if (di.displayMin < 0 && di.displayMax > 0) {
            ctx.fillStyle = 'rgba(255,0,255,0.9)';
            ctx.font = '10px Consolas, monospace';
            ctx.fillText(`0.00`, 4, di.yZero + 4);
          }
          this._deltaYAxisInfo = null;
        }

        ctx.fillStyle = 'rgba(255,255,255,0.90)';
        ctx.font = '13px system-ui';
        const nameA = selA === 'live' ? 'Live' : `Lap ${selA}`;
        const nameB = selB === 'live' ? 'Live' : `Lap ${selB}`;
        
        // Add lap times to legend
        const fmtLT = (sel) => {
          if (sel === 'live') return '';
          const idx = parseInt(sel, 10);
          const lap = (!Number.isNaN(idx) && Telemetry.laps[idx]) ? Telemetry.laps[idx] : null;
          if (!lap || lap.lapTime == null) return '';
          const mins = Math.floor(lap.lapTime / 60);
          const secs = lap.lapTime % 60;
          return ` [${mins}:${secs.toFixed(3).padStart(6, '0')}]`;
        };
        ctx.fillText(`A = ${nameA}${fmtLT(selA)}  |  B = ${nameB}${fmtLT(selB)}`, padL, 22);
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // DATA UI
    // ═══════════════════════════════════════════════════════════════════════════════
    const DataUI = {
      modal: null,
      out: null,
      sel: null,

      init() {
        if (this._initialized) return;
        this._initialized = true;
        this.modal = document.getElementById('dataModal');
        this.out = document.getElementById('dataOut');
        this.sel = document.getElementById('dataLapSelect');

        document.getElementById('dataBtn').addEventListener('click', () => this.open());
        document.getElementById('dataClose').addEventListener('click', () => this.close());
        this.modal.addEventListener('click', (e) => { if (e.target === this.modal) this.close(); });

        this.sel.addEventListener('change', () => this.render());
        document.getElementById('dataRefresh').addEventListener('click', () => this.render());

        document.getElementById('dataCopy').addEventListener('click', async () => {
          try { await navigator.clipboard.writeText(this.out.textContent || ''); }
          catch (e) { console.warn('Clipboard failed', e); }
        });

        document.getElementById('dataDownloadCsv').addEventListener('click', () => {
          const csv = this.buildCSV();
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `telemetry_lap_${this.sel.value}.csv`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        });
      },

      open() {
        this.refreshLapOptions();
        this.modal.classList.add('open');
        this.modal.setAttribute('aria-hidden', 'false');
        this.render();
      },

      close() {
        this.modal.classList.remove('open');
        this.modal.setAttribute('aria-hidden', 'true');
      },

      refreshLapOptions() {
        const n = Telemetry.laps.length;
        const mkOpt = (value, label) => `<option value="${value}">${label}</option>`;
        
        // Format lap time for display
        const formatLapTime = (lapTime) => {
          if (lapTime === null || lapTime === undefined) return '';
          const mins = Math.floor(lapTime / 60);
          const secs = lapTime % 60;
          return ` (${mins}:${secs.toFixed(3).padStart(6, '0')})`;
        };
        
        const opts = n
          ? Array.from({ length: n }, (_, i) => {
              const lap = Telemetry.laps[i];
              const timeStr = lap && lap.lapTime ? formatLapTime(lap.lapTime) : '';
              return mkOpt(String(i), `Lap ${i}${timeStr}`);
            }).join('')
          : mkOpt('0', 'Lap 0');
        this.sel.innerHTML = opts;
        this.sel.value = String(Math.max(0, n - 1));
      },

      getPoints() {
        const idx = parseInt(this.sel.value, 10);
        if (Number.isNaN(idx) || !Telemetry.laps[idx]) return [];
        return Telemetry.laps[idx].points || [];
      },

      render() {
        const pts = this.getPoints();
        if (!pts.length) {
          this.out.textContent = 'Keine Daten. Erst eine Runde fahren.';
          return;
        }

        const pad = (s, n) => s.length >= n ? s.slice(0, n) : s + ' '.repeat(n - s.length);

        // Show lap time at the top if available
        const idx = parseInt(this.sel.value, 10);
        const lap = (!Number.isNaN(idx) && Telemetry.laps[idx]) ? Telemetry.laps[idx] : null;
        let lapTimeHeader = '';
        if (lap && lap.lapTime != null) {
          const mins = Math.floor(lap.lapTime / 60);
          const secs = lap.lapTime % 60;
          lapTimeHeader = `Lap ${idx}  |  Lap Time: ${mins}:${secs.toFixed(3).padStart(6, '0')}\n\n`;
        }

        const header =
          pad('d[m]', 7) + ' ' +
          pad('v[km/h]', 10) + ' ' +
          pad('vLim[km/h]', 11) + ' ' +
          pad('a[m/s²]', 9) + ' ' +
          pad('thr[%]', 7) + ' ' +
          pad('brk[%]', 7) + '\n' +
          '-'.repeat(62) + '\n';

        const lines = pts.map(p => {
          const d = String(Math.round(p.d));
          const v = (p.v ?? 0).toFixed(1);
          const vLim = (p.vLim == null ? '—' : (p.vLim).toFixed(1));
          const a = (p.a ?? 0).toFixed(2);
          const thr = String(Math.round(p.thr ?? 0));
          const brk = String(Math.round(p.brk ?? 0));

          return (
            pad(d, 7) + ' ' +
            pad(v, 10) + ' ' +
            pad(vLim, 11) + ' ' +
            pad(a, 9) + ' ' +
            pad(thr, 7) + ' ' +
            pad(brk, 7)
          );
        }).join('\n');

        this.out.textContent = lapTimeHeader + header + lines;
      },

      buildCSV() {
        const pts = this.getPoints();
        const rows = ['d_m,v_kmh,vLimit_kmh,a_ms2,thr_pct,brk_pct'];
        for (const p of pts) {
          const d = Math.round(p.d);
          const v = (p.v ?? 0).toFixed(3);
          const vLim = (p.vLim == null ? '' : (p.vLim).toFixed(3));
          const a = (p.a ?? 0).toFixed(4);
          const thr = (p.thr ?? 0).toFixed(2);
          const brk = (p.brk ?? 0).toFixed(2);
          rows.push(`${d},${v},${vLim},${a},${thr},${brk}`);
        }
        return rows.join('\n');
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // SETUP UI (Deferred changes - apply only in box)
    // ═══════════════════════════════════════════════════════════════════════════════
    const SetupUI = {
      modal: null,
      grid: null,
      fields: null,
      pendingChanges: null, // Stores pending setup changes
      lastAppliedInfo: null, // Info about last applied changes

      schema: [
        // Simplified in-race setup — essentials only
        { key: 'fuelCapacity', label: 'Fuel Load',          unit: 'kg',     step: 1,    min: 0,   max: 110 },
        { key: 'camber',       label: 'Camber',             unit: '°',      step: 0.1,  min: -4.0, max: 0 },
        { key: 'wingAngle',    label: 'Wing Angle',         unit: '°',      step: 0.1,  min: 0,    max: 25 },
        { key: 'rideHeight',   label: 'Ride Height',        unit: 'mm',     step: 1,    min: 20,   max: 50,
            transform: v => v * 1000, inverse: v => v / 1000 },
        { key: 'springK',      label: 'Spring Rate',        unit: 'N/mm',   step: 5,    min: 40,   max: 500,
            transform: v => v / 1000, inverse: v => v * 1000 },
        { key: 'damperC',      label: 'Damper',             unit: 'Ns/mm',  step: 0.1,  min: 0.1,  max: 20,
            transform: v => v / 1000, inverse: v => v * 1000 },
      ],

      init() {
        if (this._initialized) return;
        this._initialized = true;
        this.modal = document.getElementById('setupModal');
        this.grid = document.getElementById('setupGrid');

        document.getElementById('setupBtn').addEventListener('click', () => this.open());
        document.getElementById('setupClose').addEventListener('click', () => this.close());
        this.modal.addEventListener('click', (e) => { if (e.target === this.modal) this.close(); });

        document.getElementById('setupResetDefaults').addEventListener('click', () => this.fillFromDefaults());
        document.getElementById('setupApply').addEventListener('click', () => this.queueChanges());
        document.getElementById('setupSave').addEventListener('click', () => this.saveSetup());
        document.getElementById('setupLoad').addEventListener('click', () => this.loadSetup());

        this.build();
        this.fillFromConfig();
      },

      // Check if car is in box (stopped in pit)
      isInBox() {
        // Use controlled car's pit state if in MultiCarRace
        if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
          const controlled = MultiCarRace.cars.find(c => c.id === (RaceUI?.controlledCarId || 1));
          if (controlled && controlled.pit) {
            return controlled.pit.inLane && controlled.pit.phase === 'stopped';
          }
        }
        return Car.pit.inLane && Car.pit.phase === 'stopped';
      },

      // Queue or apply changes depending on pit status
      queueChanges() {
        const changes = this.collectChanges();
        
        if (this.isInBox()) {
          // In pit box: apply immediately
          this.applyChanges(changes);
          this.lastAppliedInfo = { time: Simulation.time, lap: Car.lap };
          this.pendingChanges = null;
          this.updateStatusDisplay();
          this.close();
        } else {
          // On track: queue changes for next pit stop
          this.pendingChanges = changes;
          this.updateStatusDisplay();
          this.close();
        }
      },

      // ── SETUP SAVE/LOAD (localStorage) ──
      saveSetup() {
        const name = prompt('Setup Name:', `Setup_${new Date().toISOString().slice(0,10)}`);
        if (!name) return;
        
        const data = {};
        for (const s of this.schema) {
          const inp = this.fields.get(s.key);
          if (inp) data[s.key] = parseFloat(inp.value);
        }
        const tireSelect = this.fields.get('tireCompound');
        if (tireSelect) data.tireCompound = tireSelect.value;
        
        // Get existing saved setups
        let saved = {};
        try { saved = JSON.parse(localStorage.getItem('raceSetups') || '{}'); } catch(e) {}
        saved[name] = data;
        localStorage.setItem('raceSetups', JSON.stringify(saved));
        
        const banner = document.getElementById('setupStatusBanner');
        if (banner) {
          banner.textContent = `✅ Setup "${name}" saved`;
          banner.style.background = '#226622';
          banner.style.display = 'block';
          setTimeout(() => { banner.style.display = 'none'; }, 2000);
        }
      },
      
      loadSetup() {
        let saved = {};
        try { saved = JSON.parse(localStorage.getItem('raceSetups') || '{}'); } catch(e) {}
        const names = Object.keys(saved);
        if (names.length === 0) {
          alert('No saved setups found.');
          return;
        }
        
        const choice = prompt(`Load Setup:\n${names.map((n,i) => `${i+1}. ${n}`).join('\n')}\n\nEnter number or name:`);
        if (!choice) return;
        
        let setupName;
        const idx = parseInt(choice) - 1;
        if (idx >= 0 && idx < names.length) {
          setupName = names[idx];
        } else {
          setupName = names.find(n => n.toLowerCase() === choice.toLowerCase());
        }
        
        if (!setupName || !saved[setupName]) {
          alert('Setup not found.');
          return;
        }
        
        const data = saved[setupName];
        
        // Fill fields
        for (const s of this.schema) {
          const inp = this.fields.get(s.key);
          if (!inp || data[s.key] === undefined) continue;
          inp.value = data[s.key];
        }
        const tireSelect = this.fields.get('tireCompound');
        if (tireSelect && data.tireCompound) {
          tireSelect.value = data.tireCompound;
        }
        
        const banner = document.getElementById('setupStatusBanner');
        if (banner) {
          banner.textContent = `📂 Setup "${setupName}" loaded — press Apply to use`;
          banner.style.background = '#224466';
          banner.style.display = 'block';
          setTimeout(() => { banner.style.display = 'none'; }, 3000);
        }
      },

      // Collect current field values as changes
      collectChanges() {
        const changes = {};
        
        // Collect tire compound change
        const tireSelect = this.fields.get('tireCompound');
        if (tireSelect) {
          changes.tireCompound = tireSelect.value;
        }
        
        for (const s of this.schema) {
          const inp = this.fields.get(s.key);
          if (!inp) continue;
          let val = parseFloat(inp.value);
          if (!Number.isFinite(val)) continue;
          // Apply inverse transform (e.g., mm -> m, kN/m -> N/m)
          if (s.inverse) val = s.inverse(val);
          changes[s.key] = val;
        }
        return changes;
      },

      // Calculate deltas between current config and pending changes
      getDeltas() {
        if (!this.pendingChanges) return [];
        const deltas = [];
        
        // Check tire compound delta
        if (this.pendingChanges.tireCompound && this.pendingChanges.tireCompound !== Tire.compound) {
          deltas.push({
            key: 'tireCompound',
            label: 'Tire Compound',
            unit: '',
            current: Tire.compound.toUpperCase(),
            pending: this.pendingChanges.tireCompound.toUpperCase(),
            delta: 0,
            isString: true
          });
        }
        
        for (const s of this.schema) {
          const pending = this.pendingChanges[s.key];
          if (pending === undefined) continue;
          
          let current;
          if (s.custom && s.key === 'pitSpeed') current = Track.pit.speedLimit * 3.6;
          else if (s.custom && s.key === 'pitOffset') current = Track.pit.offset;
          else current = CarConfig[s.key];
          
          const delta = pending - current;
          if (Math.abs(delta) > 0.0001) {
            deltas.push({
              key: s.key,
              label: s.label,
              unit: s.unit,
              current,
              pending,
              delta
            });
          }
        }
        return deltas;
      },

      // Apply pending changes (called from simulation when in box)
      tryApplyPending() {
        if (!this.pendingChanges || !this.isInBox()) return false;
        
        // ── MULTIPLAYER: Send setup changes to server instead of applying locally ──
        if (Multiplayer.isMultiplayerRace && !Multiplayer.isHost) {
          const changes = this.pendingChanges;
          Multiplayer.sendCommand('cmd_setup_change', {
            setup: changes,
            compound: changes.tireCompound || null,
            fuel: changes.fuelCapacity || null
          });
          this.pendingChanges = null;
          this.updateStatusDisplay();
          return true;
        }
        
        this.applyChanges(this.pendingChanges);
        this.lastAppliedInfo = { time: Simulation.time, lap: Car.lap };
        this.pendingChanges = null;
        this.updateStatusDisplay();
        return true;
      },

      // Actually apply changes to config
      applyChanges(changes) {
        // Apply tire compound change
        if (changes.tireCompound && changes.tireCompound !== Tire.compound) {
          Tire.changeTires(changes.tireCompound);
          
          // Also update the controlled car's tire compound
          if (typeof RaceUI !== 'undefined' && typeof MultiCarRace !== 'undefined') {
            const controlled = MultiCarRace.cars.find(c => c.id === RaceUI.controlledCarId);
            if (controlled && controlled.tire) {
              controlled.tire.compound = changes.tireCompound;
              controlled.tire.condition = 100;  // Fresh tires
              controlled.tire.distanceTraveled = 0;
            }
          }
        }

        for (const s of this.schema) {
          const val = changes[s.key];
          if (val === undefined) continue;

          if (s.custom && s.key === 'pitSpeed') Track.pit.speedLimit = Math.max(1, val) / 3.6;
          else if (s.custom && s.key === 'pitOffset') Track.pit.offset = val;
          else CarConfig[s.key] = val;
        }

        Car.fuel = Math.min(Car.fuel, CarConfig.fuelCapacity);
        
        // Apply changes to the controlled car's setup as well
        if (typeof RaceUI !== 'undefined' && typeof MultiCarRace !== 'undefined') {
          const controlled = MultiCarRace.cars.find(c => c.id === RaceUI.controlledCarId);
          if (controlled) {
            // Copy ALL non-custom CarConfig values to controlled car's setup
            for (const s of this.schema) {
              if (s.custom) continue;  // Skip pit settings
              const val = CarConfig[s.key];
              if (val !== undefined) {
                controlled.setup[s.key] = val;
              }
            }
            // Also copy keys that might not be in schema but are in CarConfig
            const directKeys = ['mass','power','cLWing','cLDiffuser','cDBody','cDWing','cRr','frontalArea','tireGrip',
                                'brakeForce','camber','wingAngle','rideHeight','springK',
                                'damperC','fuelCapacity'];
            for (const key of directKeys) {
              if (CarConfig[key] !== undefined) {
                controlled.setup[key] = CarConfig[key];
              }
            }
            // Update fuel (refuel if in pit box)
            if (controlled.pit && controlled.pit.phase === 'stopped') {
              controlled.fuel = controlled.setup.fuelCapacity;
              Car.fuel = controlled.fuel;
            } else {
              controlled.fuel = Math.min(controlled.fuel, controlled.setup.fuelCapacity);
            }
            // Fully invalidate envelope cache so braking recalculates with new setup
            controlled._env = null;
            controlled._lastEnvBuildTime = -999;
            controlled._envPit = null;
            controlled._lastPitEnvBuildTime = -999;
            
            // Rebuild this car's platform lookup table with new suspension setup
            controlled.rebuildPlatformLookup();
            // Also update global Platform for single-car UI display
            Platform.buildLookupTable(controlled.setup);
          }
        }
        
        Renderer.centerTrack();
        UI.syncPitButtons();

        Simulation._lastEnvBuildTime = -999;
        Simulation._lastPitEnvBuildTime = -999;
        Simulation._env = null;
        Simulation._envPit = null;
        
        // Sync compound to tire modal
        const tireModalSelect = document.getElementById('tireCompoundSelect');
        if (tireModalSelect) tireModalSelect.value = Tire.compound;
      },

      updateStatusDisplay() {
        const hint = document.querySelector('#setupModal .modal-foot .hint');
        if (!hint) return;
        
        const deltas = this.getDeltas();
        let statusText = '';
        
        if (this.pendingChanges && deltas.length > 0) {
          statusText = '<strong style="color:#ffd700;">⏳ Pending changes (apply in box):</strong><br/>';
          statusText += deltas.map(d => {
            if (d.isString) {
              return `${d.label}: ${d.current} → ${d.pending}`;
            }
            const sign = d.delta >= 0 ? '+' : '';
            return `${d.label}: ${d.current.toFixed(2)} → ${d.pending.toFixed(2)} (${sign}${d.delta.toFixed(2)} ${d.unit})`;
          }).join('<br/>');
        } else if (this.lastAppliedInfo) {
          statusText = `<span style="color:#00ff88;">✓ Setup applied at Lap ${this.lastAppliedInfo.lap}</span>`;
        } else {
          statusText = 'Änderungen werden beim nächsten Box-Stopp aktiv.';
        }
        
        hint.innerHTML = statusText;
      },

      build() {
        this.fields = new Map();
        this.grid.innerHTML = '';

        // Add Tire Compound selector (special dropdown)
        const tireCard = document.createElement('div');
        tireCard.className = 'field';
        tireCard.style.gridColumn = 'span 2';

        const tireLbl = document.createElement('div');
        tireLbl.className = 'lbl';
        tireLbl.textContent = '🛞 Tire Compound (Box only)';

        const tireRow = document.createElement('div');
        tireRow.className = 'row';
        tireRow.style.gap = '12px';

        const tireSelect = document.createElement('select');
        tireSelect.id = 'setupTireCompound';
        tireSelect.style.flex = '1';
        tireSelect.innerHTML = `
          <option value="soft">🔴 Soft (High Grip, Fast Wear)</option>
          <option value="medium">🟡 Medium (Balanced)</option>
          <option value="hard">⚪ Hard (Low Grip, Durable)</option>
          <option value="intermediate">🟢 Inter (Wet Specialist)</option>
          <option value="wet">🔵 Wet (Rain Tires)</option>
        `;

        const tireStatus = document.createElement('span');
        tireStatus.id = 'setupTireStatus';
        tireStatus.style.fontSize = '12px';
        tireStatus.style.color = 'var(--text-secondary)';

        tireRow.appendChild(tireSelect);
        tireRow.appendChild(tireStatus);
        tireCard.appendChild(tireLbl);
        tireCard.appendChild(tireRow);
        this.grid.appendChild(tireCard);

        this.fields.set('tireCompound', tireSelect);

        for (const s of this.schema) {
          const card = document.createElement('div');
          card.className = 'field';

          const lbl = document.createElement('div');
          lbl.className = 'lbl';
          lbl.textContent = s.label;

          const row = document.createElement('div');
          row.className = 'row';

          const inp = document.createElement('input');
          inp.type = 'number';
          inp.step = String(s.step);
          inp.min = String(s.min);
          inp.max = String(s.max);

          const unit = document.createElement('div');
          unit.className = 'unit';
          unit.textContent = s.unit;

          row.appendChild(inp);
          row.appendChild(unit);

          card.appendChild(lbl);
          card.appendChild(row);

          this.grid.appendChild(card);
          this.fields.set(s.key, inp);
        }
      },

      fillFromConfig() {
        // Get the controlled car's setup if available
        let sourceSetup = CarConfig;
        let sourceTire = Tire;
        
        if (typeof RaceUI !== 'undefined' && typeof MultiCarRace !== 'undefined') {
          const controlled = MultiCarRace.cars.find(c => c.id === RaceUI.controlledCarId);
          if (controlled) {
            sourceSetup = controlled.setup;
            sourceTire = controlled.tire;
          }
        }
        
        // Fill tire compound
        const tireSelect = this.fields.get('tireCompound');
        if (tireSelect) {
          tireSelect.value = sourceTire.compound;
          const status = document.getElementById('setupTireStatus');
          if (status) {
            const condition = sourceTire.condition !== undefined ? sourceTire.condition : Tire.condition;
            const dist = sourceTire.distanceTraveled !== undefined ? sourceTire.distanceTraveled : Tire.distanceTraveled;
            status.textContent = `Current: ${condition.toFixed(0)}% | ${(dist/1000).toFixed(1)}km`;
          }
        }

        for (const s of this.schema) {
          const inp = this.fields.get(s.key);
          if (!inp) continue;

          if (s.custom && s.key === 'pitSpeed') inp.value = (Track.pit.speedLimit * 3.6).toFixed(0);
          else if (s.custom && s.key === 'pitOffset') inp.value = Track.pit.offset.toFixed(0);
          else {
            // Apply transform for display (e.g., m -> mm, N/m -> kN/m)
            let val = sourceSetup[s.key];
            if (val === undefined) val = CarConfig[s.key];  // Fallback
            if (s.transform) val = s.transform(val);
            inp.value = val;
          }
        }
      },

      fillFromDefaults() {
        Object.assign(CarConfig, structuredClone(CarDefaults));
        Track.pit.speedLimit = 60 / 3.6;
        Track.pit.offset = -14;
        this.fillFromConfig();
        Car.fuel = Math.min(Car.fuel, CarConfig.fuelCapacity);
        this.pendingChanges = null;
        this.updateStatusDisplay();
      },

      open() {
        this.fillFromConfig();
        this.updateStatusDisplay();
        this.modal.classList.add('open');
        this.modal.setAttribute('aria-hidden', 'false');
      },

      close() {
        this.modal.classList.remove('open');
        this.modal.setAttribute('aria-hidden', 'true');
      },

      isOpen() {
        return this.modal && this.modal.classList.contains('open');
      }
    };
    // ═══════════════════════════════════════════════════════════════════════════════
    // TIRE UI
    // ═══════════════════════════════════════════════════════════════════════════════
    const TireUI = {
      modal: null,

      init() {
        if (this._initialized) return;
        this._initialized = true;
        this.modal = document.getElementById('tireModal');

        document.getElementById('tireBtn').addEventListener('click', () => this.open());
        document.getElementById('tireClose').addEventListener('click', () => this.close());
        this.modal.addEventListener('click', (e) => { if (e.target === this.modal) this.close(); });

        document.getElementById('tireChange').addEventListener('click', () => this.changeTires());
        
        // Compound selection cards
        document.getElementById('tireSoftCard').addEventListener('click', () => this.selectCompound('soft'));
        document.getElementById('tireMediumCard').addEventListener('click', () => this.selectCompound('medium'));
        document.getElementById('tireHardCard').addEventListener('click', () => this.selectCompound('hard'));
      },

      open() {
        this.update();
        this.drawGripCurve();
        this.drawFwetCurve();
        this.drawFtempCurve();
        this.drawMwearCurve();
        this.modal.classList.add('open');
        this.modal.setAttribute('aria-hidden', 'false');
      },

      close() {
        this.modal.classList.remove('open');
        this.modal.setAttribute('aria-hidden', 'true');
      },

      isOpen() {
        return this.modal.classList.contains('open');
      },

      selectCompound(compound) {
        const inBox = this.isControlledInBox();
        if (!inBox) return; // Can only change compound in box
        
        document.getElementById('tireCompoundSelect').value = compound;
        this.highlightSelectedCompound(compound);
      },

      highlightSelectedCompound(compound) {
        const softCard = document.getElementById('tireSoftCard');
        const mediumCard = document.getElementById('tireMediumCard');
        const hardCard = document.getElementById('tireHardCard');
        
        softCard.style.opacity = compound === 'soft' ? '1' : '0.6';
        mediumCard.style.opacity = compound === 'medium' ? '1' : '0.6';
        hardCard.style.opacity = compound === 'hard' ? '1' : '0.6';
      },

      changeTires() {
        const inBox = this.isControlledInBox();
        if (!inBox) return;

        const newCompound = document.getElementById('tireCompoundSelect').value;
        
        // Use tire allocation system to mount the best available set
        if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
          const controlled = MultiCarRace.cars.find(c => c.id === (RaceUI?.controlledCarId || 1));
          if (controlled && controlled.tire && controlled.tireAllocation) {
            // Save current state
            TireAllocation.saveCurrentState(controlled.tireAllocation, controlled.tire);
            // Find the best available set (highest condition)
            const sets = controlled.tireAllocation.sets[newCompound] || [];
            let bestIdx = 0;
            let bestCond = -1;
            for (let i = 0; i < sets.length; i++) {
              if (sets[i].condition > bestCond) {
                bestCond = sets[i].condition;
                bestIdx = i;
              }
            }
            TireAllocation.mountSet(controlled.tireAllocation, controlled.tire, newCompound, bestIdx);
            // Sync to global Tire
            Tire.compound = controlled.tire.compound;
            Tire.condition = controlled.tire.condition;
            Tire.distanceTraveled = controlled.tire.distanceTraveled;
          } else {
            Tire.changeTires(newCompound);
          }
        } else {
          Tire.changeTires(newCompound);
        }
        
        this.update();
        this.drawGripCurve();
        this.drawFwetCurve();
        this.drawFtempCurve();
        this.drawMwearCurve();
        // Sync compound to setup modal
        this.syncCompoundToSetup();
      },

      // Cross-sync: update setup modal's compound selector to match current tire
      syncCompoundToSetup() {
        const setupSelect = document.getElementById('setupTireCompound');
        if (setupSelect) setupSelect.value = Tire.compound;
      },
      
      // Helper: check if controlled car is in box
      isControlledInBox() {
        if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
          const controlled = MultiCarRace.cars.find(c => c.id === (RaceUI?.controlledCarId || 1));
          if (controlled && controlled.pit) {
            return controlled.pit.inLane && controlled.pit.phase === 'stopped';
          }
        }
        return Car.pit.inLane && Car.pit.phase === 'stopped';
      },

      update() {
        const compound = Tire.getCompound();
        
        // Update compound badge
        const badge = document.getElementById('tireCompoundBadge');
        const info = document.getElementById('tireCompoundInfo');
        if (badge) {
          badge.textContent = compound.name.toUpperCase();
          badge.style.background = compound.color;
          badge.style.color = '#000';
        }
        if (info) {
          info.textContent = Tire.compound === 'soft' 
            ? 'Maximum grip, faster wear' 
            : Tire.compound === 'hard'
            ? 'Maximum durability, less grip'
            : 'Balanced grip and durability';
        }
        
        // Update condition bar with compound color
        const bar = document.getElementById('tireConditionBar');
        if (bar) {
          bar.style.width = `${Tire.condition}%`;
          bar.style.background = `linear-gradient(90deg, ${compound.color}88, ${compound.color})`;
        }
        
        // Update optimal range marker
        const marker = document.getElementById('tireOptimalMarker');
        if (marker) {
          marker.style.left = `${compound.optimalConditionLow}%`;
          marker.style.width = `${compound.optimalConditionHigh - compound.optimalConditionLow}%`;
        }
        
        // Update text displays
        const text = document.getElementById('tireConditionText');
        const distText = document.getElementById('tireDistanceText');
        const gripText = document.getElementById('tireGripMultText');
        const changeBtn = document.getElementById('tireChange');
        const compoundSelect = document.getElementById('tireCompoundSelect');

        if (text) text.textContent = `${Tire.condition.toFixed(1)}%`;
        if (distText) distText.textContent = `${(Tire.distanceTraveled / 1000).toFixed(2)} km`;
        if (gripText) {
          const grip = Tire.getGripMultiplier() * 100;
          gripText.textContent = `${grip.toFixed(1)}%`;
          gripText.style.color = grip >= 100 ? '#00ff88' : (grip >= 90 ? '#ffcc00' : '#ff6666');
        }

        // Enable tire change only in box
        const inBox = Car.pit.inLane && Car.pit.phase === 'stopped';
        if (changeBtn) changeBtn.disabled = !inBox;
        if (compoundSelect) compoundSelect.disabled = !inBox;

        // Populate compound select from allocation sets only
        if (compoundSelect) {
          let alloc = null;
          if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
            const controlled = MultiCarRace.cars.find(c => c.id === (RaceUI?.controlledCarId || 1));
            if (controlled && controlled.tireAllocation) alloc = controlled.tireAllocation;
          }
          if (alloc) {
            const compIcons = { soft: '🔴', medium: '🟡', hard: '⚪', intermediate: '🟢', wet: '🔵' };
            const compLabels = { soft: 'Soft', medium: 'Medium', hard: 'Hard', intermediate: 'Inter', wet: 'Wet' };
            const curVal = compoundSelect.value;
            compoundSelect.innerHTML = '';
            for (const [comp, sets] of Object.entries(alloc.sets)) {
              // Only show compounds that have at least one set with condition > 0
              const hasUsable = sets.some(s => s.condition > 0);
              if (!hasUsable) continue;
              const bestCond = Math.max(...sets.map(s => s.condition));
              const opt = document.createElement('option');
              opt.value = comp;
              opt.textContent = `${compIcons[comp] || ''} ${compLabels[comp] || comp} (${Math.round(bestCond)}%)`;
              compoundSelect.appendChild(opt);
            }
            // Restore selection
            if ([...compoundSelect.options].some(o => o.value === curVal)) {
              compoundSelect.value = curVal;
            } else {
              compoundSelect.value = Tire.compound;
            }
          }
        }
        
        // Highlight current compound
        this.highlightSelectedCompound(Tire.compound);
        if (compoundSelect) compoundSelect.value = Tire.compound;
        
        // Render tire sets allocation
        this.renderTireSets();
      },
      
      renderTireSets() {
        const container = document.getElementById('tireSetsContainer');
        if (!container) return;
        
        // Get allocation from controlled car
        let alloc = null;
        if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
          const controlled = MultiCarRace.cars.find(c => c.id === (RaceUI?.controlledCarId || 1));
          if (controlled && controlled.tireAllocation) {
            // First save current tire state to allocation
            TireAllocation.saveCurrentState(controlled.tireAllocation, controlled.tire);
            alloc = controlled.tireAllocation;
          }
        }
        
        if (!alloc) {
          container.innerHTML = '<span style="color:#888; font-size:11px;">No allocation data</span>';
          return;
        }
        
        const compoundColors = { soft: '#ff4444', medium: '#ffcc00', hard: '#ffffff', intermediate: '#44cc44', wet: '#4488ff' };
        const compoundNames = { soft: 'S', medium: 'M', hard: 'H', intermediate: 'I', wet: 'W' };
        const inBox = this.isControlledInBox();
        
        let html = '';
        for (const [compound, sets] of Object.entries(alloc.sets)) {
          const color = compoundColors[compound] || '#aaa';
          const letter = compoundNames[compound] || '?';
          for (let i = 0; i < sets.length; i++) {
            const set = sets[i];
            const isActive = compound === alloc.activeCompound && i === alloc.activeSetIndex;
            const condPct = Math.round(set.condition);
            const condColor = condPct > 60 ? '#4f4' : condPct > 30 ? '#ff4' : '#f44';
            const border = isActive ? `3px solid ${color}` : `1px solid #555`;
            const bg = isActive ? `rgba(${color === '#ffffff' ? '255,255,255' : color === '#ff4444' ? '255,68,68' : color === '#ffcc00' ? '255,204,0' : color === '#44cc44' ? '68,204,68' : '68,136,255'},0.15)` : 'rgba(255,255,255,0.03)';
            const cursor = inBox && !isActive ? 'pointer' : 'default';
            const opacity = set.condition <= 0 ? '0.3' : '1';
            
            html += `<div class="tire-set-badge" data-compound="${compound}" data-set-idx="${i}" 
              style="display:inline-flex; flex-direction:column; align-items:center; padding:4px 8px; 
              border:${border}; border-radius:6px; background:${bg}; cursor:${cursor}; 
              min-width:42px; opacity:${opacity}; font-size:11px;"
              title="${TireCompounds[compound]?.name || compound} Set ${i+1} — ${condPct}% condition${set.used ? ' (used)' : ' (new)'}">
              <span style="font-weight:900; color:${color}; font-size:13px;">${letter}${i+1}</span>
              <span style="color:${condColor}; font-size:10px;">${condPct}%</span>
              ${isActive ? '<span style="color:#0f0; font-size:8px;">▶ ON</span>' : (set.used ? '<span style="color:#888; font-size:8px;">used</span>' : '<span style="color:#aaa; font-size:8px;">new</span>')}
            </div>`;
          }
          // Separator between compounds
          html += '<div style="width:2px; background:#333; margin:0 2px; align-self:stretch;"></div>';
        }
        // Remove last separator
        container.innerHTML = html.replace(/<div style="width:2px[^>]*><\/div>$/, '');
        
        // Wire click handlers to select sets (only when in box)
        if (inBox) {
          container.querySelectorAll('.tire-set-badge').forEach(el => {
            el.addEventListener('click', () => {
              const comp = el.dataset.compound;
              const idx = parseInt(el.dataset.setIdx);
              const controlled = MultiCarRace.cars.find(c => c.id === (RaceUI?.controlledCarId || 1));
              if (controlled && controlled.tire && controlled.tireAllocation) {
                TireAllocation.mountSet(controlled.tireAllocation, controlled.tire, comp, idx);
                Tire.compound = controlled.tire.compound;
                Tire.condition = controlled.tire.condition;
                Tire.distanceTraveled = controlled.tire.distanceTraveled;
                this.update();
                this.drawGripCurve();
                this.drawFwetCurve();
                this.drawFtempCurve();
                this.drawMwearCurve();
                this.syncCompoundToSetup();
              }
            });
          });
        }
      },

      drawGripCurve() {
        const canvas = document.getElementById('tireGripCurveCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;
        
        ctx.clearRect(0, 0, W, H);
        
        const padL = 40, padR = 10, padT = 15, padB = 25;
        const plotW = W - padL - padR;
        const plotH = H - padT - padB;
        
        // Draw grid
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
          const x = padL + (plotW * i / 4);
          ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, padT + plotH); ctx.stroke();
        }
        for (let i = 0; i <= 4; i++) {
          const y = padT + (plotH * i / 4);
          ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(padL + plotW, y); ctx.stroke();
        }
        
        // Draw grip curves for both compounds
        const drawCurve = (compoundKey, dashed) => {
          const comp = TireCompounds[compoundKey];
          ctx.strokeStyle = comp.color;
          ctx.lineWidth = 2;
          ctx.setLineDash(dashed ? [6, 4] : []);
          
          ctx.beginPath();
          for (let c = 0; c <= 100; c++) {
            let grip;
            if (c >= comp.optimalConditionLow && c <= comp.optimalConditionHigh) {
              grip = comp.baseGrip * comp.optimalGripBonus;
            } else if (c > comp.optimalConditionHigh) {
              const t = (c - comp.optimalConditionHigh) / (100 - comp.optimalConditionHigh);
              grip = comp.baseGrip * (1.0 - t * 0.03);
            } else {
              const t = c / comp.optimalConditionLow;
              grip = comp.baseGrip * (comp.minGripFactor + t * (1.0 - comp.minGripFactor));
            }
            
            const x = padL + (c / 100) * plotW;
            const y = padT + plotH - ((grip - 0.5) / 0.6) * plotH; // Scale 0.5-1.1 to plot height
            
            if (c === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
          ctx.setLineDash([]);
        };
        
        drawCurve('hard', Tire.compound !== 'hard');
        drawCurve('medium', Tire.compound !== 'medium');
        drawCurve('soft', Tire.compound !== 'soft');
        
        // Draw current position marker
        const comp = Tire.getCompound();
        const currentGrip = Tire.getGripMultiplier();
        const markerX = padL + (Tire.condition / 100) * plotW;
        const markerY = padT + plotH - ((currentGrip - 0.5) / 0.6) * plotH;
        
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(markerX, markerY, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // Labels
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.font = '10px system-ui';
        ctx.fillText('0%', padL - 20, padT + plotH + 4);
        ctx.fillText('100%', padL + plotW - 15, padT + plotH + 4);
        ctx.fillText('Condition →', padL + plotW/2 - 30, padT + plotH + 18);
        
        ctx.save();
        ctx.translate(12, padT + plotH/2);
        ctx.rotate(-Math.PI/2);
        ctx.fillText('Grip', 0, 0);
        ctx.restore();
      },

      // ═══════════════════════════════════════════════════════════════════
      // F_wet — Grip vs Wetness for all 5 compounds
      // ═══════════════════════════════════════════════════════════════════
      drawFwetCurve() {
        const canvas = document.getElementById('tireFwetCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        const padL = 45, padR = 10, padT = 15, padB = 28;
        const plotW = W - padL - padR, plotH = H - padT - padB;
        const yMin = 0, yMax = 1.05;

        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
        for (let i = 0; i <= 5; i++) {
          const x = padL + plotW * i / 5;
          ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, padT + plotH); ctx.stroke();
        }
        for (let i = 0; i <= 4; i++) {
          const y = padT + plotH * i / 4;
          ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(padL + plotW, y); ctx.stroke();
        }

        // Y-axis labels
        ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font = '10px system-ui'; ctx.textAlign = 'right';
        for (let i = 0; i <= 4; i++) {
          const v = yMax - (yMax - yMin) * i / 4;
          ctx.fillText(v.toFixed(2), padL - 4, padT + plotH * i / 4 + 3);
        }
        ctx.textAlign = 'left';

        // X-axis labels
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        for (let i = 0; i <= 5; i++) {
          ctx.fillText(`${i * 20}%`, padL + plotW * i / 5 - 8, padT + plotH + 14);
        }
        ctx.fillText('Wetness →', padL + plotW / 2 - 25, padT + plotH + 26);
        ctx.save(); ctx.translate(10, padT + plotH / 2); ctx.rotate(-Math.PI / 2);
        ctx.fillText('F_wet', 0, 0); ctx.restore();

        const compounds = ['soft', 'medium', 'hard', 'intermediate', 'wet'];
        const steps = 200;

        for (const c of compounds) {
          const comp = TireCompounds[c];
          const isActive = c === Tire.compound;
          ctx.strokeStyle = comp.color;
          ctx.lineWidth = isActive ? 3 : 1.5;
          ctx.globalAlpha = isActive ? 1 : 0.55;
          ctx.setLineDash(isActive ? [] : [4, 3]);
          ctx.beginPath();
          for (let i = 0; i <= steps; i++) {
            const w = i / steps;
            const fw = TireModel.F_wet(c, w);
            const x = padL + (w) * plotW;
            const y = padT + plotH - ((fw - yMin) / (yMax - yMin)) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.stroke();
          ctx.setLineDash([]); ctx.globalAlpha = 1;
        }

        // Current position marker
        const curW = Weather.wetness || 0;
        const curFw = TireModel.F_wet(Tire.compound, curW);
        const mx = padL + curW * plotW;
        const my = padT + plotH - ((curFw - yMin) / (yMax - yMin)) * plotH;
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(mx, my, 5, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = TireCompounds[Tire.compound]?.color || '#fff'; ctx.beginPath(); ctx.arc(mx, my, 3, 0, Math.PI * 2); ctx.fill();

        // Legend
        let lx = padL + 4;
        for (const c of compounds) {
          ctx.fillStyle = TireCompounds[c].color;
          ctx.fillRect(lx, padT + 2, 8, 8);
          ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.font = '9px system-ui';
          ctx.fillText(TireCompounds[c].name, lx + 10, padT + 10);
          lx += ctx.measureText(TireCompounds[c].name).width + 18;
        }
      },

      // ═══════════════════════════════════════════════════════════════════
      // F_temp — Grip vs Track Temperature for all 5 compounds
      // ═══════════════════════════════════════════════════════════════════
      drawFtempCurve() {
        const canvas = document.getElementById('tireFtempCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        const padL = 45, padR = 10, padT = 15, padB = 28;
        const plotW = W - padL - padR, plotH = H - padT - padB;
        const Tmin = 5, Tmax = 50;
        const yMin = 0.96, yMax = 1.005;

        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
        for (let i = 0; i <= 9; i++) {
          const x = padL + plotW * i / 9;
          ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, padT + plotH); ctx.stroke();
        }
        for (let i = 0; i <= 4; i++) {
          const y = padT + plotH * i / 4;
          ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(padL + plotW, y); ctx.stroke();
        }

        // Y-axis labels
        ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font = '10px system-ui'; ctx.textAlign = 'right';
        for (let i = 0; i <= 4; i++) {
          const v = yMax - (yMax - yMin) * i / 4;
          ctx.fillText(v.toFixed(3), padL - 4, padT + plotH * i / 4 + 3);
        }
        ctx.textAlign = 'left';

        // X-axis labels
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        for (let i = 0; i <= 9; i++) {
          const T = Tmin + (Tmax - Tmin) * i / 9;
          ctx.fillText(`${Math.round(T)}°`, padL + plotW * i / 9 - 6, padT + plotH + 14);
        }
        ctx.fillText('Track Temp →', padL + plotW / 2 - 30, padT + plotH + 26);
        ctx.save(); ctx.translate(10, padT + plotH / 2); ctx.rotate(-Math.PI / 2);
        ctx.fillText('F_temp', 0, 0); ctx.restore();

        const compounds = ['soft', 'medium', 'hard', 'intermediate', 'wet'];
        const steps = 200;

        for (const c of compounds) {
          const comp = TireCompounds[c];
          const isActive = c === Tire.compound;
          ctx.strokeStyle = comp.color;
          ctx.lineWidth = isActive ? 3 : 1.5;
          ctx.globalAlpha = isActive ? 1 : 0.55;
          ctx.setLineDash(isActive ? [] : [4, 3]);
          ctx.beginPath();
          for (let i = 0; i <= steps; i++) {
            const T = Tmin + (Tmax - Tmin) * i / steps;
            const ft = TireModel.F_temp(c, T);
            const x = padL + (i / steps) * plotW;
            const y = padT + plotH - ((ft - yMin) / (yMax - yMin)) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.stroke();
          ctx.setLineDash([]); ctx.globalAlpha = 1;
        }

        // Current position marker
        const curT = Weather.trackTemp || 25;
        const curFt = TireModel.F_temp(Tire.compound, curT);
        const mx = padL + ((curT - Tmin) / (Tmax - Tmin)) * plotW;
        const my = padT + plotH - ((curFt - yMin) / (yMax - yMin)) * plotH;
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(mx, my, 5, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = TireCompounds[Tire.compound]?.color || '#fff'; ctx.beginPath(); ctx.arc(mx, my, 3, 0, Math.PI * 2); ctx.fill();
      },

      // ═══════════════════════════════════════════════════════════════════
      // M_wear — Wear Multiplier vs Wetness for all 5 compounds
      // ═══════════════════════════════════════════════════════════════════
      drawMwearCurve() {
        const canvas = document.getElementById('tireMwearCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        const padL = 45, padR = 10, padT = 15, padB = 28;
        const plotW = W - padL - padR, plotH = H - padT - padB;
        const yMin = 0.95, yMax = 1.25;

        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
        for (let i = 0; i <= 5; i++) {
          const x = padL + plotW * i / 5;
          ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, padT + plotH); ctx.stroke();
        }
        for (let i = 0; i <= 4; i++) {
          const y = padT + plotH * i / 4;
          ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(padL + plotW, y); ctx.stroke();
        }

        // Y-axis labels
        ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font = '10px system-ui'; ctx.textAlign = 'right';
        for (let i = 0; i <= 4; i++) {
          const v = yMax - (yMax - yMin) * i / 4;
          ctx.fillText(v.toFixed(2), padL - 4, padT + plotH * i / 4 + 3);
        }
        ctx.textAlign = 'left';

        // X-axis labels
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        for (let i = 0; i <= 5; i++) {
          ctx.fillText(`${i * 20}%`, padL + plotW * i / 5 - 8, padT + plotH + 14);
        }
        ctx.fillText('Wetness →', padL + plotW / 2 - 25, padT + plotH + 26);
        ctx.save(); ctx.translate(10, padT + plotH / 2); ctx.rotate(-Math.PI / 2);
        ctx.fillText('M_wear', 0, 0); ctx.restore();

        // Use current rubber+temp for the wear curve, vary wetness
        const rubberLvl = Weather.rubberLevel != null ? Weather.rubberLevel : 0.5;
        const trackTemp = Weather.trackTemp || 25;

        const compounds = ['soft', 'medium', 'hard', 'intermediate', 'wet'];
        const steps = 200;

        for (const c of compounds) {
          const comp = TireCompounds[c];
          const isActive = c === Tire.compound;
          ctx.strokeStyle = comp.color;
          ctx.lineWidth = isActive ? 3 : 1.5;
          ctx.globalAlpha = isActive ? 1 : 0.55;
          ctx.setLineDash(isActive ? [] : [4, 3]);
          ctx.beginPath();
          for (let i = 0; i <= steps; i++) {
            const w = i / steps;
            const mw = TireModel.getWearMultiplier(c, rubberLvl, w, trackTemp);
            const x = padL + (w) * plotW;
            const y = padT + plotH - ((mw - yMin) / (yMax - yMin)) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          }
          ctx.stroke();
          ctx.setLineDash([]); ctx.globalAlpha = 1;
        }

        // Current position
        const curW = Weather.wetness || 0;
        const curMw = TireModel.getWearMultiplier(Tire.compound, rubberLvl, curW, trackTemp);
        const mx = padL + curW * plotW;
        const my = padT + plotH - ((curMw - yMin) / (yMax - yMin)) * plotH;
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(mx, my, 5, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = TireCompounds[Tire.compound]?.color || '#fff'; ctx.beginPath(); ctx.arc(mx, my, 3, 0, Math.PI * 2); ctx.fill();

        // Legend
        let lx = padL + 4;
        for (const c of compounds) {
          ctx.fillStyle = TireCompounds[c].color;
          ctx.fillRect(lx, padT + 2, 8, 8);
          ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.font = '9px system-ui';
          ctx.fillText(TireCompounds[c].name, lx + 10, padT + 10);
          lx += ctx.measureText(TireCompounds[c].name).width + 18;
        }
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // WEATHER FORECAST UI
    // ═══════════════════════════════════════════════════════════════════════════════
    const WeatherUI = {
      modal: null,

      init() {
        this.modal = document.getElementById('weatherModal');
        const closeBtn = document.getElementById('weatherClose');
        const closeBtn2 = document.getElementById('weatherCloseBtn');
        const openBtn = document.getElementById('weatherBtn');
        if (closeBtn) closeBtn.addEventListener('click', () => this.close());
        if (closeBtn2) closeBtn2.addEventListener('click', () => this.close());
        if (openBtn) openBtn.addEventListener('click', () => this.open());
      },

      open() {
        if (this.modal) {
          this.modal.style.display = 'grid';
          this.modal.setAttribute('aria-hidden', 'false');
          this.update();
        }
      },

      close() {
        if (this.modal) {
          this.modal.style.display = 'none';
          this.modal.setAttribute('aria-hidden', 'true');
        }
      },

      isOpen() {
        return this.modal && this.modal.style.display === 'grid';
      },

      // ── Weather Schedule UI ──
      addScheduleWaypoint() {
        if (Simulation.running) return; // Only pre-race
        const timeVal = parseFloat(document.getElementById('wsAddTime')?.value) || 0;
        const condVal = document.getElementById('wsAddCond')?.value || 'sunny';
        const tempVal = parseFloat(document.getElementById('wsAddTemp')?.value) || 25;

        const wp = { time: timeVal, condition: condVal, airTemp: tempVal };
        const tl = Weather._timeline.slice();
        tl.push(wp);
        Weather.setTimeline(tl);
        this.renderSchedule();
      },

      removeScheduleWaypoint(idx) {
        if (Simulation.running) return;
        const tl = Weather._timeline.slice();
        tl.splice(idx, 1);
        Weather.setTimeline(tl);
        this.renderSchedule();
      },

      renderSchedule() {
        const container = document.getElementById('weatherScheduleList');
        const section = document.getElementById('weatherScheduleSection');
        if (!container) return;

        // Disable schedule changes during race
        const disabled = Simulation.running;
        if (section) {
          section.querySelectorAll('input, select, button').forEach(el => {
            if (el.id !== 'weatherCloseBtn') el.disabled = disabled;
          });
        }

        const tl = Weather._timeline;
        if (tl.length === 0) {
          container.innerHTML = '<span style="color:#666; font-size:11px;">No waypoints. Current sidebar weather is used throughout.</span>';
          return;
        }

        const condIcons = { sunny: '☀', cloudy: '☁', light_rain: '🌦', heavy_rain: '🌧' };
        let html = '';
        for (let i = 0; i < tl.length; i++) {
          const wp = tl[i];
          const icon = condIcons[wp.condition] || '?';
          html += `<div style="display:flex; align-items:center; gap:8px; padding:4px 8px; background:rgba(255,255,255,0.04); border-radius:4px; font-size:12px;">
            <span style="color:#888; min-width:40px; font-weight:700;">${wp.time} min</span>
            <span>${icon} ${wp.condition}</span>
            <span style="color:#ff8844;">${wp.airTemp}°C</span>
            ${disabled ? '' : `<button class="btn" data-ws-remove="${i}" style="font-size:9px; padding:1px 6px; margin-left:auto;">✕</button>`}
          </div>`;
        }
        container.innerHTML = html;

        // Wire remove buttons
        if (!disabled) {
          container.querySelectorAll('[data-ws-remove]').forEach(btn => {
            btn.addEventListener('click', () => {
              this.removeScheduleWaypoint(parseInt(btn.dataset.wsRemove));
            });
          });
        }
      },

      update() {
        // Current conditions
        const condIcons = { sunny: '☀ Sunny', cloudy: '☁ Cloudy', light_rain: '🌦 Light Rain', heavy_rain: '🌧 Heavy Rain' };
        const el = (id) => document.getElementById(id);
        el('wfCurrentCond').textContent = condIcons[Weather.condition] || Weather.condition;
        el('wfCurrentTemp').textContent = `${Weather.airTemp.toFixed(0)} / ${Weather.trackTemp.toFixed(0)} °C`;
        el('wfCurrentWet').textContent = `${(Weather.wetness * 100).toFixed(0)}%`;
        el('wfCurrentWet').style.color = Weather.wetness > 0.3 ? '#4488ff' : Weather.wetness > 0.1 ? '#88aaff' : '#ccc';
        // Show compound-specific grip factor from TireModel
        const compF = Weather.getCompoundFactors(Tire.compound);
        const compGripPct = (compF.gripFactor * 100).toFixed(0);
        el('wfTrackGrip').textContent = `${compGripPct}% (${Tire.getCompound().name})`;
        el('wfGripDetail').textContent = `rubber ${(compF.F_rubber*100).toFixed(0)}% · wet ${(compF.F_wet*100).toFixed(0)}% · temp ${(compF.F_temp*100).toFixed(0)}%`;
        el('wfDensity').textContent = `${Weather.airDensity.toFixed(3)} kg/m³`;

        // Draw forecast graph on canvas
        const canvas = el('wfForecastCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        // Layout: margins
        const mL = 40, mR = 40, mT = 15, mB = 25;
        const plotW = W - mL - mR;
        const plotH = H - mT - mB;

        // Forecast parameters
        const totalSeconds = 900; // 15 minutes
        const steps = 60; // one data point every 15 seconds
        const dtStep = totalSeconds / steps;

        // Simulate weather forward
        let simAirTemp = Weather.airTemp;
        let simRainInt = Weather.rainIntensity;
        let simWetness = Weather.wetness;
        let simCond = Weather.condition;
        let simTrackTemp = Weather.trackTemp;
        const raceTimeNow = (typeof Simulation !== 'undefined') ? Simulation.time : 0;

        const tempData = [{ t: 0, val: simAirTemp }];
        const rainData = [{ t: 0, val: simRainInt * 100 }];

        const condToIntensity = { sunny: 0, cloudy: 0, light_rain: 0.3, heavy_rain: 0.8 };

        for (let i = 1; i <= steps; i++) {
          const t = i * dtStep;
          
          // If timeline is active, use it to set condition/temp at future race time
          if (Weather._timelineActive) {
            const futureRaceTime = raceTimeNow + t;
            const wp = Weather._evaluateTimeline(futureRaceTime);
            if (wp) {
              simCond = wp.condition;
              simAirTemp = wp.airTemp;
              simRainInt = condToIntensity[simCond] || 0;
            }
          }
          
          // Simulate wetness
          const rainRate = simRainInt * 0.012;
          const evapBase = simCond === 'sunny' ? 0.0015 : 0.0005;
          const tempBonus = Math.max(0, (simTrackTemp - 15) * 0.00005);
          const windBonus = Weather.windSpeed * 0.0001;
          const evapRate = evapBase + tempBonus + windBonus;
          simWetness = Math.max(0, Math.min(1, simWetness + (rainRate - evapRate) * dtStep));
          // Small random drift for temperature (deterministic for display)
          simAirTemp += Math.sin(t * 0.01 + Weather.airTemp) * 0.02;
          simTrackTemp = simAirTemp + 10 + (simCond === 'sunny' ? 5 : 0) - simWetness * 8;
          tempData.push({ t, val: simAirTemp });
          rainData.push({ t, val: simRainInt * 100 });
        }

        // Determine axis ranges
        const tempMin = Math.floor(Math.min(...tempData.map(d => d.val)) - 8);
        const tempMax = Math.ceil(Math.max(...tempData.map(d => d.val)) + 8);
        const rainMin = 0;
        const rainMax = 100;

        // Uncertainty grows with time
        const uncertaintyAt = (tSec) => {
          const frac = tSec / totalSeconds;
          return frac * frac; // quadratic growth
        };

        // Helper: x position for time
        const xAt = (tSec) => mL + (tSec / totalSeconds) * plotW;
        // Helper: y position for temp
        const yTemp = (v) => mT + plotH - ((v - tempMin) / (tempMax - tempMin)) * plotH;
        // Helper: y position for rain %
        const yRain = (v) => mT + plotH - ((v - rainMin) / (rainMax - rainMin)) * plotH;

        // Draw grid
        ctx.strokeStyle = '#1a1e28';
        ctx.lineWidth = 1;
        // Horizontal grid lines
        for (let i = 0; i <= 4; i++) {
          const y = mT + (plotH / 4) * i;
          ctx.beginPath(); ctx.moveTo(mL, y); ctx.lineTo(W - mR, y); ctx.stroke();
        }
        // Vertical grid lines (every 3 min)
        for (let m = 0; m <= 15; m += 3) {
          const x = xAt(m * 60);
          ctx.beginPath(); ctx.moveTo(x, mT); ctx.lineTo(x, mT + plotH); ctx.stroke();
        }

        // X-axis labels
        ctx.fillStyle = '#666';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        for (let m = 0; m <= 15; m += 3) {
          ctx.fillText(`+${m}m`, xAt(m * 60), H - 5);
        }

        // Left Y-axis labels (Temperature)
        ctx.textAlign = 'right';
        ctx.fillStyle = '#ff8844';
        for (let i = 0; i <= 4; i++) {
          const v = tempMin + ((tempMax - tempMin) / 4) * (4 - i);
          ctx.fillText(`${v.toFixed(0)}°`, mL - 4, mT + (plotH / 4) * i + 3);
        }

        // Right Y-axis labels (Rain %)
        ctx.textAlign = 'left';
        ctx.fillStyle = '#4488ff';
        for (let i = 0; i <= 4; i++) {
          const v = rainMax - (rainMax / 4) * i;
          ctx.fillText(`${v.toFixed(0)}%`, W - mR + 4, mT + (plotH / 4) * i + 3);
        }

        // Draw temperature uncertainty cone (orange)
        const tempUncertaintyRange = (tempMax - tempMin) * 0.4; // max ± at end
        ctx.beginPath();
        for (let i = 0; i < tempData.length; i++) {
          const d = tempData[i];
          const unc = uncertaintyAt(d.t) * tempUncertaintyRange;
          const y = yTemp(Math.min(tempMax, d.val + unc));
          if (i === 0) ctx.moveTo(xAt(d.t), y); else ctx.lineTo(xAt(d.t), y);
        }
        for (let i = tempData.length - 1; i >= 0; i--) {
          const d = tempData[i];
          const unc = uncertaintyAt(d.t) * tempUncertaintyRange;
          const y = yTemp(Math.max(tempMin, d.val - unc));
          ctx.lineTo(xAt(d.t), y);
        }
        ctx.closePath();
        ctx.fillStyle = 'rgba(255, 136, 68, 0.12)';
        ctx.fill();

        // Draw temperature line
        ctx.beginPath();
        ctx.strokeStyle = '#ff8844';
        ctx.lineWidth = 2;
        for (let i = 0; i < tempData.length; i++) {
          const d = tempData[i];
          if (i === 0) ctx.moveTo(xAt(d.t), yTemp(d.val)); else ctx.lineTo(xAt(d.t), yTemp(d.val));
        }
        ctx.stroke();

        // Draw rain uncertainty cone (blue)
        const rainUncertaintyRange = 40; // max ± at end
        ctx.beginPath();
        for (let i = 0; i < rainData.length; i++) {
          const d = rainData[i];
          const unc = uncertaintyAt(d.t) * rainUncertaintyRange;
          const y = yRain(Math.min(100, d.val + unc));
          if (i === 0) ctx.moveTo(xAt(d.t), y); else ctx.lineTo(xAt(d.t), y);
        }
        for (let i = rainData.length - 1; i >= 0; i--) {
          const d = rainData[i];
          const unc = uncertaintyAt(d.t) * rainUncertaintyRange;
          const y = yRain(Math.max(0, d.val - unc));
          ctx.lineTo(xAt(d.t), y);
        }
        ctx.closePath();
        ctx.fillStyle = 'rgba(68, 136, 255, 0.12)';
        ctx.fill();

        // Draw rain line
        ctx.beginPath();
        ctx.strokeStyle = '#4488ff';
        ctx.lineWidth = 2;
        for (let i = 0; i < rainData.length; i++) {
          const d = rainData[i];
          if (i === 0) ctx.moveTo(xAt(d.t), yRain(d.val)); else ctx.lineTo(xAt(d.t), yRain(d.val));
        }
        ctx.stroke();

        // Draw "now" marker
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.moveTo(mL, mT);
        ctx.lineTo(mL, mT + plotH);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#fff';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Now', mL, mT - 3);
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // PARTS UI — Assembly Parts Detail Modal
    // ═══════════════════════════════════════════════════════════════════════════════
    const PartsUI = {
      modal: null,

      init() {
        this.modal = document.getElementById('partsModal');
        const closeBtn = document.getElementById('partsClose');
        const closeBtn2 = document.getElementById('partsCloseBtn');
        const infoEl = document.getElementById('infoParts');
        if (closeBtn) closeBtn.addEventListener('click', () => this.close());
        if (closeBtn2) closeBtn2.addEventListener('click', () => this.close());
        if (infoEl) infoEl.addEventListener('click', () => this.open());
        if (this.modal) this.modal.addEventListener('click', (e) => { if (e.target === this.modal) this.close(); });
      },

      open() {
        if (this.modal) {
          this.modal.style.display = 'grid';
          this.modal.setAttribute('aria-hidden', 'false');
          this.update();
        }
      },

      close() {
        if (this.modal) {
          this.modal.style.display = 'none';
          this.modal.setAttribute('aria-hidden', 'true');
        }
      },

      isOpen() {
        return this.modal && this.modal.style.display === 'grid';
      },

      update() {
        const container = document.getElementById('partsDetailList');
        const summaryEl = document.getElementById('partsPerfSummary');
        if (!container) return;

        // Get parts from controlled car
        let parts = null;
        let controlled = null;
        if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
          controlled = MultiCarRace.cars.find(c => c.id === (typeof RaceUI !== 'undefined' ? RaceUI.controlledCarId : 1));
          if (controlled) parts = controlled.assemblyParts;
        }

        if (!parts) {
          container.innerHTML = '<div style="color:#888; text-align:center; padding:20px;">No parts data available. Start a race first.</div>';
          if (summaryEl) summaryEl.innerHTML = '';
          return;
        }

        // Performance summary by category
        if (summaryEl) {
          const categories = [
            { key: 'power', label: '⚡ Power', icon: '🔧' },
            { key: 'grip',  label: '🏎 Grip',  icon: '🏎' },
            { key: 'aero',  label: '✈ Aero',   icon: '✈' }
          ];
          let sumHtml = '';
          for (const cat of categories) {
            const mult = AssemblyParts.getMultiplier(parts, cat.key);
            const lossPct = (1 - mult) * 100;
            const color = lossPct < 1 ? '#4f4' : lossPct < 3 ? '#ff4' : '#f44';
            sumHtml += `<div style="background:#1a1e28; border-radius:8px; padding:10px; text-align:center;">
              <div style="font-size:12px; color:#aaa;">${cat.label}</div>
              <div style="font-size:20px; font-weight:900; color:${color}">${(mult * 100).toFixed(1)}%</div>
              <div style="font-size:10px; color:#666;">${lossPct > 0.05 ? '-' + lossPct.toFixed(1) + '% loss' : 'No loss'}</div>
            </div>`;
          }
          summaryEl.innerHTML = sumHtml;
        }

        // Individual parts
        let html = '';
        for (const [key, def] of Object.entries(AssemblyParts.partTypes)) {
          const part = parts[key];
          if (!part) continue;
          const cond = part.condition;
          const km = part.km;
          const maxKm = part.maxKm;
          const pct = cond.toFixed(1);
          const { mult, lossPct } = AssemblyParts.getPartImpact(parts, key);
          const color = cond > 70 ? '#4f4' : cond > 40 ? '#ff4' : '#f44';
          const barWidth = Math.max(0, Math.min(100, cond));
          const barColor = cond > 70 ? '#44ff44' : cond > 40 ? '#ffcc00' : '#ff4444';
          const lossStr = lossPct > 0.05 ? `<span style="color:#f66;">-${lossPct.toFixed(1)}% ${def.affects}</span>` : `<span style="color:#4f4;">No impact</span>`;

          html += `<div style="background:#1a1e28; border-radius:8px; padding:12px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
              <span style="font-weight:700; font-size:14px;">${def.label}</span>
              <div style="display:flex; align-items:center; gap:8px;">
                <span style="font-weight:900; font-size:16px; color:${color}">${pct}%</span>
                <button class="btn" data-replace-part="${key}" style="font-size:10px; padding:2px 8px; background:#2a4a2a; border:1px solid #4a8a4a; color:#8f8;" title="Replace with new part (Career)">🔄 Replace</button>
              </div>
            </div>
            <div style="height:6px; background:#333; border-radius:3px; overflow:hidden; margin-bottom:6px;">
              <div style="height:100%; width:${barWidth}%; background:${barColor}; border-radius:3px; transition:width 0.3s;"></div>
            </div>
            <div style="display:flex; justify-content:space-between; font-size:11px; color:#888;">
              <span>${km.toFixed(1)} / ${maxKm} km</span>
              <span>→ ${def.affects}</span>
              <span>${lossStr}</span>
            </div>
          </div>`;
        }
        container.innerHTML = html;

        // Wire up replace buttons
        container.querySelectorAll('[data-replace-part]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const partKey = e.currentTarget.dataset.replacePart;
            if (parts && confirm(`Replace ${AssemblyParts.partTypes[partKey]?.name || partKey} with a new one?`)) {
              AssemblyParts.replacePart(parts, partKey);
              this.update();
            }
          });
        });
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // CAMBER UI — Visual Camber Setup with Grip Curves
    // ═══════════════════════════════════════════════════════════════════════════════
    const CamberUI = {
      modal: null,
      slider: null,

      init() {
        if (this._initialized) return;
        this._initialized = true;
        this.modal = document.getElementById('camberModal');
        this.slider = document.getElementById('camberSlider');

        document.getElementById('camberBtn').addEventListener('click', () => this.open());
        document.getElementById('camberClose').addEventListener('click', () => this.close());
        this.modal.addEventListener('click', (e) => { if (e.target === this.modal) this.close(); });

        document.getElementById('camberReset').addEventListener('click', () => {
          this.slider.value = -4.0;
          this.updateDisplay();
        });

        document.getElementById('camberApply').addEventListener('click', () => {
          const camber = parseFloat(this.slider.value);
          CarConfig.camber = camber;
          if (SetupUI.fields && SetupUI.fields.get('camber')) {
            SetupUI.fields.get('camber').value = camber;
          }
          // Update controlled car's setup in multi-car race
          if (typeof RaceUI !== 'undefined' && typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
            const controlled = MultiCarRace.cars.find(c => c.id === RaceUI.controlledCarId);
            if (controlled) {
              controlled.setup.camber = camber;
              // Invalidate braking envelope (camber affects grip + rolling resistance)
              controlled._env = null;
              controlled._lastEnvBuildTime = -999;
            }
          }
          this.close();
        });

        this.slider.addEventListener('input', () => this.updateDisplay());
      },

      open() {
        this.slider.value = CarConfig.camber;
        this.updateDisplay();
        this.drawCurves();
        this.modal.classList.add('open');
        this.modal.setAttribute('aria-hidden', 'false');
      },

      close() {
        this.modal.classList.remove('open');
        this.modal.setAttribute('aria-hidden', 'true');
      },

      updateDisplay() {
        const camber = parseFloat(this.slider.value);
        const { kLat, kLong } = CamberModel.getFactors(camber);
        const wearFactor = CamberModel.getWearFactor(camber);
        const rrFactor = CamberModel.getRollingResistanceFactor(camber);

        document.getElementById('camberValue').textContent = camber.toFixed(1) + '°';

        const latPct = ((kLat - 1) * 100);
        const longPct = ((kLong - 1) * 100);
        const rrPct = ((rrFactor - 1) * 100);
        const latEl = document.getElementById('camberLatEffect');
        const longEl = document.getElementById('camberLongEffect');

        latEl.textContent = (latPct >= 0 ? '+' : '') + latPct.toFixed(1) + '%';
        latEl.style.color = latPct >= 0 ? '#00ff88' : '#ff6666';

        longEl.textContent = (longPct >= 0 ? '+' : '') + longPct.toFixed(1) + '%';
        longEl.style.color = longPct >= 0 ? '#00ff88' : '#ff6666';

        document.getElementById('camberWearEffect').textContent = wearFactor.toFixed(2) + '×';

        const rrEl = document.getElementById('camberRREffect');
        rrEl.textContent = '+' + rrPct.toFixed(1) + '%';
        rrEl.style.color = rrPct > 3 ? '#ff6666' : rrPct > 1 ? '#ff9944' : '#aaf';

        // Trade-off rating
        const netGrip = latPct + longPct;
        const tradeoff = document.getElementById('camberTradeoff');
        if (netGrip > 2) { tradeoff.textContent = 'CORNER FOCUSED'; tradeoff.style.color = '#00ff88'; }
        else if (netGrip > -1) { tradeoff.textContent = 'BALANCED'; tradeoff.style.color = '#00d4ff'; }
        else if (netGrip > -4) { tradeoff.textContent = 'SPEED FOCUSED'; tradeoff.style.color = '#ffcc00'; }
        else { tradeoff.textContent = 'EXTREME SPEED'; tradeoff.style.color = '#ff6666'; }

        this.drawCurves();
      },

      drawCurves() {
        const canvas = document.getElementById('camberCurveCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        const padL = 45, padR = 15, padT = 15, padB = 30;
        const plotW = W - padL - padR, plotH = H - padT - padB;

        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 8; i++) {
          const x = padL + (plotW * i / 8);
          ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, padT + plotH); ctx.stroke();
        }
        for (let i = 0; i <= 4; i++) {
          const y = padT + (plotH * i / 4);
          ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(padL + plotW, y); ctx.stroke();
        }

        // Draw kLat curve (green)
        ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 2.5; ctx.setLineDash([]);
        ctx.beginPath();
        for (let c = -40; c <= 0; c++) {
          const camber = c / 10;
          const { kLat } = CamberModel.getFactors(camber);
          const x = padL + ((camber + 4) / 4) * plotW;
          const y = padT + plotH - ((kLat - 0.88) / 0.20) * plotH;
          c === -40 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Draw kLong curve (red, dashed)
        ctx.strokeStyle = '#ff6666'; ctx.lineWidth = 2; ctx.setLineDash([6, 4]);
        ctx.beginPath();
        for (let c = -40; c <= 0; c++) {
          const camber = c / 10;
          const { kLong } = CamberModel.getFactors(camber);
          const x = padL + ((camber + 4) / 4) * plotW;
          const y = padT + plotH - ((kLong - 0.88) / 0.20) * plotH;
          c === -40 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw kRR curve (orange, dotted)
        ctx.strokeStyle = '#ff9944'; ctx.lineWidth = 2; ctx.setLineDash([3, 3]);
        ctx.beginPath();
        for (let c = -40; c <= 0; c++) {
          const camber = c / 10;
          const kRR = CamberModel.getRollingResistanceFactor(camber);
          const x = padL + ((camber + 4) / 4) * plotW;
          const y = padT + plotH - ((kRR - 0.88) / 0.20) * plotH;
          c === -40 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        // 1.0 reference line
        const refY = padT + plotH - ((1.0 - 0.88) / 0.20) * plotH;
        ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.lineWidth = 1; ctx.setLineDash([3, 3]);
        ctx.beginPath(); ctx.moveTo(padL, refY); ctx.lineTo(padL + plotW, refY); ctx.stroke();
        ctx.setLineDash([]);

        // Current position marker
        const currentCamber = parseFloat(this.slider.value);
        const markerX = padL + ((currentCamber + 4) / 4) * plotW;
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]);
        ctx.beginPath(); ctx.moveTo(markerX, padT); ctx.lineTo(markerX, padT + plotH); ctx.stroke();
        ctx.setLineDash([]);

        const { kLat: cKLat, kLong: cKLong } = CamberModel.getFactors(currentCamber);
        const cKRR = CamberModel.getRollingResistanceFactor(currentCamber);
        ctx.fillStyle = '#00ff88';
        ctx.beginPath(); ctx.arc(markerX, padT + plotH - ((cKLat - 0.88) / 0.20) * plotH, 5, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#ff6666';
        ctx.beginPath(); ctx.arc(markerX, padT + plotH - ((cKLong - 0.88) / 0.20) * plotH, 5, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#ff9944';
        ctx.beginPath(); ctx.arc(markerX, padT + plotH - ((cKRR - 0.88) / 0.20) * plotH, 4, 0, Math.PI * 2); ctx.fill();

        // Labels
        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.font = '10px system-ui';
        ctx.fillText('-4.0°', padL - 5, padT + plotH + 15);
        ctx.fillText('0°', padL + plotW - 5, padT + plotH + 15);
        ctx.fillText('Camber →', padL + plotW/2 - 20, padT + plotH + 26);

        // Legend
        ctx.fillStyle = '#00ff88'; ctx.fillText('● Lateral (Corners)', padL + 5, padT + 10);
        ctx.fillStyle = '#ff6666'; ctx.fillText('● Longitudinal (Straights)', padL + 130, padT + 10);
        ctx.fillStyle = '#ff9944'; ctx.fillText('● Rolling Resistance', padL + 300, padT + 10);
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // AERO UI — Wing Angle Setup with Downforce/Drag Visualization
    // ═══════════════════════════════════════════════════════════════════════════════
    const AeroUI = {
      modal: null,
      slider: null,

      init() {
        if (this._initialized) return;
        this._initialized = true;
        this.modal = document.getElementById('aeroModal');
        this.slider = document.getElementById('wingSlider');

        document.getElementById('aeroBtn').addEventListener('click', () => this.open());
        document.getElementById('aeroClose').addEventListener('click', () => this.close());
        this.modal.addEventListener('click', (e) => { if (e.target === this.modal) this.close(); });

        document.getElementById('aeroReset').addEventListener('click', () => {
          this.slider.value = 10.0;
          this.updateDisplay();
        });

        document.getElementById('aeroApply').addEventListener('click', () => {
          const wingAngle = parseFloat(this.slider.value);
          CarConfig.wingAngle = wingAngle;
          if (SetupUI.fields && SetupUI.fields.get('wingAngle')) {
            SetupUI.fields.get('wingAngle').value = wingAngle;
          }
          this.close();
        });

        this.slider.addEventListener('input', () => this.updateDisplay());
      },

      open() {
        this.slider.value = CarConfig.wingAngle;
        this.updateDisplay();
        this.drawCurves();
        this.modal.classList.add('open');
        this.modal.setAttribute('aria-hidden', 'false');
      },

      close() {
        this.modal.classList.remove('open');
        this.modal.setAttribute('aria-hidden', 'true');
      },

      updateDisplay() {
        const wingAngle = parseFloat(this.slider.value);
        const { kLift, kDrag, liftBonusPct, dragPenaltyPct } = AeroModel.getFactors(wingAngle);

        document.getElementById('aeroValue').textContent = wingAngle.toFixed(1) + '°';

        const liftEl = document.getElementById('aeroLiftEffect');
        liftEl.textContent = '+' + liftBonusPct.toFixed(1) + '%';
        liftEl.style.color = liftBonusPct > 15 ? '#00ff88' : (liftBonusPct > 8 ? '#88ffaa' : '#aaddbb');

        const dragEl = document.getElementById('aeroDragEffect');
        dragEl.textContent = '+' + dragPenaltyPct.toFixed(1) + '%';
        dragEl.style.color = dragPenaltyPct > 25 ? '#ff4444' : (dragPenaltyPct > 12 ? '#ff8844' : '#ffcc00');

        // Top speed estimate: v_max ∝ 1/sqrt(cDrag), so penalty ≈ -(dragPct/2)%
        const topSpeedDelta = -(dragPenaltyPct / 2);
        const tsEl = document.getElementById('aeroTopSpeedEffect');
        tsEl.textContent = topSpeedDelta.toFixed(1) + ' km/h (est.)';
        tsEl.style.color = topSpeedDelta < -5 ? '#ff6666' : '#ffcc00';

        // Balance assessment
        const bal = document.getElementById('aeroBalance');
        if (wingAngle < 5) { bal.textContent = 'LOW DOWNFORCE'; bal.style.color = '#ff6666'; }
        else if (wingAngle < 8) { bal.textContent = 'SPEED FOCUSED'; bal.style.color = '#ffcc00'; }
        else if (wingAngle < 13) { bal.textContent = 'BALANCED'; bal.style.color = '#00d4ff'; }
        else if (wingAngle < 17) { bal.textContent = 'GRIP FOCUSED'; bal.style.color = '#00ff88'; }
        else { bal.textContent = 'MAX DOWNFORCE'; bal.style.color = '#00ff88'; }

        this.drawCurves();
      },

      drawCurves() {
        const canvas = document.getElementById('aeroCurveCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        const padL = 45, padR = 15, padT = 15, padB = 30;
        const plotW = W - padL - padR, plotH = H - padT - padB;

        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
        for (let i = 0; i <= 10; i++) {
          const x = padL + (plotW * i / 10);
          ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, padT + plotH); ctx.stroke();
        }
        for (let i = 0; i <= 4; i++) {
          const y = padT + (plotH * i / 4);
          ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(padL + plotW, y); ctx.stroke();
        }

        // Scale: 0% to 50% (Y-axis)
        const yScale = (pct) => padT + plotH - (pct / 50) * plotH;

        // Draw Downforce curve (green, solid)
        ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 2.5; ctx.setLineDash([]);
        ctx.beginPath();
        for (let a = 0; a <= 250; a++) {
          const angle = a / 10;
          const { liftBonusPct } = AeroModel.getFactors(angle);
          const x = padL + (angle / 25) * plotW;
          const y = yScale(liftBonusPct);
          a === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Draw Drag curve (red, dashed)
        ctx.strokeStyle = '#ff6666'; ctx.lineWidth = 2; ctx.setLineDash([6, 4]);
        ctx.beginPath();
        for (let a = 0; a <= 250; a++) {
          const angle = a / 10;
          const { dragPenaltyPct } = AeroModel.getFactors(angle);
          const x = padL + (angle / 25) * plotW;
          const y = yScale(dragPenaltyPct);
          a === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        // Current position marker
        const currentAngle = parseFloat(this.slider.value);
        const markerX = padL + (currentAngle / 25) * plotW;

        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]);
        ctx.beginPath(); ctx.moveTo(markerX, padT); ctx.lineTo(markerX, padT + plotH); ctx.stroke();
        ctx.setLineDash([]);

        const { liftBonusPct, dragPenaltyPct } = AeroModel.getFactors(currentAngle);
        ctx.fillStyle = '#00ff88';
        ctx.beginPath(); ctx.arc(markerX, yScale(liftBonusPct), 5, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#ff6666';
        ctx.beginPath(); ctx.arc(markerX, yScale(dragPenaltyPct), 5, 0, Math.PI * 2); ctx.fill();

        // Labels
        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.font = '10px system-ui';
        ctx.fillText('0°', padL - 5, padT + plotH + 15);
        ctx.fillText('25°', padL + plotW - 10, padT + plotH + 15);
        ctx.fillText('Wing Angle →', padL + plotW/2 - 30, padT + plotH + 26);
        ctx.fillText(`Current: ${currentAngle.toFixed(1)}°`, markerX - 35, padT + plotH + 30);

        // Legend
        ctx.fillStyle = '#00ff88'; ctx.fillText('● Downforce', padL + 5, padT + 10);
        ctx.fillStyle = '#ff6666'; ctx.fillText('● Drag', padL + 100, padT + 10);
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // PLATFORM UI — Suspension Setup with 3 Graphs
    // ═══════════════════════════════════════════════════════════════════════════════
    const PlatformUI = {
      modal: null,
      factorsCanvas: null,
      heightCanvas: null,
      aeroMapCanvas: null,
      _previewSimResults: [],
      _previewSetup: null,
      _selectedSpeedKmh: null,  // null = no selection, show prompt

      presets: {
        lowDf:     { rideHeight: 0.045, springK: 100000, damperC: 4000 },
        balanced:  { rideHeight: 0.035, springK: 180000, damperC: 5500 },
        highDf:    { rideHeight: 0.025, springK: 200000, damperC: 7000 },
        wet:       { rideHeight: 0.040, springK: 120000, damperC: 6000 }
      },

      init() {
        if (this._initialized) return;
        this._initialized = true;
        this.modal = document.getElementById('platformModal');
        this.factorsCanvas = document.getElementById('platformFactorsCanvas');
        this.heightCanvas = document.getElementById('platformHeightCanvas');
        this.aeroMapCanvas = document.getElementById('platformAeroMapCanvas');

        document.getElementById('platformBtn').addEventListener('click', () => this.open());
        document.getElementById('platformClose').addEventListener('click', () => this.close());
        this.modal.addEventListener('click', (e) => { if (e.target === this.modal) this.close(); });

        // Sliders
        const rh = document.getElementById('platformRideHeight');
        const sk = document.getElementById('platformSpringK');
        const dc = document.getElementById('platformDamperC');

        rh.addEventListener('input', () => this.onSliderChange());
        sk.addEventListener('input', () => this.onSliderChange());
        dc.addEventListener('input', () => this.onSliderChange());

        // Click-to-select-speed on factor & height canvases
        const handleCanvasClick = (canvas, padL, padR) => {
          canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const px = (e.clientX - rect.left) * scaleX;
            const plotW = canvas.width - padL - padR;
            const ratio = Math.max(0, Math.min(1, (px - padL) / plotW));
            this._selectedSpeedKmh = Math.round(ratio * 400 / 5) * 5; // snap to 5 km/h
            this.updateSummary();
            this.drawAllGraphs();
          });
          canvas.style.cursor = 'crosshair';
        };
        handleCanvasClick(this.factorsCanvas, 35, 10);
        handleCanvasClick(this.heightCanvas, 35, 10);

        // Presets
        document.getElementById('platformPresetLowDf').addEventListener('click', () => this.applyPreset('lowDf'));
        document.getElementById('platformPresetBalanced').addEventListener('click', () => this.applyPreset('balanced'));
        document.getElementById('platformPresetHighDf').addEventListener('click', () => this.applyPreset('highDf'));
        document.getElementById('platformPresetWet').addEventListener('click', () => this.applyPreset('wet'));

        // Apply
        document.getElementById('platformApply').addEventListener('click', () => {
          const setup = this.getSliderSetup();
          CarConfig.rideHeight = setup.rideHeight;
          CarConfig.springK = setup.springK;
          CarConfig.damperC = setup.damperC;
          // Update SetupUI fields
          if (SetupUI.fields) {
            const rhField = SetupUI.fields.get('rideHeight');
            const skField = SetupUI.fields.get('springK');
            const dcField = SetupUI.fields.get('damperC');
            if (rhField) rhField.value = setup.rideHeight * 1000; // mm display
            if (skField) skField.value = setup.springK / 1000;    // kN/m display
            if (dcField) dcField.value = setup.damperC / 1000;    // kN·s/m display
          }
          // Rebuild global lookup table
          Platform.buildLookupTable(setup);
          // Also update the controlled car's per-car lookup during a race
          if (typeof RaceUI !== 'undefined' && typeof MultiCarRace !== 'undefined') {
            const controlled = MultiCarRace.cars.find(c => c.id === RaceUI.controlledCarId);
            if (controlled) {
              controlled.setup.rideHeight = setup.rideHeight;
              controlled.setup.springK = setup.springK;
              controlled.setup.damperC = setup.damperC;
              controlled.rebuildPlatformLookup();
              // Invalidate braking envelope
              controlled._env = null;
              controlled._lastEnvBuildTime = -999;
              controlled._envPit = null;
              controlled._lastPitEnvBuildTime = -999;
            }
          }
          this.close();
        });
      },

      getSliderSetup() {
        return {
          rideHeight: parseFloat(document.getElementById('platformRideHeight').value) / 1000, // mm → m
          springK: parseFloat(document.getElementById('platformSpringK').value) * 1000,       // kN/m → N/m
          damperC: parseFloat(document.getElementById('platformDamperC').value) * 1000         // kN·s/m → N·s/m
        };
      },

      applyPreset(name) {
        const p = this.presets[name];
        if (!p) return;
        document.getElementById('platformRideHeight').value = p.rideHeight * 1000;
        document.getElementById('platformSpringK').value = p.springK / 1000;
        document.getElementById('platformDamperC').value = p.damperC / 1000;
        this.onSliderChange();
      },

      onSliderChange() {
        const setup = this.getSliderSetup();
        // Update value labels
        document.getElementById('platformRhVal').textContent = (setup.rideHeight * 1000).toFixed(0) + ' mm';
        document.getElementById('platformSkVal').textContent = (setup.springK / 1000).toFixed(0) + ' N/mm';
        document.getElementById('platformDcVal').textContent = (setup.damperC / 1000).toFixed(1) + ' Ns/mm';

        // Run simulation preview
        this.runPreview(setup);
      },

      runPreview(setup) {
        this._previewSetup = setup;
        this._previewSimResults = [];

        // Simulate for each speed point (0-400 km/h in 10 km/h steps for preview)
        for (let kmh = 0; kmh <= 400; kmh += 5) {
          const v = kmh / 3.6;
          if (typeof Platform.computeAtSpeed === 'function') {
            const result = Platform.computeAtSpeed(v, setup);
            this._previewSimResults.push({ kmh, v, ...result });
          }
        }

        this.updateSummary();
        this.drawAllGraphs();
      },

      updateSummary() {
        if (this._previewSimResults.length === 0) return;

        const aeroEl = document.getElementById('platformAeroVal');
        const gripEl = document.getElementById('platformGripVal');
        const dragEl = document.getElementById('platformDragVal');
        const wearEl = document.getElementById('platformWearVal');
        const speedLabel = document.getElementById('platformSpeedLabel');

        if (this._selectedSpeedKmh == null) {
          // No speed selected — show prompt
          speedLabel.textContent = '👆 Click a graph to select speed';
          speedLabel.style.color = 'rgba(255,255,255,0.5)';
          aeroEl.textContent = '—'; aeroEl.style.color = 'rgba(255,255,255,0.3)';
          gripEl.textContent = '—'; gripEl.style.color = 'rgba(255,255,255,0.3)';
          dragEl.textContent = '—'; dragEl.style.color = 'rgba(255,255,255,0.3)';
          wearEl.textContent = '—'; wearEl.style.color = 'rgba(255,255,255,0.3)';
          return;
        }

        // Find closest data point to selected speed
        const target = this._selectedSpeedKmh;
        let best = this._previewSimResults[0];
        let bestDist = Math.abs(best.kmh - target);
        for (const r of this._previewSimResults) {
          const d = Math.abs(r.kmh - target);
          if (d < bestDist) { best = r; bestDist = d; }
        }

        speedLabel.textContent = `📍 @ ${best.kmh} km/h`;
        speedLabel.style.color = '#fff';

        const kAero = best.kAero || 1;
        const kMech = best.kMech || 1;
        const kDrag = best.kDrag || 1;
        const kWear = best.kWear || 1;

        aeroEl.textContent = (kAero * 100).toFixed(1) + '%';
        aeroEl.style.color = kAero >= 1.1 ? '#00ff88' : (kAero >= 0.95 ? '#ffcc00' : '#ff6666');

        gripEl.textContent = (kMech * 100).toFixed(1) + '%';
        gripEl.style.color = kMech >= 0.98 ? '#00ff88' : (kMech >= 0.93 ? '#ffcc00' : '#ff6666');

        dragEl.textContent = (kDrag * 100).toFixed(1) + '%';
        dragEl.style.color = kDrag <= 0.92 ? '#00ff88' : (kDrag <= 1.0 ? '#ffcc00' : '#ff6666');

        wearEl.textContent = kWear.toFixed(2) + '×';
        wearEl.style.color = kWear <= 1.02 ? '#00ff88' : (kWear <= 1.10 ? '#ffcc00' : '#ff6666');
      },

      open() {
        // Load current values into sliders
        document.getElementById('platformRideHeight').value = CarConfig.rideHeight * 1000;
        document.getElementById('platformSpringK').value = CarConfig.springK / 1000;
        document.getElementById('platformDamperC').value = CarConfig.damperC / 1000;
        this._selectedSpeedKmh = 200;  // default selection
        this.onSliderChange();
        this.modal.classList.add('open');
        this.modal.setAttribute('aria-hidden', 'false');
      },

      close() {
        this.modal.classList.remove('open');
        this.modal.setAttribute('aria-hidden', 'true');
      },

      drawAllGraphs() {
        this.drawFactorsGraph();
        this.drawHeightGraph();
        this.drawAeroMap();
      },

      drawFactorsGraph() {
        const canvas = this.factorsCanvas;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        const padL = 35, padR = 10, padT = 12, padB = 25;
        const plotW = W - padL - padR, plotH = H - padT - padB;
        const data = this._previewSimResults;
        if (!data.length) return;

        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
          const x = padL + plotW * i / 4;
          ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, padT + plotH); ctx.stroke();
          ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.font = '9px system-ui';
          ctx.fillText((i * 100) + '', x - 8, padT + plotH + 12);
        }

        // Y axis: 0.4 to 1.6
        const yMin = 0.4, yMax = 1.6;
        const yMap = (val) => padT + plotH - ((val - yMin) / (yMax - yMin)) * plotH;

        // 1.0 reference
        ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.setLineDash([3, 3]);
        ctx.beginPath(); ctx.moveTo(padL, yMap(1.0)); ctx.lineTo(padL + plotW, yMap(1.0)); ctx.stroke();
        ctx.setLineDash([]);

        // kAero curve (green)
        ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 2;
        ctx.beginPath();
        data.forEach((d, i) => {
          const x = padL + (d.kmh / 400) * plotW;
          const y = yMap(d.kAero || 1);
          i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();

        // kMech curve (cyan)
        ctx.strokeStyle = '#00d4ff'; ctx.lineWidth = 2;
        ctx.beginPath();
        data.forEach((d, i) => {
          const x = padL + (d.kmh / 400) * plotW;
          const y = yMap(d.kMech || 1);
          i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();

        // kDrag curve (red, dashed)
        ctx.strokeStyle = '#ff6666'; ctx.lineWidth = 1.5; ctx.setLineDash([5, 3]);
        ctx.beginPath();
        data.forEach((d, i) => {
          const x = padL + (d.kmh / 400) * plotW;
          const y = yMap(d.kDrag || 1);
          i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);

        // kWear curve (orange, dotted)
        ctx.strokeStyle = '#ff8800'; ctx.lineWidth = 1.5; ctx.setLineDash([2, 3]);
        ctx.beginPath();
        data.forEach((d, i) => {
          const x = padL + (d.kmh / 400) * plotW;
          const y = yMap(d.kWear || 1);
          i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);

        // Selected speed marker
        if (this._selectedSpeedKmh != null) {
          const mx = padL + (this._selectedSpeedKmh / 400) * plotW;
          ctx.strokeStyle = 'rgba(255,255,255,0.7)'; ctx.lineWidth = 1.5; ctx.setLineDash([3, 3]);
          ctx.beginPath(); ctx.moveTo(mx, padT); ctx.lineTo(mx, padT + plotH); ctx.stroke();
          ctx.setLineDash([]);
          // Dot highlights
          const sel = this._previewSimResults.find(d => d.kmh === this._selectedSpeedKmh);
          if (sel) {
            ctx.fillStyle = '#00ff88';
            ctx.beginPath(); ctx.arc(mx, yMap(sel.kAero || 1), 4.5, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#00d4ff';
            ctx.beginPath(); ctx.arc(mx, yMap(sel.kMech || 1), 4.5, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#ff6666';
            ctx.beginPath(); ctx.arc(mx, yMap(sel.kDrag || 1), 4.5, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#ff8800';
            ctx.beginPath(); ctx.arc(mx, yMap(sel.kWear || 1), 4.5, 0, Math.PI * 2); ctx.fill();
          }
          // Speed label at top
          ctx.fillStyle = '#fff'; ctx.font = 'bold 10px system-ui';
          ctx.fillText(this._selectedSpeedKmh + ' km/h', mx + 4, padT + 10);
        }

        // Legend
        ctx.font = '9px system-ui';
        ctx.fillStyle = '#00ff88'; ctx.fillText('Aero', padL + 2, padT + 9);
        ctx.fillStyle = '#00d4ff'; ctx.fillText('Grip', padL + 35, padT + 9);
        ctx.fillStyle = '#ff6666'; ctx.fillText('Drag', padL + 65, padT + 9);
        ctx.fillStyle = '#ff8800'; ctx.fillText('Wear', padL + 95, padT + 9);
        ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillText('km/h →', padL + plotW / 2 - 15, padT + plotH + 22);
      },

      drawHeightGraph() {
        const canvas = this.heightCanvas;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        const padL = 35, padR = 10, padT = 12, padB = 25;
        const plotW = W - padL - padR, plotH = H - padT - padB;
        const data = this._previewSimResults;
        if (!data.length) return;

        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
          const x = padL + plotW * i / 4;
          ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, padT + plotH); ctx.stroke();
          ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.font = '9px system-ui';
          ctx.fillText((i * 100) + '', x - 8, padT + plotH + 12);
        }

        // Y axis: 0 to 60mm
        const yMax = 60;
        const yMap = (mm) => padT + plotH - (mm / yMax) * plotH;

        // Mean ride height curve (cyan)
        ctx.strokeStyle = '#00d4ff'; ctx.lineWidth = 2;
        ctx.beginPath();
        data.forEach((d, i) => {
          const x = padL + (d.kmh / 400) * plotW;
          const hMm = d.hMean || (this._previewSetup?.rideHeight || 0.035) * 1000;
          const y = yMap(hMm);
          i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();

        // Fluctuation band (fill)
        if (data.some(d => d.X != null && d.X > 0)) {
          ctx.fillStyle = 'rgba(0,212,255,0.12)';
          ctx.beginPath();
          data.forEach((d, i) => {
            const x = padL + (d.kmh / 400) * plotW;
            const hMm = d.hMean || 35;
            const fluct = d.X || 0;
            const y = yMap(hMm + fluct);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          });
          for (let i = data.length - 1; i >= 0; i--) {
            const d = data[i];
            const x = padL + (d.kmh / 400) * plotW;
            const hMm = d.hMean || 35;
            const fluct = d.X || 0;
            ctx.lineTo(x, yMap(hMm - fluct));
          }
          ctx.fill();
        }

        // Bottoming line at 1mm
        ctx.strokeStyle = 'rgba(255,68,68,0.5)'; ctx.lineWidth = 1; ctx.setLineDash([4, 4]);
        ctx.beginPath(); ctx.moveTo(padL, yMap(1)); ctx.lineTo(padL + plotW, yMap(1)); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#ff4444'; ctx.font = '8px system-ui'; ctx.fillText('Bottoming', padL + 2, yMap(1) - 3);

        // Selected speed marker
        if (this._selectedSpeedKmh != null) {
          const mx = padL + (this._selectedSpeedKmh / 400) * plotW;
          ctx.strokeStyle = 'rgba(255,255,255,0.7)'; ctx.lineWidth = 1.5; ctx.setLineDash([3, 3]);
          ctx.beginPath(); ctx.moveTo(mx, padT); ctx.lineTo(mx, padT + plotH); ctx.stroke();
          ctx.setLineDash([]);
          const sel = this._previewSimResults.find(d => d.kmh === this._selectedSpeedKmh);
          if (sel) {
            const hMm = sel.hMean || 35;
            ctx.fillStyle = '#00d4ff';
            ctx.beginPath(); ctx.arc(mx, yMap(hMm), 4.5, 0, Math.PI * 2); ctx.fill();
          }
        }

        // Legend
        ctx.fillStyle = '#00d4ff'; ctx.font = '9px system-ui'; ctx.fillText('Ride Height', padL + 2, padT + 9);
        ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillText('km/h →', padL + plotW / 2 - 15, padT + plotH + 22);
      },

      drawAeroMap() {
        const canvas = this.aeroMapCanvas;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        const padL = 45, padR = 15, padT = 12, padB = 25;
        const plotW = W - padL - padR, plotH = H - padT - padB;

        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
        for (let i = 0; i <= 10; i++) {
          const x = padL + plotW * i / 10;
          ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, padT + plotH); ctx.stroke();
        }

        // Draw aero efficiency vs ride height (0-60mm)
        const yMin = 0.3, yMax = 1.6;
        const yMap = (val) => padT + plotH - ((val - yMin) / (yMax - yMin)) * plotH;

        // kAero curve from Platform aero model
        ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 2.5;
        ctx.beginPath();
        for (let h = 0; h <= 60; h++) {
          const hMeters = h / 1000;
          let kAero = 1.0;
          if (typeof Platform.getAeroEfficiency === 'function') {
            kAero = Platform.getAeroEfficiency(hMeters);
          }
          const x = padL + (h / 60) * plotW;
          const y = yMap(kAero);
          h === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Drag curve
        ctx.strokeStyle = '#ff6666'; ctx.lineWidth = 1.5; ctx.setLineDash([5, 3]);
        ctx.beginPath();
        for (let h = 0; h <= 60; h++) {
          const hMeters = h / 1000;
          let kDrag = 1.0;
          if (typeof Platform.getDragEfficiency === 'function') {
            kDrag = Platform.getDragEfficiency(hMeters);
          }
          const x = padL + (h / 60) * plotW;
          const y = yMap(kDrag);
          h === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        // ─── Ride Height Variance Band ───
        // If a speed is selected, show the oscillation range at that speed as a blue band.
        // Otherwise show the band for a representative speed (200 km/h).
        const data = this._previewSimResults;
        let bandCenter = (this._previewSetup?.rideHeight || CarConfig.rideHeight) * 1000;
        let bandHalf = 0;
        if (data.length > 0) {
          const targetKmh = this._selectedSpeedKmh != null ? this._selectedSpeedKmh : 200;
          let bestPt = data[0];
          let bestD = Math.abs(bestPt.kmh - targetKmh);
          for (const r of data) { const d2 = Math.abs(r.kmh - targetKmh); if (d2 < bestD) { bestPt = r; bestD = d2; } }
          bandCenter = bestPt.hMean || bandCenter;
          bandHalf = bestPt.X || 0;  // X = fluctuation amplitude in mm
        }
        const bandLo = Math.max(0, bandCenter - bandHalf);
        const bandHi = Math.min(60, bandCenter + bandHalf);
        // Draw band
        const bxL = padL + (bandLo / 60) * plotW;
        const bxR = padL + (bandHi / 60) * plotW;
        ctx.fillStyle = 'rgba(0,180,255,0.13)';
        ctx.fillRect(bxL, padT, bxR - bxL, plotH);
        // Band edge lines
        ctx.strokeStyle = 'rgba(0,180,255,0.35)'; ctx.lineWidth = 1; ctx.setLineDash([4, 3]);
        ctx.beginPath(); ctx.moveTo(bxL, padT); ctx.lineTo(bxL, padT + plotH); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(bxR, padT); ctx.lineTo(bxR, padT + plotH); ctx.stroke();
        ctx.setLineDash([]);
        // Band label
        ctx.fillStyle = 'rgba(0,180,255,0.6)'; ctx.font = '8px system-ui';
        const bandLabelKmh = this._selectedSpeedKmh != null ? this._selectedSpeedKmh : 200;
        ctx.fillText(`h @ ${bandLabelKmh} km/h`, bxL + 2, padT + plotH - 3);

        // Current static ride height marker (white dashed)
        const rhMm = (this._previewSetup?.rideHeight || CarConfig.rideHeight) * 1000;
        const markerX = padL + (rhMm / 60) * plotW;
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]);
        ctx.beginPath(); ctx.moveTo(markerX, padT); ctx.lineTo(markerX, padT + plotH); ctx.stroke();
        ctx.setLineDash([]);

        // Mean ride height marker (solid cyan)
        const meanX = padL + (bandCenter / 60) * plotW;
        ctx.strokeStyle = '#00d4ff'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(meanX, padT); ctx.lineTo(meanX, padT + plotH); ctx.stroke();

        // Reference line at 1.0
        ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.setLineDash([3, 3]);
        ctx.beginPath(); ctx.moveTo(padL, yMap(1.0)); ctx.lineTo(padL + plotW, yMap(1.0)); ctx.stroke();
        ctx.setLineDash([]);

        // Labels
        ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.font = '9px system-ui';
        ctx.fillText('0mm', padL - 5, padT + plotH + 14);
        ctx.fillText('60mm', padL + plotW - 15, padT + plotH + 14);
        ctx.fillText('Ride Height →', padL + plotW/2 - 25, padT + plotH + 24);

        ctx.fillStyle = '#00ff88'; ctx.fillText('● Aero Eff.', padL + 2, padT + 9);
        ctx.fillStyle = '#ff6666'; ctx.fillText('● Drag', padL + 75, padT + 9);
        ctx.fillStyle = '#00d4ff'; ctx.fillText('● h range', padL + 115, padT + 9);
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // CONTROLS
    // ═══════════════════════════════════════════════════════════════════════════════
    document.getElementById('startBtn').addEventListener('click', () => {
      // Clients can't pause/start the simulation — only the server controls it
      if (Multiplayer.isMultiplayerRace && !Multiplayer.isHost) return;
      
      // ── First start: run countdown with sounds ──
      if (!Simulation.running && typeof RaceUI !== 'undefined' && !RaceUI._raceStarted && MultiCarRace.isActive) {
        RaceUI._raceStarted = true;
        const btn = document.getElementById('startBtn');
        btn.textContent = '⏳ COUNTDOWN';
        btn.disabled = true;
        
        Countdown.start(() => {
          Simulation.running = true;
          Simulation.lastFrameTime = performance.now();
          btn.textContent = '⏸ PAUSE';
          btn.classList.remove('primary');
          btn.disabled = false;

          // Start rain sound if wet
          if (Weather.wetness > 0.05) SoundEngine.startRain();
        });
        return;
      }

      Simulation.running = !Simulation.running;
      const btn = document.getElementById('startBtn');

      if (Simulation.running) {
        btn.textContent = '⏸ PAUSE';
        btn.classList.remove('primary');
        Simulation.lastFrameTime = performance.now();
      } else {
        btn.textContent = '▶ START';
        btn.classList.add('primary');
      }
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      Simulation.reset();
      Renderer.centerTrack();
      document.getElementById('startBtn').textContent = '▶ START';
      document.getElementById('startBtn').classList.add('primary');
    });

    document.querySelectorAll('.speed-btn[data-speed]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.speed-btn[data-speed]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        Simulation.speed = parseFloat(btn.dataset.speed);
      });
    });

    // PIT: Combined button - toggles arm on track, exits when in box
    // In MULTIPLAYER: sends command to server instead of modifying state directly
    document.getElementById('pitBtn').addEventListener('click', () => {
      // Get the controlled car's pit state
      let pitState = Car.pit;
      let controlled = null;
      
      if (typeof MultiCarRace !== 'undefined' && MultiCarRace.isActive) {
        const controlledId = typeof RaceUI !== 'undefined' ? RaceUI.controlledCarId : 1;
        controlled = MultiCarRace.cars.find(c => c.id === controlledId);
        if (controlled) {
          pitState = controlled.pit;
        }
      }
      
      const inBox = pitState.inLane && pitState.phase === 'stopped';
      
      // ── MULTIPLAYER: Send commands to server ──
      if (Multiplayer.isMultiplayerRace) {
        if (inBox) {
          Multiplayer.sendCommand('cmd_pit_exit');
        } else if (pitState.inLane) {
          return; // Can't toggle while in pit lane
        } else if (pitState.armed) {
          Multiplayer.sendCommand('cmd_pit_cancel');
        } else {
          Multiplayer.sendCommand('cmd_pit_arm');
        }
        UI.syncPitButtons();
        return;
      }
      
      // ── SINGLE-PLAYER: Direct state modification ──
      if (inBox) {
        pitState.exitRequested = true;
        Car.pit.exitRequested = true;
        UI.syncPitButtons();
        return;
      }
      
      if (pitState.inLane) return;

      pitState.armed = !pitState.armed;
      if (!pitState.armed) {
        pitState.committed = false;
        pitState.phase = 'none';
      } else {
        pitState.phase = 'approach';
      }
      
      Car.pit.armed = pitState.armed;
      Car.pit.committed = pitState.committed;
      Car.pit.phase = pitState.phase;
      
      UI.syncPitButtons();
    });

    document.getElementById('liftCoastBtn').addEventListener('click', () => {
      LiftCoast.toggle();
    });

    // ═══════════════════════════════════════════════════════════════════════════════
    // GAME LOOP
    // ═══════════════════════════════════════════════════════════════════════════════
    // ═══════════════════════════════════════════════════════════════════════════════
    // SOUND ENGINE — Web Audio API Synthesized Sounds
    // ═══════════════════════════════════════════════════════════════════════════════
    const SoundEngine = {
      ctx: null,
      masterGain: null,
      volume: 0.35,
      _initialized: false,

      init() {
        if (this._initialized) return;
        try {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          this.masterGain = this.ctx.createGain();
          this.masterGain.gain.value = this.volume;
          this.masterGain.connect(this.ctx.destination);
          this._initialized = true;
        } catch (e) {
          console.warn('[SoundEngine] Web Audio not available:', e.message);
        }
      },

      resume() {
        if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
      },

      playCountdownBeep(final) {
        if (final) {
          this._playTone(880, 0.25, 'sine', 0.28);
          setTimeout(() => this._playTone(1760, 0.2, 'sine', 0.22), 60);
        } else {
          this._playTone(600, 0.15, 'sine', 0.22);
        }
      },

      // ── Utility: play a simple tone ──
      _playTone(freq, duration, type, volume) {
        if (!this._initialized) return;
        this.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type || 'sine';
        osc.frequency.value = freq;
        gain.gain.value = volume || 0.15;
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        gain.gain.setTargetAtTime(0, this.ctx.currentTime + duration * 0.7, duration * 0.15);
        osc.stop(this.ctx.currentTime + duration + 0.1);
      },

      // ── RAIN SOUND ──
      _rainNoise: null,
      _rainGain: null,
      startRain() {
        if (!this._initialized || this._rainNoise) return;
        this.resume();
        const bufSize = this.ctx.sampleRate * 3;
        const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        let b0 = 0, b1 = 0, b2 = 0;
        for (let i = 0; i < bufSize; i++) {
          const w = Math.random() * 2 - 1;
          b0 = 0.99886 * b0 + w * 0.0555179;
          b1 = 0.99332 * b1 + w * 0.0750759;
          b2 = 0.96900 * b2 + w * 0.1538520;
          data[i] = (b0 + b1 + b2 + w * 0.5362) * 0.11;
        }
        this._rainNoise = this.ctx.createBufferSource();
        this._rainNoise.buffer = buf;
        this._rainNoise.loop = true;
        this._rainGain = this.ctx.createGain();
        this._rainGain.gain.value = 0;
        this._rainNoise.connect(this._rainGain);
        this._rainGain.connect(this.masterGain);
        this._rainNoise.start();
      },

      updateRain(wetness) {
        if (!this._rainGain) return;
        const vol = wetness * 0.12;
        this._rainGain.gain.setTargetAtTime(vol, this.ctx.currentTime, 0.3);
        const overlay = document.getElementById('rainOverlay');
        if (overlay) overlay.classList.toggle('active', wetness > 0.05);
      },

      stopRain() {
        try { if (this._rainNoise) this._rainNoise.stop(); } catch (_) {}
        this._rainNoise = null;
        this._rainGain = null;
        const overlay = document.getElementById('rainOverlay');
        if (overlay) overlay.classList.remove('active');
      },

      stopAll() {
        this.stopRain();
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // PARTICLE SYSTEM — Canvas-based visual effects
    // ═══════════════════════════════════════════════════════════════════════════════
    const ParticleSystem = {
      canvas: null,
      ctx: null,
      particles: [],
      maxParticles: 400,
      _initialized: false,

      init() {
        this.canvas = document.getElementById('particleCanvas');
        if (!this.canvas) return;
        this.ctx = this.canvas.getContext('2d');
        this._resize();
        window.addEventListener('resize', () => this._resize());
        this._initialized = true;
      },

      _resize() {
        if (!this.canvas) return;
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
      },

      emitRain(wetness) {
        if (!this._initialized || wetness < 0.05) return;
        const count = Math.floor(wetness * 8);
        for (let i = 0; i < count; i++) {
          if (this.particles.length >= this.maxParticles) this.particles.shift();
          this.particles.push({
            x: Math.random() * this.canvas.width,
            y: -10,
            vx: -1.5 - Math.random(),
            vy: 12 + Math.random() * 8,
            decay: 0.003,
            size: 1 + Math.random() * 1.5,
            color: 'rgba(160,190,220,',
            gravity: 0.1,
            length: 8 + Math.random() * 12,
            life: 1.0
          });
        }
      },

      update(dt) {
        if (!this._initialized || !this.particles.length) return;
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i];
          p.life -= p.decay * (dt || 1);
          if (p.life <= 0 || p.y > this.canvas.height + 20) {
            this.particles.splice(i, 1); continue;
          }
          p.x += p.vx;
          p.y += p.vy;
          p.vy += p.gravity;

          ctx.strokeStyle = p.color + (p.life * 0.5).toFixed(2) + ')';
          ctx.lineWidth = p.size;
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x + p.vx * 0.5, p.y + p.length);
          ctx.stroke();
        }
      },

      clear() {
        this.particles = [];
        if (this.ctx) this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // MINIMAP — Corner overview of the full track with car positions
    // ═══════════════════════════════════════════════════════════════════════════════
    const MiniMap = {
      canvas: null,
      ctx: null,
      _initialized: false,
      _trackPath: null,   // Cached track path points
      _bounds: null,      // Track bounding box

      init() {
        this.canvas = document.getElementById('minimapCanvas');
        if (!this.canvas) return;
        this.ctx = this.canvas.getContext('2d');
        this._initialized = true;
      },

      buildTrackPath() {
        if (!Track || !Track._points) return;
        const pts = Track._points;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const p of pts) {
          minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
        }
        this._bounds = { minX, maxX, minY, maxY };

        // Downsample for minimap (every Nth point)
        const step = Math.max(1, Math.floor(pts.length / 200));
        this._trackPath = [];
        for (let i = 0; i < pts.length; i += step) {
          this._trackPath.push(pts[i]);
        }
      },

      render() {
        if (!this._initialized || !MultiCarRace.isActive) return;
        if (!this._trackPath) this.buildTrackPath();
        if (!this._trackPath || !this._bounds) return;

        const ctx = this.ctx;
        const W = this.canvas.width;
        const H = this.canvas.height;
        const b = this._bounds;
        const pad = 24;

        // Scale to fit
        const scaleX = (W - pad * 2) / (b.maxX - b.minX || 1);
        const scaleY = (H - pad * 2) / (b.maxY - b.minY || 1);
        const scale = Math.min(scaleX, scaleY);
        const offX = (W - (b.maxX - b.minX) * scale) / 2;
        const offY = (H - (b.maxY - b.minY) * scale) / 2;

        ctx.clearRect(0, 0, W, H);

        // Draw track outline
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 3;
        ctx.lineJoin = 'round';
        ctx.beginPath();
        for (let i = 0; i < this._trackPath.length; i++) {
          const p = this._trackPath[i];
          const x = (p.x - b.minX) * scale + offX;
          const y = (p.y - b.minY) * scale + offY;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();

        // Draw car dots
        const positions = MultiCarRace.getPositions();
        const controlledId = typeof RaceUI !== 'undefined' ? RaceUI.controlledCarId : 1;

        for (let i = positions.length - 1; i >= 0; i--) {
          const car = positions[i];
          const pos = Track.getPointCorrected(car.visualS || car.s);
          const x = (pos.x - b.minX) * scale + offX;
          const y = (pos.y - b.minY) * scale + offY;
          const isPlayer = car.id === controlledId;

          // Dot
          ctx.fillStyle = car.color;
          ctx.beginPath();
          ctx.arc(x, y, isPlayer ? 5 : 3, 0, Math.PI * 2);
          ctx.fill();

          // Player: white ring
          if (isPlayer) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            ctx.stroke();
          }

          // Position number for top 3
          if (i < 3) {
            ctx.fillStyle = '#fff';
            ctx.font = '700 8px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(i + 1, x, y - 5);
          }
        }
      },

      invalidate() {
        this._trackPath = null;
        this._bounds = null;
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // COUNTDOWN SYSTEM — Visual + Audio countdown before race start
    // ═══════════════════════════════════════════════════════════════════════════════
    const Countdown = {
      _active: false,

      start(onGo) {
        if (this._active) return;
        this._active = true;
        const overlay = document.getElementById('countdownOverlay');
        const text = document.getElementById('countdownText');
        if (!overlay || !text) { if (onGo) onGo(); return; }
        overlay.style.display = 'flex';

        const steps = [
          { label: '3', delay: 0, isFinal: false },
          { label: '2', delay: 1000, isFinal: false },
          { label: '1', delay: 2000, isFinal: false },
          { label: 'GO!', delay: 3000, isFinal: true },
        ];

        steps.forEach(step => {
          setTimeout(() => {
            text.textContent = step.label;
            text.className = step.isFinal ? 'countdown-go' : '';
            text.style.animation = 'none';
            void text.offsetWidth;  // Force reflow
            text.style.animation = 'countPulse 0.8s ease';
            SoundEngine.playCountdownBeep(step.isFinal);

            if (step.isFinal) {
              setTimeout(() => {
                overlay.style.display = 'none';
                this._active = false;
                if (onGo) onGo();
              }, 800);
            }
          }, step.delay);
        });
      }
    };

    let _gameLoopErrors = 0;
    const _MAX_LOOP_ERRORS = 100;  // High threshold — silently recover, never freeze
    let _gameLoopRunning = false;  // Guard against multiple rAF chains
    let _lastErrorLog = 0;  // Throttle error logging
    let _frameCount = 0;
    let _lastPerfCheck = 0;
    
    function gameLoop(now) {
      _frameCount++;
      // Performance check every 10s
      if (now - _lastPerfCheck > 10000) {
        _lastPerfCheck = now;
        _checkPerformance();
        if (_frameCount > 0) {
          _debugLog(`Frames in last 10s: ${_frameCount} (≈${(_frameCount/10).toFixed(0)} FPS). Errors so far: ${_gameLoopErrors}`);
        }
        _frameCount = 0;
      }
      try {
        // ── MULTIPLAYER CLIENT: No local physics, just render from server state ──
        const isClientOnly = Multiplayer.isMultiplayerRace && !Multiplayer.isHost;
        
        if (isClientOnly) {
          // Client: render every frame but no physics simulation
          // State is updated by Multiplayer.applyWorldState() from server broadcasts
          Simulation.lastFrameTime = now;
        } else if (Simulation.running) {
          const frameTime = Math.min((now - Simulation.lastFrameTime) / 1000, 0.1);
          Simulation.lastFrameTime = now;

          Simulation.accumulator += frameTime * Simulation.speed;
          
          // Safety: cap max physics steps per frame to prevent freeze
          let maxSteps = 200;  // 200 × 0.01s = 2s sim time max (reduced for perf)
          while (Simulation.accumulator >= SIM_DT && maxSteps-- > 0) {
            try {
              Simulation.step();
            } catch (stepErr) {
              // Individual step failure — skip and continue
              if (now - _lastErrorLog > 5000) {
                console.warn('[GameLoop] Step error:', stepErr.message);
                _lastErrorLog = now;
              }
              // Attempt NaN recovery for all cars
              if (MultiCarRace.isActive) {
                for (const car of MultiCarRace.cars) {
                  if (!Number.isFinite(car.v)) car.v = 10;
                  if (!Number.isFinite(car.s)) car.s = 0;
                }
              }
            }
            Simulation.accumulator -= SIM_DT;
          }
          // If we hit the cap, drain the excess to prevent buildup
          if (maxSteps <= 0) Simulation.accumulator = 0;

          const alpha = Simulation.accumulator / SIM_DT;
          Simulation.interpolate(alpha);
        }

        Renderer.render();
        updateUI();
        LiftCoast.syncButton();

        // ── Weather visual effects ──
        if (MultiCarRace.isActive) {
          const wetness = Weather.wetness || 0;
          SoundEngine.updateRain(wetness);
          ParticleSystem.emitRain(wetness);
        }
        ParticleSystem.update(1);
        MiniMap.render();

        if (TelemetryUI.isOpen() && !TelemetryUI.liveFrozen) {
          TelemetryUI.draw();
        }
        
        if (TireUI.isOpen()) {
          TireUI.update();
          TireUI.drawGripCurve();
          TireUI.drawFwetCurve();
          TireUI.drawFtempCurve();
          TireUI.drawMwearCurve();
        }
        
        if (WeatherUI.isOpen()) {
          WeatherUI.update();
        }
        
        if (PartsUI.isOpen()) {
          PartsUI.update();
        }
        
        if (SetupUI.isOpen()) {
          // Only sync tire compound and status, not all fields (user may be editing)
          const setupTireSelect = document.getElementById('setupTireCompound');
          if (setupTireSelect) setupTireSelect.value = Tire.compound;
          const setupTireStatus = document.getElementById('setupTireStatus');
          if (setupTireStatus) {
            setupTireStatus.textContent = `Current: ${Tire.condition.toFixed(0)}% | ${(Tire.distanceTraveled/1000).toFixed(1)}km`;
          }
          SetupUI.updateStatusDisplay();
        }
        
        // Reset error counter on successful frame
        _gameLoopErrors = 0;
        
      } catch (err) {
        _gameLoopErrors++;
        // Throttle error logging to avoid console spam
        if (now - _lastErrorLog > 2000) {
          console.error(`[GameLoop] Error #${_gameLoopErrors}:`, err.message);
          _lastErrorLog = now;
        }
        
        // Try to recover by fixing common issues
        try {
          if (MultiCarRace.isActive) {
            for (const car of MultiCarRace.cars) {
              if (!Number.isFinite(car.v)) car.v = 10;
              if (!Number.isFinite(car.s)) car.s = 0;
              if (!Number.isFinite(car.fuel)) car.fuel = car.setup.fuelCapacity || 100;
            }
          }
          if (!Number.isFinite(Car.v)) Car.v = 10;
          if (!Number.isFinite(Car.s)) Car.s = 0;
        } catch (recoverErr) { /* ignore recovery errors */ }
        
        if (_gameLoopErrors >= _MAX_LOOP_ERRORS) {
          // Silently reset — no alert(), no pausing, no UI switch.
          // The game loop continues running and auto-recovers.
          _debugLog(`🔴 GameLoop hit ${_MAX_LOOP_ERRORS} errors — resetting counter. Last error: ${err.message}`);
          _gameLoopErrors = 0;
        }
      }

      requestAnimationFrame(gameLoop);
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // MULTI-CAR RACE UI & INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════════════
    
    const RaceUI = {
      controlledCarId: 1,  // ID of player-controlled car
      
      // Team names and colors for 20 cars (2 cars per team)
      teams: [
        { name: 'Red Bull',        color: '#1e41ff', number: 1 },
        { name: 'Red Bull',        color: '#1e41ff', number: 11 },
        { name: 'Ferrari',         color: '#e8002d', number: 16 },
        { name: 'Ferrari',         color: '#e8002d', number: 55 },
        { name: 'Mercedes',        color: '#27f4d2', number: 44 },
        { name: 'Mercedes',        color: '#27f4d2', number: 63 },
        { name: 'McLaren',         color: '#ff8000', number: 4 },
        { name: 'McLaren',         color: '#ff8000', number: 81 },
        { name: 'Aston Martin',    color: '#229971', number: 14 },
        { name: 'Aston Martin',    color: '#229971', number: 18 },
        { name: 'Alpine',          color: '#ff87bc', number: 10 },
        { name: 'Alpine',          color: '#ff87bc', number: 31 },
        { name: 'Williams',        color: '#64c4ff', number: 23 },
        { name: 'Williams',        color: '#64c4ff', number: 2 },
        { name: 'RB',              color: '#6692ff', number: 22 },
        { name: 'RB',              color: '#6692ff', number: 3 },
        { name: 'Sauber',          color: '#52e252', number: 77 },
        { name: 'Sauber',          color: '#52e252', number: 24 },
        { name: 'Haas',            color: '#b6babd', number: 20 },
        { name: 'Haas',            color: '#b6babd', number: 27 },
      ],
      
      // Per-team performance differentials (relative to CarDefaults)
      // WIDE spread: ~2-3s per lap between top and bottom teams
      // frontalArea variation: low-drag cars have smaller area
      teamSetups: [
        // Red Bull 1:  best overall package, excellent aero efficiency
        { power: 790000, cLWing: 1.733, cLDiffuser: 2.118, cDBody: 0.365, cDWing: 0.495, mass: 796, tireGrip: 1.78, brakeForce: 37000, frontalArea: 1.78 },
        // Red Bull 2:
        { power: 790000, cLWing: 1.719, cLDiffuser: 2.101, cDBody: 0.379, cDWing: 0.491, mass: 796, tireGrip: 1.76, brakeForce: 37000, frontalArea: 1.78 },
        // Ferrari 1:  raw power king, good aero, slightly heavier
        { power: 800000, cLWing: 1.620, cLDiffuser: 1.980, cDBody: 0.467, cDWing: 0.463, mass: 802, tireGrip: 1.73, brakeForce: 36500, frontalArea: 1.82 },
        // Ferrari 2:
        { power: 800000, cLWing: 1.607, cLDiffuser: 1.964, cDBody: 0.471, cDWing: 0.459, mass: 802, tireGrip: 1.71, brakeForce: 36500, frontalArea: 1.82 },
        // Mercedes 1:  best mechanical grip, balanced
        { power: 775000, cLWing: 1.665, cLDiffuser: 2.035, cDBody: 0.414, cDWing: 0.476, mass: 798, tireGrip: 1.82, brakeForce: 36000, frontalArea: 1.80 },
        // Mercedes 2:
        { power: 775000, cLWing: 1.652, cLDiffuser: 2.019, cDBody: 0.428, cDWing: 0.472, mass: 798, tireGrip: 1.80, brakeForce: 36000, frontalArea: 1.80 },
        // McLaren 1:  lowest drag, less downforce, very light
        { power: 770000, cLWing: 1.530, cLDiffuser: 1.870, cDBody: 0.383, cDWing: 0.437, mass: 795, tireGrip: 1.74, brakeForce: 35500, frontalArea: 1.76 },
        // McLaren 2:
        { power: 770000, cLWing: 1.517, cLDiffuser: 1.854, cDBody: 0.397, cDWing: 0.433, mass: 795, tireGrip: 1.72, brakeForce: 35500, frontalArea: 1.76 },
        // Aston Martin 1:  high downforce, more drag, heavy
        { power: 755000, cLWing: 1.710, cLDiffuser: 2.090, cDBody: 0.471, cDWing: 0.489, mass: 806, tireGrip: 1.72, brakeForce: 35800, frontalArea: 1.84 },
        // Aston Martin 2:
        { power: 755000, cLWing: 1.697, cLDiffuser: 2.074, cDBody: 0.475, cDWing: 0.485, mass: 806, tireGrip: 1.70, brakeForce: 35800, frontalArea: 1.84 },
        // Alpine 1:  mid-pack, average everything
        { power: 750000, cLWing: 1.575, cLDiffuser: 1.925, cDBody: 0.460, cDWing: 0.450, mass: 801, tireGrip: 1.69, brakeForce: 35000, frontalArea: 1.80 },
        // Alpine 2:
        { power: 750000, cLWing: 1.562, cLDiffuser: 1.909, cDBody: 0.474, cDWing: 0.446, mass: 801, tireGrip: 1.67, brakeForce: 35000, frontalArea: 1.80 },
        // Williams 1:  good straight-line speed, weak corners
        { power: 765000, cLWing: 1.463, cLDiffuser: 1.788, cDBody: 0.412, cDWing: 0.418, mass: 799, tireGrip: 1.64, brakeForce: 34200, frontalArea: 1.77 },
        // Williams 2:
        { power: 765000, cLWing: 1.449, cLDiffuser: 1.771, cDBody: 0.426, cDWing: 0.414, mass: 799, tireGrip: 1.62, brakeForce: 34200, frontalArea: 1.77 },
        // RB 1:  junior team, balanced mid-field
        { power: 752000, cLWing: 1.566, cLDiffuser: 1.914, cDBody: 0.453, cDWing: 0.447, mass: 800, tireGrip: 1.67, brakeForce: 34800, frontalArea: 1.80 },
        // RB 2:
        { power: 752000, cLWing: 1.553, cLDiffuser: 1.898, cDBody: 0.466, cDWing: 0.444, mass: 800, tireGrip: 1.65, brakeForce: 34800, frontalArea: 1.80 },
        // Sauber 1:  struggling, heavy, low grip, weak power
        { power: 730000, cLWing: 1.485, cLDiffuser: 1.815, cDBody: 0.526, cDWing: 0.424, mass: 810, tireGrip: 1.60, brakeForce: 33500, frontalArea: 1.83 },
        // Sauber 2:
        { power: 730000, cLWing: 1.472, cLDiffuser: 1.799, cDBody: 0.539, cDWing: 0.421, mass: 810, tireGrip: 1.58, brakeForce: 33500, frontalArea: 1.83 },
        // Haas 1:  decent braking, weakest power, heavy
        { power: 725000, cLWing: 1.508, cLDiffuser: 1.843, cDBody: 0.509, cDWing: 0.431, mass: 808, tireGrip: 1.62, brakeForce: 35500, frontalArea: 1.82 },
        // Haas 2:
        { power: 725000, cLWing: 1.494, cLDiffuser: 1.826, cDBody: 0.523, cDWing: 0.427, mass: 808, tireGrip: 1.60, brakeForce: 35500, frontalArea: 1.82 },
      ],

      initRace() {
        // ══════════════════════════════════════════════════════════════
        // MULTIPLAYER: Only create cars for connected players (NO AI)
        // SINGLE-PLAYER: Create 20 cars, car 1 = player, rest = AI
        // ══════════════════════════════════════════════════════════════
        const compounds = ['soft','soft','soft','medium','soft','soft','medium','medium','soft','medium',
                           'medium','hard','soft','medium','medium','hard','medium','hard','soft','hard'];
        
        if (Multiplayer.isMultiplayerRace) {
          // MULTIPLAYER: One car per connected player, no AI
          const numPlayers = Multiplayer.players.length;
          const carConfigs = [];
          for (let idx = 0; idx < numPlayers; idx++) {
            const player = Multiplayer.players[idx];
            const team = this.teams[idx] || this.teams[0];
            carConfigs.push({
              name: player.nickname,
              teamName: team.name,
              color: team.color,
              number: team.number,
              setup: { ...CarDefaults, ...(this.teamSetups[idx] || {}) },
              compound: compounds[idx] || 'medium',
              skills: driverSkillProfiles[idx] || driverSkillProfiles[0],
              ai: null  // NO AI in multiplayer
            });
          }
          MultiCarRace.initRace(carConfigs);
        } else {
          // SINGLE-PLAYER: 20 cars with AI
          const carConfigs = this.teams.map((team, idx) => ({
            name: driverNames[idx] || team.name,
            teamName: team.name,
            color: team.color,
            number: team.number,
            // Car 0 (player): use CarConfig (which UI has modified)
            // AI cars: use CarDefaults + team-specific overrides
            setup: idx === 0
              ? { ...structuredClone(CarConfig), ...(this.teamSetups[idx] || {}) }
              : { ...CarDefaults, ...(this.teamSetups[idx] || {}) },
            compound: compounds[idx] || 'medium',
            skills: driverSkillProfiles[idx] || driverSkillProfiles[0],
            ai: idx === 0 ? null : AIDriver.create(idx)
          }));
          MultiCarRace.initRace(carConfigs);
        }
        
        this.updateCarSelector();
        this.updateLiveTiming();

        // ── Initialize Sound & Effects ──
        SoundEngine.init();
        SoundEngine.resume();
        ParticleSystem.init();
        MiniMap.init();
        MiniMap.invalidate();
        ParticleSystem.clear();
        this._raceStarted = false;

        // Track last positions for animation
        this._lastPositions = {};
      },
      
      updateCarSelector() {
        const select = document.getElementById('controlledCarSelect');
        if (!select) return;
        
        select.innerHTML = '';
        
        // In multiplayer: only show our own car (can't switch to others)
        if (Multiplayer.isMultiplayerRace) {
          const myCar = MultiCarRace.cars[Multiplayer.localCarIndex];
          if (myCar) {
            const opt = document.createElement('option');
            opt.value = myCar.id;
            opt.textContent = `#${myCar.number} ${myCar.name} (YOU)`;
            opt.style.color = myCar.color;
            opt.selected = true;
            select.appendChild(opt);
          }
          select.disabled = true;
          return;
        }
        
        // Single-player: show all cars, allow switching
        for (const car of MultiCarRace.cars) {
          const opt = document.createElement('option');
          opt.value = car.id;
          opt.textContent = `#${car.number} ${car.name}`;
          opt.style.color = car.color;
          if (car.id === this.controlledCarId) opt.selected = true;
          select.appendChild(opt);
        }
        
        select.onchange = (e) => {
          const newId = parseInt(e.target.value);
          const oldId = this.controlledCarId;
          
          // Give AI to the car we're leaving
          const oldCar = MultiCarRace.cars.find(c => c.id === oldId);
          if (oldCar && !oldCar.ai) {
            oldCar.ai = AIDriver.create(oldId);
          }
          
          // Remove AI from the car we're taking control of
          const newCar = MultiCarRace.cars.find(c => c.id === newId);
          if (newCar) {
            newCar.ai = null;
            // Cancel any AI pit plans
            if (newCar.pit.armed && newCar.pit.phase === 'approach') {
              newCar.pit.armed = false;
              newCar.pit.committed = false;
              newCar.pit.phase = 'none';
            }
          }
          
          this.controlledCarId = newId;
          this.syncControlledCar();
        };
      },
      
      // Sync the global Car object with the controlled car from MultiCarRace
      syncControlledCar() {
        const controlled = MultiCarRace.cars.find(c => c.id === this.controlledCarId);
        if (controlled) {
          // Update CarConfig from controlled car's setup
          Object.assign(CarConfig, controlled.setup);
          
          // Sync Car state to match controlled car
          Car.s = controlled.s;
          Car.v = controlled.v;
          Car.a = controlled.a;
          Car.lap = controlled.lap;
          Car.fuel = controlled.fuel;
          Car.vLimit = controlled.vLimit;  // Sync braking limit curve
          Car.throttle = controlled.throttle;
          Car.brake = controlled.brake;
          
          // Sync pit state from controlled car
          if (controlled.pit) {
            Car.pit.armed = controlled.pit.armed;
            Car.pit.committed = controlled.pit.committed;
            Car.pit.inLane = controlled.pit.inLane;
            Car.pit.limiter = controlled.pit.limiter;
            Car.pit.stopped = controlled.pit.stopped;
            Car.pit.phase = controlled.pit.phase;
            Car.pit.exitRequested = controlled.pit.exitRequested;
          }
          
          // Sync global Tire object
          if (typeof Tire !== 'undefined') {
            Tire.condition = controlled.tire.condition;
            Tire.compound = controlled.tire.compound;
          }
          
          // Update all sliders to match the controlled car's setup
          this.updateSetupSliders(controlled.setup);
          
          // Update pit button
          UI.syncPitButtons();
        }
      },
      
      // Update UI sliders to match a car's setup
      updateSetupSliders(setup) {
        const sliderMappings = {
          'mass': 'mass',
          'power': 'power',
          'cLWing': 'cLWing',
          'cLDiffuser': 'cLDiffuser',
          'cDBody': 'cDBody',
          'cDWing': 'cDWing',
          'wingAngle': 'wingAngle',
          'rideHeight': 'rideHeight',
          'springK': 'springK',
          'damperC': 'damperC',
          'fuelCapacity': 'fuelCapacity',
          'brakeForce': 'brakeForce'
        };
        
        for (const [sliderId, setupKey] of Object.entries(sliderMappings)) {
          const slider = document.getElementById(sliderId);
          const display = document.getElementById(sliderId + 'Val');
          if (slider && setup[setupKey] !== undefined) {
            slider.value = setup[setupKey];
            if (display) display.textContent = setup[setupKey];
          }
        }
      },
      
      // Apply current CarConfig to the controlled car
      applySetupToControlledCar() {
        const controlled = MultiCarRace.cars.find(c => c.id === this.controlledCarId);
        if (controlled) {
          Object.assign(controlled.setup, CarConfig);
        }
      },
      
      getControlledCar() {
        return MultiCarRace.cars.find(c => c.id === this.controlledCarId);
      },
      
      updateLiveTiming() {
        const container = document.getElementById('timingRows');
        const statusEl = document.getElementById('raceStatus');
        if (!container || !MultiCarRace.cars.length) return;
        
        // Get sorted positions
        const positions = MultiCarRace.getPositions();
        const leader = positions[0];
        
        // Update race status
        if (statusEl && leader) {
          statusEl.textContent = `LAP ${leader.lap}/${Track.totalLaps}`;
        }
        
        // Build timing rows
        let html = '';
        for (let i = 0; i < positions.length; i++) {
          const car = positions[i];
          const pos = i + 1;
          const isSelected = car.id === this.controlledCarId;
          const isLeader = pos === 1;
          
          // Position class
          let posClass = '';
          if (pos === 1) posClass = 'p1';
          else if (pos === 2) posClass = 'p2';
          else if (pos === 3) posClass = 'p3';
          
          // Gap to leader
          let gapText = '';
          let gapClass = '';
          if (isLeader) {
            gapText = 'LEADER';
            gapClass = 'leader';
          } else {
            const gap = MultiCarRace.getGapToLeader(car);
            if (gap < 60) {
              gapText = `+${gap.toFixed(1)}s`;
            } else {
              const lapDiff = Math.floor(gap / 90); // Approximate
              gapText = `+${lapDiff} LAP${lapDiff > 1 ? 'S' : ''}`;
            }
            gapClass = 'interval';
          }
          
          // Interval to car ahead
          let intText = '';
          let intClass = '';
          if (isLeader) {
            intText = '--';
            intClass = '';
          } else {
            const interval = MultiCarRace.getGapToCarAhead(car);
            if (interval !== null && interval < 60) {
              intText = `+${interval.toFixed(1)}s`;
              intClass = interval < 1.0 ? 'drs' : 'interval';
            } else if (interval !== null) {
              intText = `+${Math.floor(interval / 90)}L`;
              intClass = 'interval';
            } else {
              intText = '--';
            }
          }
          
          // Last lap time
          let lastLapText = '--:--.---';
          let lastLapClass = '';
          if (car.lastLapTime) {
            lastLapText = formatTime(car.lastLapTime);
            if (car.lastLapTime === car.bestLapTime) {
              lastLapClass = 'green';
            }
            // Check for overall best (purple)
            const overallBest = Math.min(...positions.map(c => c.bestLapTime || Infinity));
            if (car.lastLapTime === overallBest) {
              lastLapClass = 'purple';
            }
          }
          
          // Slipstream/Dirty Air display
          const slip = car.slipstream || { kDrag: 1.0, kCL: 1.0 };
          const dragReduction = Math.round((1 - slip.kDrag) * 100);
          const downforceLoss = Math.round((1 - slip.kCL) * 100);
          
          let slipText = '--';
          let slipClass = 'neutral';
          if (dragReduction > 1) {
            slipText = `-${dragReduction}% drag`;
            slipClass = 'drag-bonus';
          }
          if (downforceLoss > 1) {
            slipText = `-${downforceLoss}% DF`;
            slipClass = 'dirty-air';
          }
          if (dragReduction > 1 && downforceLoss > 1) {
            slipText = `D-${dragReduction}/F-${downforceLoss}`;
            slipClass = dragReduction > downforceLoss ? 'drag-bonus' : 'dirty-air';
          }
          
          // AI / Player status
          let driverTag = '';
          if (car.ai) {
            let aiStatus = 'AI';
            if (car.ai.coastActive) aiStatus = '🌊 L&C';
            if (car.pit.armed || car.pit.inLane) aiStatus = '🔧 PIT';
            driverTag = `<span style="font-size:9px;color:#888;margin-left:2px">${aiStatus}</span>`;
          } else {
            driverTag = `<span style="font-size:9px;color:#0f0;margin-left:2px">PLAYER</span>`;
          }
          
          // Speed (km/h)
          const speedKmh = Math.round(car.v * 3.6);
          
          // Tire: compound badge + condition bar
          const tireCondPct = car.tire ? Math.round(car.tire.condition) : 100;
          const tireLetter = car.tire ? car.tire.compound[0].toUpperCase() : 'M';
          const compName = car.tire ? car.tire.compound : 'medium';
          const compColors = {soft:'#e10600', medium:'#ffd700', hard:'#f0f0f0', intermediate:'#43b02a', wet:'#0091d2'};
          const compBg = compColors[compName] || '#ffd700';
          const compFg = (compName === 'medium' || compName === 'hard') ? '#111' : '#fff';
          const tireBarColor = tireCondPct > 50 ? compBg : tireCondPct > 25 ? '#ff4' : '#f44';
          
          // Fuel: bar + kg label
          const fuelKg = Math.round(car.fuel);
          const fuelCap = car.setup.fuelCapacity || 110;
          const fuelPct = Math.round((car.fuel / fuelCap) * 100);
          const fuelBarColor = fuelPct > 30 ? '#4af' : fuelPct > 15 ? '#ff4' : '#f44';
          
          html += `
            <div class="timing-row ${isSelected ? 'selected' : ''} ${isLeader ? 'leader' : ''}" 
                 data-car-id="${car.id}" onclick="RaceUI.selectCar(${car.id})">
              <div class="timing-pos ${posClass}">${pos}</div>
              <div class="timing-number" style="background: ${car.color}">${car.number}</div>
              <div class="timing-name">${car.name}${driverTag}</div>
              <div class="timing-gap ${gapClass}">${gapText}</div>
              <div class="timing-int ${intClass}" style="font-size:10px;text-align:right">${intText}</div>
              <div class="timing-last ${lastLapClass}">${lastLapText}</div>
              <div class="timing-spd">${speedKmh}</div>
              <div class="timing-tire-fuel">
                <span class="timing-tire-badge" style="background:${compBg};color:${compFg}">${tireLetter}</span><div class="timing-tire-bar"><div class="timing-tire-bar-fill" style="width:${tireCondPct}%;background:${tireBarColor}"></div></div>
                <span style="color:${fuelBarColor}">⛽</span><div class="timing-fuel-bar"><div class="timing-fuel-bar-fill" style="width:${fuelPct}%;background:${fuelBarColor}"></div></div><span style="color:#aaa;font-size:8px">${fuelKg}</span>
              </div>
            </div>
          `;
        }
        
        container.innerHTML = html;

        // ── Position-change animations ──
        if (this._lastPositions) {
          for (let i = 0; i < positions.length; i++) {
            const car = positions[i];
            const newPos = i + 1;
            const oldPos = this._lastPositions[car.id];
            if (oldPos !== undefined && oldPos !== newPos) {
              const row = container.querySelector(`[data-car-id="${car.id}"]`);
              if (row) {
                row.classList.add(newPos < oldPos ? 'pos-up' : 'pos-down');
                if (newPos < oldPos) row.classList.add('overtake-flash');
                setTimeout(() => {
                  row.classList.remove('pos-up', 'pos-down', 'overtake-flash');
                }, 600);
              }
            }
            this._lastPositions[car.id] = newPos;
          }
        }
      },
      
      selectCar(carId) {
        this.controlledCarId = carId;
        document.getElementById('controlledCarSelect').value = carId;
        this.syncControlledCar();
        this.updateLiveTiming();
      },
      
      // ─────────────────────────────────────────────────────────────────
      // SECTOR TIMING - Track sector times with millisecond precision
      // ─────────────────────────────────────────────────────────────────
      
      updateSectorTiming(car, simTime) {
        const currentSector = Track.getSector(car.s);
        
        // Check if sector changed
        if (currentSector !== car.currentSector) {
          const sectorTime = simTime - car.sectorStartTime;
          const completedSector = car.currentSector;
          
          // Store sector time (index is sector - 1)
          if (completedSector >= 1 && completedSector <= 3) {
            car.sectors.current[completedSector - 1] = sectorTime;
            
            // Check for personal best in this sector
            const prevBest = car.sectors.personalBest[completedSector - 1];
            if (prevBest === null || sectorTime < prevBest) {
              car.sectors.personalBest[completedSector - 1] = sectorTime;
            }
          }
          
          // Update current sector and start time
          car.currentSector = currentSector;
          car.sectorStartTime = simTime;
          
          // If completing sector 3, it's a new lap (handled elsewhere)
          if (completedSector === 3 && currentSector === 1) {
            // Copy current to last, reset current
            car.sectors.last = [...car.sectors.current];
            car.sectors.current = [null, null, null];
          }
        }
      },
      
      // Format time with milliseconds (e.g., "1:23.456")
      formatTimeMs(seconds) {
        if (seconds === null || seconds === undefined || !isFinite(seconds)) {
          return '--:--.---';
        }
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        const secPart = Math.floor(secs);
        const msPart = Math.round((secs - secPart) * 1000);
        
        if (mins > 0) {
          return `${mins}:${secPart.toString().padStart(2, '0')}.${msPart.toString().padStart(3, '0')}`;
        }
        return `${secPart}.${msPart.toString().padStart(3, '0')}`;
      },
      
      // Format sector time (shorter, e.g., "23.456")
      formatSectorTime(seconds) {
        if (seconds === null || seconds === undefined || !isFinite(seconds)) {
          return '--.-';
        }
        return seconds.toFixed(3);
      },
      
      // Get sector color class based on comparison
      getSectorClass(sectorTime, sectorIdx, car) {
        if (!sectorTime) return 'white';
        
        // Get overall best for this sector across all cars
        let overallBest = Infinity;
        for (const c of MultiCarRace.cars) {
          const best = c.sectors.personalBest[sectorIdx];
          if (best !== null && best < overallBest) overallBest = best;
        }
        
        const personalBest = car.sectors.personalBest[sectorIdx];
        
        // Purple = overall best
        if (sectorTime <= overallBest + 0.001) return 'purple';
        // Green = personal best
        if (personalBest !== null && sectorTime <= personalBest + 0.001) return 'green';
        // Yellow = slower than personal best
        return 'yellow';
      },
      
      // Update the current sector display for controlled car
      updateCurrentSectors() {
        const car = this.getControlledCar();
        if (!car) return;
        
        for (let i = 0; i < 3; i++) {
          const el = document.getElementById(`sector${i + 1}Time`);
          if (!el) continue;
          
          const sectorTime = car.sectors.current[i];
          const lastTime = car.sectors.last[i];
          const displayTime = sectorTime || lastTime;
          
          el.textContent = `S${i + 1} ${this.formatSectorTime(displayTime)}`;
          
          // Remove old classes
          el.classList.remove('purple', 'green', 'yellow', 'white');
          
          // Add appropriate class
          if (displayTime) {
            el.classList.add(this.getSectorClass(displayTime, i, car));
          } else {
            el.classList.add('white');
          }
        }
      },
      
      // ─────────────────────────────────────────────────────────────────
      // FULL F1 TIMING MODAL
      // ─────────────────────────────────────────────────────────────────
      
      openFullTiming() {
        const modal = document.getElementById('f1TimingModal');
        if (modal) modal.classList.add('open');
        this.updateFullTiming();
      },
      
      closeFullTiming() {
        const modal = document.getElementById('f1TimingModal');
        if (modal) modal.classList.remove('open');
      },
      
      updateFullTiming() {
        const tbody = document.getElementById('f1TimingBody');
        if (!tbody || !MultiCarRace.cars.length) return;
        
        const positions = MultiCarRace.getPositions();
        const leader = positions[0];
        let overallBestLap = Infinity;
        
        // Find overall best lap
        for (const car of positions) {
          if (car.bestLapTime && car.bestLapTime < overallBestLap) {
            overallBestLap = car.bestLapTime;
          }
        }
        
        // Find best sector times
        const bestSectors = [Infinity, Infinity, Infinity];
        for (const car of positions) {
          for (let i = 0; i < 3; i++) {
            const best = car.sectors.personalBest[i];
            if (best !== null && best < bestSectors[i]) {
              bestSectors[i] = best;
            }
          }
        }
        
        let html = '';
        for (let i = 0; i < positions.length; i++) {
          const car = positions[i];
          const pos = i + 1;
          const isSelected = car.id === this.controlledCarId;
          
          // Position styling
          let posClass = '';
          if (pos === 1) posClass = 'gold';
          else if (pos === 2) posClass = 'silver';
          else if (pos === 3) posClass = 'bronze';
          
          // Gap to leader
          let gapText = '--';
          if (pos === 1) {
            gapText = '--';
          } else if (leader) {
            const gap = MultiCarRace.getGapToLeader(car);
            gapText = gap < 60 ? `+${gap.toFixed(3)}` : `+${Math.floor(gap / 90)} LAP`;
          }
          
          // Interval to car ahead
          let intText = '--';
          if (pos > 1) {
            const intGap = MultiCarRace.getGapToCarAhead(car);
            intText = (intGap !== null && intGap < 60) ? `+${intGap.toFixed(3)}` : '--';
          }
          
          // Sector times (use current or last)
          const sectorTimes = [];
          const sectorClasses = [];
          for (let s = 0; s < 3; s++) {
            const current = car.sectors.current[s];
            const last = car.sectors.last[s];
            const time = current || last;
            sectorTimes.push(time);
            
            if (time === null) {
              sectorClasses.push('white');
            } else if (time <= bestSectors[s] + 0.001) {
              sectorClasses.push('purple');
            } else if (car.sectors.personalBest[s] !== null && time <= car.sectors.personalBest[s] + 0.001) {
              sectorClasses.push('green');
            } else {
              sectorClasses.push('yellow');
            }
          }
          
          // Last lap time
          let lastLapClass = '';
          if (car.lastLapTime === overallBestLap) lastLapClass = 'fastest';
          else if (car.lastLapTime === car.bestLapTime) lastLapClass = '';
          
          // Best lap styling
          let bestLapClass = car.bestLapTime === overallBestLap ? 'fastest' : '';
          
          // Tire compound
          const compound = car.tire?.compound || 'medium';
          
          html += `
            <tr class="${isSelected ? 'selected' : ''}" onclick="RaceUI.selectCar(${car.id}); RaceUI.updateFullTiming();">
              <td class="f1-pos ${posClass}">${pos}</td>
              <td>
                <div class="f1-driver">
                  <span class="f1-number" style="background: ${car.color}">${car.number}</span>
                  <div>
                    <div class="f1-name">${car.name}</div>
                  </div>
                </div>
              </td>
              <td class="f1-time ${pos === 1 ? 'leader' : ''}">${pos === 1 ? 'LEADER' : ''}</td>
              <td class="f1-gap">${gapText}</td>
              <td class="f1-gap">${intText}</td>
              <td><span class="f1-sector ${sectorClasses[0]}">${this.formatSectorTime(sectorTimes[0])}</span></td>
              <td><span class="f1-sector ${sectorClasses[1]}">${this.formatSectorTime(sectorTimes[1])}</span></td>
              <td><span class="f1-sector ${sectorClasses[2]}">${this.formatSectorTime(sectorTimes[2])}</span></td>
              <td class="f1-time ${lastLapClass}">${this.formatTimeMs(car.lastLapTime)}</td>
              <td class="f1-time ${bestLapClass}">${this.formatTimeMs(car.bestLapTime)}</td>
              <td><span class="f1-tire ${compound}">${compound.charAt(0).toUpperCase()}</span></td>
              <td class="f1-laps">${car.lap}</td>
            </tr>
          `;
        }
        
        tbody.innerHTML = html;
      }
    };

    // ═══════════════════════════════════════════════════════════════════════════════
    // INIT
    // ═══════════════════════════════════════════════════════════════════════════════

    // ═══════════════════════════════════════════════════════════════
    // DRIVER NAMES — F1 driver names for all 20 entries
    // ═══════════════════════════════════════════════════════════════
    const driverNames = [
      'M. Verstappen', 'S. Pérez',     // Red Bull
      'C. Leclerc',    'C. Sainz',      // Ferrari
      'L. Hamilton',   'G. Russell',    // Mercedes
      'L. Norris',     'O. Piastri',    // McLaren
      'F. Alonso',     'L. Stroll',     // Aston Martin
      'P. Gasly',      'E. Ocon',       // Alpine
      'A. Albon',      'L. Sargeant',   // Williams
      'D. Ricciardo',  'Y. Tsunoda',    // RB
      'V. Bottas',     'G. Zhou',       // Sauber
      'K. Magnussen',  'N. Hülkenberg', // Haas
    ];

    // ═══════════════════════════════════════════════════════════════
    // LOADING SCREEN — Marketing-psychology optimized progress bars
    // ═══════════════════════════════════════════════════════════════
    const LoadingScreen = {
      hints: [
        'Initializing telemetry systems...',
        'Calibrating aerodynamic coefficients...',
        'Computing brake envelopes...',
        'Generating tyre degradation models...',
        'Synchronizing race control...',
        'Preparing grid formation...',
        'Loading track surface data...',
        'Optimizing fuel strategies...',
      ],
      _hintIdx: 0,

      start() {
        const el = document.getElementById('loadingScreen');
        if (!el) return this.finish();

        const bars = [
          { fill: document.getElementById('loadBar1'), pct: document.getElementById('loadPct1') },
          { fill: document.getElementById('loadBar2'), pct: document.getElementById('loadPct2') },
          { fill: document.getElementById('loadBar3'), pct: document.getElementById('loadPct3') },
        ];
        const hintEl = document.getElementById('loadingHint');

        // Marketing-psychology curve: fast start → slow middle → fast finish
        let t = 0;
        const TOTAL = 2200;
        const STEP = 50;
        const stagger = [0, 400, 800];
        const barDuration = [1200, 1000, 800];

        const animate = () => {
          t += STEP;
          for (let i = 0; i < 3; i++) {
            const elapsed = t - stagger[i];
            if (elapsed < 0) continue;
            const progress = Math.min(1, elapsed / barDuration[i]);
            // Eased curve: fast-slow-fast (quadratic ease-in-out)
            const eased = progress < 0.5
              ? 2 * progress * progress
              : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            const pctVal = Math.round(eased * 100);
            bars[i].fill.style.width = pctVal + '%';
            bars[i].pct.textContent = pctVal + '%';
          }

          if (t % 300 === 0) {
            this._hintIdx = (this._hintIdx + 1) % this.hints.length;
            if (hintEl) hintEl.textContent = this.hints[this._hintIdx];
          }

          if (t < TOTAL) {
            setTimeout(animate, STEP);
          } else {
            for (let i = 0; i < 3; i++) {
              bars[i].fill.style.width = '100%';
              bars[i].pct.textContent = '100%';
            }
            if (hintEl) hintEl.textContent = 'Ready!';
            setTimeout(() => this.finish(), 400);
          }
        };
        setTimeout(animate, STEP);
      },

      finish() {
        const el = document.getElementById('loadingScreen');
        if (el) {
          el.classList.add('fade-out');
          setTimeout(() => {
            el.classList.add('hidden');
            // ═══ MOTORSPORT MANAGER INTEGRATION ═══
            // If MM_raceConfig exists, skip menu and auto-start race
            if (MotorsportManagerBridge.hasConfig()) {
              MotorsportManagerBridge.applyConfig();
            } else {
              MainMenu.show();
            }
          }, 600);
        } else {
          if (MotorsportManagerBridge.hasConfig()) {
            MotorsportManagerBridge.applyConfig();
          } else {
            MainMenu.show();
          }
        }
      }
    };

    // ═══════════════════════════════════════════════════════════════
    // RACE FINISH MANAGER — Detects race end & shows ranking
    // ═══════════════════════════════════════════════════════════════
    const RaceFinish = {
      finished: false,
      finishOrder: [],        // Array of {car, finishTime}
      leaderFinishTime: null,  // Sim time when leader crossed finish
      _animatedCount: 0,

      reset() {
        this.finished = false;
        this.finishOrder = [];
        this.leaderFinishTime = null;
        this._animatedCount = 0;
      },

      // Called every sim step to check if any car has finished
      check() {
        if (this.finished || !MultiCarRace.isActive) return;

        for (const car of MultiCarRace.cars) {
          if (car._raceFinished) continue;
          if (car.lap > Track.totalLaps) {
            car._raceFinished = true;
            car._finishTime = Simulation.time;
            this.finishOrder.push({ car, finishTime: Simulation.time });

            if (!this.leaderFinishTime) {
              this.leaderFinishTime = Simulation.time;
            }
          }
        }

        // Race is fully over when all cars have finished
        if (this.finishOrder.length === MultiCarRace.cars.length) {
          this.endRace();
        }
        // Or after 60s past leader finish, end for remaining
        else if (this.leaderFinishTime && (Simulation.time - this.leaderFinishTime) > 60) {
          // Mark remaining cars as DNF
          for (const car of MultiCarRace.cars) {
            if (!car._raceFinished) {
              car._raceFinished = true;
              car._finishTime = Simulation.time;
              car._dnf = true;
              this.finishOrder.push({ car, finishTime: Simulation.time, dnf: true });
            }
          }
          this.endRace();
        }
      },

      endRace() {
        this.finished = true;
        Simulation.running = false;

        // Notify multiplayer peers if active
        if (Multiplayer.isConnected) {
          Multiplayer.broadcast({ type: 'race_finished', finishOrder: this.finishOrder.map(f => ({
            id: f.car.id, name: f.car.name, number: f.car.number, color: f.car.color,
            finishTime: f.finishTime, bestLapTime: f.car.bestLapTime, dnf: f.dnf || false
          }))});
        }

        // ═══ MOTORSPORT MANAGER: Send results back ═══
        MotorsportManagerBridge.sendResult(this.finishOrder);

        // Show ranking after short delay
        setTimeout(() => this.showRanking(), 800);
      },

      showRanking() {
        const overlay = document.getElementById('raceFinishOverlay');
        const container = document.getElementById('rfRankingContainer');
        container.innerHTML = '';

        const leaderTime = this.finishOrder[0]?.finishTime || 0;
        this._animatedCount = 0;

        this.finishOrder.forEach((entry, idx) => {
          const pos = idx + 1;
          const gap = idx === 0 ? 'WINNER' : (entry.dnf ? 'DNF' : `+${(entry.finishTime - leaderTime).toFixed(3)}s`);
          const medal = pos === 1 ? '🥇' : pos === 2 ? '🥈' : pos === 3 ? '🥉' : `P${pos}`;
          const bestLap = entry.car.bestLapTime < Infinity ? entry.car.bestLapTime.toFixed(3) + 's' : '—';

          const row = document.createElement('div');
          row.style.cssText = `
            display: flex; align-items: center; gap: 14px; padding: 12px 18px;
            background: ${pos <= 3 ? 'rgba(0,255,136,0.08)' : 'var(--bg-card)'};
            border-radius: 10px; margin-bottom: 6px; border-left: 4px solid ${entry.car.color};
            opacity: 0; transform: translateX(-40px);
            transition: opacity 0.5s ease, transform 0.5s ease;
          `;
          row.innerHTML = `
            <span style="font-size:${pos <= 3 ? '28px' : '18px'}; min-width:44px; text-align:center;">${medal}</span>
            <div style="width:14px; height:14px; border-radius:50%; background:${entry.car.color}; flex-shrink:0;"></div>
            <div style="flex:1;">
              <div style="font-weight:900; font-size:${pos <= 3 ? '16px' : '14px'};">#${entry.car.number} ${entry.car.name}</div>
              <div style="font-size:11px; color:var(--text-secondary);">Best Lap: ${bestLap}</div>
            </div>
            <div style="font-weight:900; font-size:14px; color:${idx === 0 ? '#00ff88' : (entry.dnf ? '#ff4444' : 'var(--text-secondary)')};">${gap}</div>
          `;
          container.appendChild(row);

          // Staggered animation
          setTimeout(() => {
            row.style.opacity = '1';
            row.style.transform = 'translateX(0)';
          }, 150 * (idx + 1));
        });

        overlay.classList.remove('hidden');

        // Wire buttons
        document.getElementById('rfBackToMenu').onclick = () => {
          overlay.classList.add('hidden');
          RaceFinish.reset();
          SoundEngine.stopAll();
          ParticleSystem.clear();
          document.getElementById('mainApp').style.display = 'none';
          MainMenu.show();
        };
        document.getElementById('rfRestartRace').onclick = () => {
          overlay.classList.add('hidden');
          RaceFinish.reset();
          SoundEngine.stopAll();
          ParticleSystem.clear();
          Simulation.reset();
          Simulation.running = true;
          document.getElementById('startBtn').textContent = '⏸ PAUSE';
          document.getElementById('startBtn').classList.remove('primary');
        };
      }
    };

    // ═══════════════════════════════════════════════════════════════
    // MULTIPLAYER MANAGER — SERVER-AUTHORITATIVE MODEL
    // ═══════════════════════════════════════════════════════════════
    // HOST = Physics server: runs Simulation.step() for ALL cars,
    //        broadcasts full world state to all clients at ~20Hz.
    // CLIENT = Render-only: receives world state, updates local
    //          car objects, renders. Can only send COMMANDS
    //          (pit, leave pit, setup change).
    // NO AI: Only connected players have cars on the grid.
    // ═══════════════════════════════════════════════════════════════
    const Multiplayer = {
      peer: null,
      connections: [],       // Active PeerJS DataConnections
      isHost: false,
      isConnected: false,
      isMultiplayerRace: false,   // True when in a multiplayer race (host or client)
      nickname: '',
      lobbyCode: '',
      players: [],           // [{peerId, nickname, ready, carIndex}]
      localCarIndex: 0,
      _syncInterval: null,
      _lobbyInterval: null,

      // ── Generate a short lobby code ──
      generateCode() {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = '';
        for (let i = 0; i < 5; i++) code += chars[Math.floor(Math.random() * chars.length)];
        return code;
      },

      // ── Show lobby overlay ──
      showLobby() {
        const lobby = document.getElementById('mpLobby');
        lobby.classList.remove('hidden');
        document.getElementById('mpNicknameSection').style.display = '';
        document.getElementById('mpChoiceSection').style.display = 'none';
        document.getElementById('mpJoinSection').style.display = 'none';
        document.getElementById('mpRoomSection').style.display = 'none';
        document.getElementById('mpStatus').textContent = 'Enter a nickname to start';
        document.getElementById('mpNickname').value = this.nickname || '';
        document.getElementById('mpNickname').focus();
      },

      hideLobby() {
        document.getElementById('mpLobby').classList.add('hidden');
      },

      // ── Initialize PeerJS ──
      initPeer(callback) {
        const peerPrefix = 'rm1-' + this.lobbyCode + '-';
        const peerId = this.isHost
          ? peerPrefix + 'host'
          : peerPrefix + 'p' + Math.floor(Math.random() * 100000);

        try {
          this.peer = new Peer(peerId, {
            debug: 0,
            config: {
              iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
              ]
            }
          });
        } catch (e) {
          document.getElementById('mpStatus').textContent = '❌ PeerJS failed to load. Check your connection.';
          return;
        }

        this.peer.on('open', (id) => {
          console.log('[MP] Peer open:', id);
          this.isConnected = true;
          if (callback) callback();
        });

        this.peer.on('error', (err) => {
          console.error('[MP] Peer error:', err);
          if (err.type === 'unavailable-id') {
            document.getElementById('mpStatus').textContent = '❌ Lobby code already in use. Try another.';
          } else if (err.type === 'peer-unavailable') {
            document.getElementById('mpStatus').textContent = '❌ Lobby not found. Check the code.';
          } else {
            document.getElementById('mpStatus').textContent = `❌ Connection error: ${err.type}`;
          }
        });

        this.peer.on('connection', (conn) => {
          this.handleConnection(conn);
        });
      },

      // ── Handle incoming connection ──
      handleConnection(conn) {
        conn.on('open', () => {
          console.log('[MP] Connection from:', conn.peer);
          this.connections.push(conn);

          conn.on('data', (data) => this.onMessage(conn, data));
          conn.on('close', () => this.onDisconnect(conn));

          // Send current lobby state to new player
          if (this.isHost) {
            conn.send({
              type: 'lobby_state',
              players: this.players,
              laps: parseInt(document.getElementById('mpLaps').value) || 5,
              trackName: Track.name || 'Speed Oval'
            });
          }
        });
      },

      // ── Host a lobby ──
      hostLobby() {
        this.isHost = true;
        this.lobbyCode = this.generateCode();
        this.players = [{
          peerId: null,
          nickname: this.nickname,
          ready: true,   // Host is always ready
          carIndex: 0,
          isHost: true
        }];

        document.getElementById('mpStatus').textContent = 'Creating lobby...';
        this.initPeer(() => {
          this.players[0].peerId = this.peer.id;
          this.showRoom();
        });
      },

      // ── Join a lobby ──
      joinLobby(code) {
        this.isHost = false;
        this.lobbyCode = code.toUpperCase().trim();
        if (this.lobbyCode.length < 3) {
          document.getElementById('mpStatus').textContent = '❌ Invalid lobby code';
          return;
        }

        document.getElementById('mpStatus').textContent = 'Connecting...';
        this.initPeer(() => {
          const hostId = 'rm1-' + this.lobbyCode + '-host';
          const conn = this.peer.connect(hostId, { reliable: true });
          conn.on('open', () => {
            console.log('[MP] Connected to host');
            this.connections.push(conn);
            conn.on('data', (data) => this.onMessage(conn, data));
            conn.on('close', () => this.onDisconnect(conn));
            conn.send({ type: 'join', nickname: this.nickname, peerId: this.peer.id });
          });
          conn.on('error', (err) => {
            document.getElementById('mpStatus').textContent = '❌ Could not connect to host';
          });
        });
      },

      // ── Show the lobby room ──
      showRoom() {
        document.getElementById('mpNicknameSection').style.display = 'none';
        document.getElementById('mpChoiceSection').style.display = 'none';
        document.getElementById('mpJoinSection').style.display = 'none';
        document.getElementById('mpRoomSection').style.display = '';
        document.getElementById('mpLobbyCode').textContent = this.lobbyCode;
        document.getElementById('mpStatus').textContent = this.isHost
          ? '🖥️ You are the SERVER (physics host)'
          : '🎮 Connected — waiting for server to start';

        document.getElementById('mpSettingsSection').style.display = this.isHost ? '' : 'none';
        document.getElementById('mpStartRace').style.display = this.isHost ? '' : 'none';
        document.getElementById('mpReady').style.display = this.isHost ? 'none' : '';

        this.updatePlayerList();

        if (this._lobbyInterval) clearInterval(this._lobbyInterval);
        this._lobbyInterval = setInterval(() => this.updatePlayerList(), 1000);
      },

      // ── Update player list UI ──
      updatePlayerList() {
        const list = document.getElementById('mpPlayerList');
        const count = document.getElementById('mpPlayerCount');
        if (!list) return;

        count.textContent = this.players.length;
        list.innerHTML = '';

        this.players.forEach((p, idx) => {
          const teamColor = (typeof RaceUI !== 'undefined' && RaceUI.teams[idx]) ? RaceUI.teams[idx].color : '#888';
          const card = document.createElement('div');
          card.style.cssText = `
            display: flex; align-items: center; gap: 10px; padding: 10px 14px;
            background: var(--bg-panel); border-radius: 8px; border-left: 3px solid ${teamColor};
          `;
          card.innerHTML = `
            <div style="width:10px; height:10px; border-radius:50%; background:${teamColor};"></div>
            <span style="flex:1; font-weight:700; font-size:14px;">${p.nickname}</span>
            ${p.isHost ? '<span style="font-size:11px; color:var(--accent-cyan); font-weight:700;">🖥️ SERVER</span>' : ''}
            <span style="font-size:11px; color:${p.ready ? '#00ff88' : '#ff6666'}; font-weight:700;">
              ${p.ready ? '✓ READY' : '⏳ WAITING'}
            </span>
          `;
          list.appendChild(card);
        });
      },

      // ── Handle messages ──
      onMessage(conn, data) {
        if (!data || !data.type) return;

        switch (data.type) {
          case 'join':
            if (this.isHost) {
              const carIdx = this.players.length;
              if (carIdx >= 20) {
                conn.send({ type: 'error', msg: 'Lobby is full (max 20 players)' });
                return;
              }
              this.players.push({
                peerId: data.peerId,
                nickname: data.nickname,
                ready: false,
                carIndex: carIdx,
                isHost: false,
                conn: conn
              });
              this.broadcastLobbyState();
              this.updatePlayerList();
            }
            break;

          case 'lobby_state':
            this.players = data.players;
            const me = this.players.find(p => p.peerId === this.peer?.id);
            if (me) this.localCarIndex = me.carIndex;
            this.showRoom();
            document.getElementById('mpTrackName').textContent = data.trackName || 'Speed Oval';
            break;

          case 'player_ready':
            if (this.isHost) {
              const pl = this.players.find(p => p.peerId === data.peerId);
              if (pl) pl.ready = data.ready;
              this.broadcastLobbyState();
              this.updatePlayerList();
            }
            break;

          case 'race_start':
            // Client receives race start from server
            this.startRaceAsClient(data);
            break;

          // ═══════════════════════════════════════════════════
          // SERVER → CLIENT: Full world state (received on client)
          // ═══════════════════════════════════════════════════
          case 'world_state':
            this.applyWorldState(data);
            break;

          // ═══════════════════════════════════════════════════
          // CLIENT → SERVER: Player commands (received on host)
          // ═══════════════════════════════════════════════════
          case 'cmd_pit_arm':
            if (this.isHost) this.handlePlayerCommand(data, conn);
            break;
          case 'cmd_pit_cancel':
            if (this.isHost) this.handlePlayerCommand(data, conn);
            break;
          case 'cmd_pit_exit':
            if (this.isHost) this.handlePlayerCommand(data, conn);
            break;
          case 'cmd_setup_change':
            if (this.isHost) this.handlePlayerCommand(data, conn);
            break;

          case 'race_finished':
            if (!this.isHost) {
              // Client receives final results from server
              this.applyRaceFinished(data);
            }
            break;

          case 'player_left':
            this.players = this.players.filter(p => p.peerId !== data.peerId);
            this.updatePlayerList();
            break;

          case 'error':
            document.getElementById('mpStatus').textContent = '❌ ' + (data.msg || 'Error');
            break;
        }
      },

      // ═══════════════════════════════════════════════════════════════
      // SERVER: Handle player commands (pit/setup)
      // ═══════════════════════════════════════════════════════════════
      handlePlayerCommand(data, conn) {
        if (!MultiCarRace.isActive) return;
        // Find the car belonging to this player
        const player = this.players.find(p => p.conn === conn);
        if (!player) return;
        const car = MultiCarRace.cars[player.carIndex];
        if (!car) return;

        console.log(`[SERVER] Command ${data.type} from ${player.nickname} (car ${player.carIndex})`);

        switch (data.type) {
          case 'cmd_pit_arm':
            if (!car.pit.inLane && !car.pit.committed) {
              car.pit.armed = true;
              car.pit.phase = 'approach';
            }
            break;

          case 'cmd_pit_cancel':
            if (car.pit.armed && !car.pit.committed) {
              car.pit.armed = false;
              car.pit.phase = 'none';
            }
            break;

          case 'cmd_pit_exit':
            if (car.pit.inLane && car.pit.phase === 'stopped') {
              car.pit.exitRequested = true;
            }
            break;

          case 'cmd_setup_change':
            // Apply setup changes (only when in pit box)
            if (car.pit.inLane && car.pit.phase === 'stopped' && data.setup) {
              const allowed = ['rideHeight','springK','damperC','wingAngle','camber',
                              'cLWing','cLDiffuser','cDBody','cDWing','tireGrip','brakeForce','fuelCapacity'];
              for (const key of allowed) {
                if (data.setup[key] !== undefined) {
                  car.setup[key] = data.setup[key];
                }
              }
              // Apply tire compound change
              if (data.compound && car.tire) {
                car.tire.compound = data.compound;
                car.tire.condition = 1.0;
              }
              // Refuel
              if (data.fuel !== undefined) {
                car.fuel = Math.min(data.fuel, car.setup.fuelCapacity || 110);
              }
            }
            break;
        }
      },

      // ── Handle disconnect ──
      onDisconnect(conn) {
        console.log('[MP] Disconnected:', conn.peer);
        this.connections = this.connections.filter(c => c !== conn);

        if (this.isHost) {
          const player = this.players.find(p => p.conn === conn);
          if (player) {
            console.log(`[SERVER] Player ${player.nickname} disconnected`);
            this.players = this.players.filter(p => p !== player);
            this.players.forEach((p, i) => p.carIndex = i);
            this.broadcastLobbyState();
            this.updatePlayerList();
          }
        }
      },

      // ── Broadcast to all connections ──
      broadcast(data) {
        for (const conn of this.connections) {
          try { conn.send(data); } catch (e) { /* ignore closed conn */ }
        }
      },

      broadcastLobbyState() {
        this.broadcast({
          type: 'lobby_state',
          players: this.players.map(p => ({
            peerId: p.peerId, nickname: p.nickname, ready: p.ready,
            carIndex: p.carIndex, isHost: p.isHost
          })),
          laps: parseInt(document.getElementById('mpLaps')?.value) || 5,
          trackName: Track.name || 'Speed Oval'
        });
      },

      // ═══════════════════════════════════════════════════════════════
      // SERVER: Start race (host only)
      // Creates cars ONLY for connected players — no AI!
      // ═══════════════════════════════════════════════════════════════
      startRaceFromHost() {
        if (!this.isHost) return;
        const totalLaps = parseInt(document.getElementById('mpLaps').value) || 5;

        // Only player cars — one per connected player
        const carAssignments = this.players.map((p, i) => ({
          carIndex: i,
          peerId: p.peerId,
          nickname: p.nickname,
          teamIndex: i  // maps to RaceUI.teams[i] for color/number
        }));

        // Broadcast race start to all clients
        this.broadcast({
          type: 'race_start',
          carAssignments,
          totalLaps,
          trackName: Track.name || 'Speed Oval'
        });

        // Start race locally as server
        this.isMultiplayerRace = true;
        this.startRaceAsServer(carAssignments, totalLaps);
      },

      // ═══════════════════════════════════════════════════════════════
      // SERVER: Initialize race and start physics + broadcast loop
      // ═══════════════════════════════════════════════════════════════
      startRaceAsServer(carAssignments, totalLaps) {
        this.hideLobby();
        if (this._lobbyInterval) { clearInterval(this._lobbyInterval); this._lobbyInterval = null; }

        Track.totalLaps = totalLaps;
        TrackEditor.loadDefault();

        setTimeout(() => {
          if (!MultiCarRace.isActive || !MultiCarRace.cars.length) return;

          // Set controlled car to host's car (index 0)
          this.localCarIndex = 0;
          RaceUI.controlledCarId = MultiCarRace.cars[0].id;
          const selector = document.getElementById('carSelector');
          if (selector) selector.value = RaceUI.controlledCarId;

          // Name cars after players, remove ALL AI
          for (const assignment of carAssignments) {
            if (assignment.carIndex < MultiCarRace.cars.length) {
              const car = MultiCarRace.cars[assignment.carIndex];
              car.name = assignment.nickname;
              car.ai = null;  // NO AI — server runs physics, players send commands
              car._playerPeerId = assignment.peerId;
            }
          }

          // Remove extra cars beyond player count
          while (MultiCarRace.cars.length > carAssignments.length) {
            MultiCarRace.cars.pop();
          }

          if (typeof RaceUI !== 'undefined') {
            RaceUI.updateCarSelector();
            RaceUI.updateLiveTiming();
          }

          // Start server world broadcast at ~20Hz
          this.startServerBroadcast();

          // Auto-start
          Simulation.running = true;
          document.getElementById('startBtn').textContent = '⏸ PAUSE';
          document.getElementById('startBtn').classList.remove('primary');
        }, 500);
      },

      // ═══════════════════════════════════════════════════════════════
      // CLIENT: Receive race start from server
      // ═══════════════════════════════════════════════════════════════
      startRaceAsClient(data) {
        const myAssignment = data.carAssignments.find(a => a.peerId === this.peer?.id);
        if (myAssignment) {
          this.localCarIndex = myAssignment.carIndex;
        }

        this.isMultiplayerRace = true;
        this.hideLobby();
        if (this._lobbyInterval) { clearInterval(this._lobbyInterval); this._lobbyInterval = null; }

        Track.totalLaps = data.totalLaps;
        TrackEditor.loadDefault();

        setTimeout(() => {
          if (!MultiCarRace.isActive || !MultiCarRace.cars.length) return;

          // Set our controlled car
          if (this.localCarIndex >= 0 && this.localCarIndex < MultiCarRace.cars.length) {
            RaceUI.controlledCarId = MultiCarRace.cars[this.localCarIndex].id;
            const selector = document.getElementById('carSelector');
            if (selector) selector.value = RaceUI.controlledCarId;
          }

          // Name all cars after players, remove ALL AI
          for (const assignment of data.carAssignments) {
            if (assignment.carIndex < MultiCarRace.cars.length) {
              const car = MultiCarRace.cars[assignment.carIndex];
              car.name = assignment.nickname;
              car.ai = null;
              car._playerPeerId = assignment.peerId;
            }
          }

          // Remove extra cars
          while (MultiCarRace.cars.length > data.carAssignments.length) {
            MultiCarRace.cars.pop();
          }

          if (typeof RaceUI !== 'undefined') {
            RaceUI.updateCarSelector();
            RaceUI.updateLiveTiming();
          }

          // CLIENT: DO NOT start Simulation.running!
          // Physics runs on the server only. We just render.
          // But we do need the game loop for rendering:
          Simulation.running = false;  // No local physics
          Simulation.lastFrameTime = performance.now();

          // Show "Connected to server" indicator
          document.getElementById('startBtn').textContent = '🌐 LIVE';
          document.getElementById('startBtn').classList.remove('primary');
          document.getElementById('startBtn').style.pointerEvents = 'none';
        }, 500);
      },

      // ═══════════════════════════════════════════════════════════════
      // SERVER: Broadcast full world state to all clients at ~20Hz
      // This is the ONLY source of truth for all car positions.
      // ═══════════════════════════════════════════════════════════════
      startServerBroadcast() {
        if (this._syncInterval) clearInterval(this._syncInterval);

        this._syncInterval = setInterval(() => {
          if (!MultiCarRace.isActive) return;

          // Build compact world state for all cars
          const worldCars = MultiCarRace.cars.map(car => ({
            id: car.id,
            s: Math.round(car.s * 100) / 100,
            v: Math.round(car.v * 100) / 100,
            a: Math.round((car.a || 0) * 10) / 10,
            lane: Math.round(car.lane * 100) / 100,
            lap: car.lap,
            throttle: Math.round(car.throttle),
            brake: Math.round(car.brake),
            fuel: Math.round(car.fuel * 10) / 10,
            tireCond: car.tire ? Math.round(car.tire.condition * 1000) / 1000 : 1,
            tireComp: car.tire ? car.tire.compound : 'medium',
            pit: car.pit ? {
              armed: car.pit.armed,
              committed: car.pit.committed,
              inLane: car.pit.inLane,
              limiter: car.pit.limiter,
              stopped: car.pit.stopped,
              phase: car.pit.phase,
            } : null,
            lastLapTime: car.lastLapTime,
            bestLapTime: car.bestLapTime < Infinity ? car.bestLapTime : null,
            currentLapTime: car.currentLapTime,
            finished: car._raceFinished || false,
            slipK: car.slipstream ? {
              kDrag: Math.round(car.slipstream.kDrag * 1000) / 1000,
              kCL: Math.round(car.slipstream.kCL * 1000) / 1000
            } : null
          }));

          this.broadcast({
            type: 'world_state',
            t: Math.round(Simulation.time * 1000) / 1000,
            cars: worldCars,
            running: Simulation.running
          });
        }, 50); // 20 Hz
      },

      // ═══════════════════════════════════════════════════════════════
      // CLIENT: Apply received world state from server
      // ═══════════════════════════════════════════════════════════════
      applyWorldState(data) {
        if (this.isHost) return;  // Server doesn't apply its own state
        if (!MultiCarRace.isActive) return;

        Simulation.time = data.t;

        for (const carData of data.cars) {
          const car = MultiCarRace.cars.find(c => c.id === carData.id);
          if (!car) continue;

          // Smooth interpolation for position (prevents jitter)
          const lerp = 0.4;
          car.s = car.s + (carData.s - car.s) * lerp;
          car.v = car.v + (carData.v - car.v) * lerp;
          car.a = carData.a;
          car.lane = car.lane + (carData.lane - car.lane) * lerp;
          
          // Update visualS for smooth rendering
          if (car.visualS === undefined) car.visualS = car.s;
          car.visualS += (car.s - car.visualS) * 0.2;
          if (Math.abs(car.visualS - car.s) < 1) car.visualS = car.s;
          if (car.visualS < 0) car.visualS += Track.lapLength;
          if (car.visualS >= Track.lapLength) car.visualS -= Track.lapLength;

          // Direct-set non-visual state
          car.lap = Math.max(car.lap, carData.lap);
          car.throttle = carData.throttle;
          car.brake = carData.brake;
          car.fuel = carData.fuel;
          car.lastLapTime = carData.lastLapTime;
          if (carData.bestLapTime != null) car.bestLapTime = carData.bestLapTime;
          car.currentLapTime = carData.currentLapTime;
          car._raceFinished = carData.finished;

          // Tire
          if (car.tire) {
            car.tire.condition = carData.tireCond;
            car.tire.compound = carData.tireComp;
          }

          // Pit state
          if (car.pit && carData.pit) {
            car.pit.armed = carData.pit.armed;
            car.pit.committed = carData.pit.committed;
            car.pit.inLane = carData.pit.inLane;
            car.pit.limiter = carData.pit.limiter;
            car.pit.stopped = carData.pit.stopped;
            car.pit.phase = carData.pit.phase;
          }

          // Slipstream visual
          if (carData.slipK) {
            car.slipstream = carData.slipK;
          }
        }

        // Sync the controlled car state to global Car object (for UI/telemetry)
        const controlled = MultiCarRace.cars.find(c => c.id === RaceUI.controlledCarId);
        if (controlled) {
          Car.s = controlled.s;
          Car.v = controlled.v;
          Car.a = controlled.a;
          Car.lap = controlled.lap;
          Car.throttle = controlled.throttle;
          Car.brake = controlled.brake;
          Car.lastLapTime = controlled.lastLapTime;
          Car.bestLapTime = controlled.bestLapTime;
          Car.fuel = controlled.fuel;
          Car.currentLapTime = controlled.currentLapTime;
          Car.vLimit = controlled.vLimit;
          Car.pit.armed = controlled.pit.armed;
          Car.pit.committed = controlled.pit.committed;
          Car.pit.inLane = controlled.pit.inLane;
          Car.pit.limiter = controlled.pit.limiter;
          Car.pit.stopped = controlled.pit.stopped;
          Car.pit.phase = controlled.pit.phase;
          if (controlled.tire && typeof Tire !== 'undefined') {
            Tire.condition = controlled.tire.condition;
            Tire.compound = controlled.tire.compound;
          }
          UI.syncPitButtons();
        }

        // Update live timing
        if (typeof RaceUI !== 'undefined') RaceUI.updateLiveTiming();
      },

      // ═══════════════════════════════════════════════════════════════
      // CLIENT: Apply race finish results from server
      // ═══════════════════════════════════════════════════════════════
      applyRaceFinished(data) {
        Simulation.running = false;
        // Build finish order for RaceFinish display
        RaceFinish.finished = true;
        RaceFinish.finishOrder = data.finishOrder.map(f => {
          const car = MultiCarRace.cars.find(c => c.id === f.id) || {
            id: f.id, name: f.name, number: f.number, color: f.color,
            bestLapTime: f.bestLapTime || Infinity
          };
          return { car, finishTime: f.finishTime, dnf: f.dnf };
        });
        setTimeout(() => RaceFinish.showRanking(), 800);
      },

      // ═══════════════════════════════════════════════════════════════
      // CLIENT: Send command to server (called by UI buttons)
      // ═══════════════════════════════════════════════════════════════
      sendCommand(type, payload = {}) {
        if (this.isHost) {
          // Host processes commands directly on local cars
          this.handleLocalHostCommand(type, payload);
          return;
        }
        // Client sends to server
        for (const conn of this.connections) {
          try {
            conn.send({ type, ...payload });
          } catch (e) {}
        }
      },

      // HOST: Handle own commands locally (host is also a player)
      handleLocalHostCommand(type, payload) {
        const car = MultiCarRace.cars[this.localCarIndex];
        if (!car) return;

        switch (type) {
          case 'cmd_pit_arm':
            if (!car.pit.inLane && !car.pit.committed) {
              car.pit.armed = true;
              car.pit.phase = 'approach';
            }
            break;
          case 'cmd_pit_cancel':
            if (car.pit.armed && !car.pit.committed) {
              car.pit.armed = false;
              car.pit.phase = 'none';
            }
            break;
          case 'cmd_pit_exit':
            if (car.pit.inLane && car.pit.phase === 'stopped') {
              car.pit.exitRequested = true;
            }
            break;
          case 'cmd_setup_change':
            if (car.pit.inLane && car.pit.phase === 'stopped' && payload.setup) {
              const allowed = ['rideHeight','springK','damperC','wingAngle','camber',
                              'cLWing','cLDiffuser','cDBody','cDWing','tireGrip','brakeForce','fuelCapacity'];
              for (const key of allowed) {
                if (payload.setup[key] !== undefined) car.setup[key] = payload.setup[key];
              }
              if (payload.compound && car.tire) {
                car.tire.compound = payload.compound;
                car.tire.condition = 1.0;
              }
              if (payload.fuel !== undefined) {
                car.fuel = Math.min(payload.fuel, car.setup.fuelCapacity || 110);
              }
            }
            break;
        }
        UI.syncPitButtons();
      },

      // ── Leave lobby / disconnect ──
      leave() {
        if (this._syncInterval) { clearInterval(this._syncInterval); this._syncInterval = null; }
        if (this._lobbyInterval) { clearInterval(this._lobbyInterval); this._lobbyInterval = null; }

        if (this.peer) {
          this.broadcast({ type: 'player_left', peerId: this.peer.id });
          this.connections.forEach(c => { try { c.close(); } catch(e) {} });
          this.connections = [];
          try { this.peer.destroy(); } catch(e) {}
          this.peer = null;
        }

        this.isConnected = false;
        this.isHost = false;
        this.isMultiplayerRace = false;
        this.players = [];
        this.lobbyCode = '';
      },

      // ── Init lobby UI event handlers ──
      initUI() {
        document.getElementById('mpNickname').addEventListener('keyup', (e) => {
          const val = e.target.value.trim();
          if (val.length >= 2) {
            document.getElementById('mpChoiceSection').style.display = 'flex';
          } else {
            document.getElementById('mpChoiceSection').style.display = 'none';
          }
          if (e.key === 'Enter' && val.length >= 2) {
            this.nickname = val;
            document.getElementById('mpHostBtn').click();
          }
        });

        document.getElementById('mpHostBtn').addEventListener('click', () => {
          this.nickname = document.getElementById('mpNickname').value.trim();
          if (this.nickname.length < 2) return;
          this.hostLobby();
        });

        document.getElementById('mpJoinBtn').addEventListener('click', () => {
          this.nickname = document.getElementById('mpNickname').value.trim();
          if (this.nickname.length < 2) return;
          document.getElementById('mpNicknameSection').style.display = 'none';
          document.getElementById('mpChoiceSection').style.display = 'none';
          document.getElementById('mpJoinSection').style.display = '';
          document.getElementById('mpJoinCode').focus();
        });

        document.getElementById('mpJoinConfirm').addEventListener('click', () => {
          const code = document.getElementById('mpJoinCode').value.trim();
          if (code.length >= 3) this.joinLobby(code);
        });
        document.getElementById('mpJoinCode').addEventListener('keyup', (e) => {
          if (e.key === 'Enter') document.getElementById('mpJoinConfirm').click();
        });

        document.getElementById('mpJoinBack').addEventListener('click', () => {
          document.getElementById('mpJoinSection').style.display = 'none';
          document.getElementById('mpNicknameSection').style.display = '';
          document.getElementById('mpChoiceSection').style.display = 'flex';
        });

        document.getElementById('mpLobbyCode').addEventListener('click', () => {
          const code = document.getElementById('mpLobbyCode').textContent;
          navigator.clipboard.writeText(code).then(() => {
            document.getElementById('mpStatus').textContent = '📋 Lobby code copied!';
            setTimeout(() => {
              document.getElementById('mpStatus').textContent = this.isHost
                ? '🖥️ You are the SERVER'
                : '🎮 Connected to server';
            }, 2000);
          });
        });

        document.getElementById('mpReady').addEventListener('click', () => {
          const btn = document.getElementById('mpReady');
          const isReady = btn.textContent.includes('✓');
          const newReady = !isReady;

          btn.textContent = newReady ? '✗ NOT READY' : '✓ READY';
          btn.classList.toggle('primary', newReady);

          for (const conn of this.connections) {
            conn.send({ type: 'player_ready', peerId: this.peer.id, ready: newReady });
          }
        });

        document.getElementById('mpStartRace').addEventListener('click', () => {
          if (this.players.length < 2) {
            document.getElementById('mpStatus').textContent = '⚠️ Need at least 2 players';
            return;
          }
          this.startRaceFromHost();
        });

        document.getElementById('mpLeaveLobby').addEventListener('click', () => {
          this.leave();
          this.showLobby();
        });

        document.getElementById('mpBackToMenu').addEventListener('click', () => {
          this.leave();
          this.hideLobby();
          MainMenu.show();
        });
      }
    };

    // ═══════════════════════════════════════════════════════════════
    // MAIN MENU
    // ═══════════════════════════════════════════════════════════════
    const MainMenu = {
      _initialized: false,

      show() {
        document.getElementById('mainMenu').classList.remove('hidden');
      },

      hide() {
        document.getElementById('mainMenu').classList.add('hidden');
      },

      init() {
        if (this._initialized) return;
        this._initialized = true;

        document.getElementById('mmStartRace').addEventListener('click', () => {
          this.hide();
          TrackEditor.loadDefault();
        });

        document.getElementById('mmEditTrack').addEventListener('click', () => {
          this.hide();
          document.getElementById('trackEditorOverlay').classList.remove('hidden');
        });

        document.getElementById('mmEditCars').addEventListener('click', () => {
          this.hide();
          CarDriverEditor.show();
        });

        document.getElementById('mmMultiplayer').addEventListener('click', () => {
          this.hide();
          Multiplayer.showLobby();
        });

        // Init multiplayer UI handlers
        Multiplayer.initUI();
      }
    };

    // ═══════════════════════════════════════════════════════════════
    // CAR/DRIVER EDITOR
    // ═══════════════════════════════════════════════════════════════
    const CarDriverEditor = {
      _initialized: false,

      defaultSetup: {
        power: 760000, cLWing: 1.575, cLDiffuser: 1.925, cDBody: 0.700, cDWing: 0.200, mass: 800,
        tireGrip: 1.50, brakeForce: 35000, frontalArea: 1.80,
      },

      defaultSkills: {
        braking: 80, cornering: 80, accelerating: 80,
        tyre_mgmt: 80, fuel_mgmt: 80, consistency: 80, wet_pace: 75,
      },

      setupFields: [
        { key: 'power',       label: 'Power',      unit: 'kW',  step: 5000, min: 500000, max: 900000, display: v => (v/1000).toFixed(0), parse: v => parseFloat(v)*1000 },
        { key: 'cLWing',      label: 'Wing CL',    unit: '',    step: 0.01, min: 1.0,    max: 2.5 },
        { key: 'cLDiffuser',  label: 'Diffuser CL', unit: '',   step: 0.01, min: 1.0,    max: 3.0 },
        { key: 'cDBody',      label: 'Body CD',    unit: '',    step: 0.01, min: 0.4,    max: 1.0 },
        { key: 'cDWing',      label: 'Wing CD',    unit: '',    step: 0.005,min: 0.10,   max: 0.40 },
        { key: 'mass',        label: 'Mass',        unit: 'kg',  step: 1,    min: 750,    max: 850 },
        { key: 'tireGrip',    label: 'Grip μ',      unit: '',    step: 0.01, min: 1.4,    max: 2.0 },
        { key: 'brakeForce',  label: 'Brakes',      unit: 'kN',  step: 500,  min: 30000,  max: 40000, display: v => (v/1000).toFixed(1), parse: v => parseFloat(v)*1000 },
        { key: 'frontalArea', label: 'Area',        unit: 'm²',  step: 0.01, min: 1.6,    max: 2.0 },
      ],

      skillFields: [
        { key: 'braking',      label: 'Braking' },
        { key: 'cornering',    label: 'Cornering' },
        { key: 'accelerating', label: 'Accel' },
        { key: 'tyre_mgmt',    label: 'Tyre Mgmt' },
        { key: 'fuel_mgmt',    label: 'Fuel Mgmt' },
        { key: 'consistency',  label: 'Consistency' },
        { key: 'wet_pace',     label: 'Rain Skill' },
      ],

      show() {
        if (!this._initialized) this.init();
        this.buildCards();
        document.getElementById('carEditorOverlay').classList.remove('hidden');
      },

      hide() {
        document.getElementById('carEditorOverlay').classList.add('hidden');
      },

      init() {
        this._initialized = true;
        document.getElementById('ceBack').addEventListener('click', () => {
          this.hide();
          MainMenu.show();
        });
        document.getElementById('ceSave').addEventListener('click', () => {
          this.saveAll();
          this.hide();
          MainMenu.show();
        });
        document.getElementById('ceResetAll').addEventListener('click', () => {
          this.resetAllEqual();
          this.buildCards();
        });
      },

      buildCards() {
        const grid = document.getElementById('ceGrid');
        grid.innerHTML = '';
        const teams = RaceUI.teams;

        for (let i = 0; i < teams.length; i++) {
          const team = teams[i];
          const setup = RaceUI.teamSetups[i];
          const skills = driverSkillProfiles[i];
          const name = driverNames[i] || `Driver ${i+1}`;

          const card = document.createElement('div');
          card.className = 'ce-card';
          card.dataset.idx = i;

          let html = `
            <div class="ce-card-header">
              <div class="ce-car-swatch" style="background:${team.color}"></div>
              <div class="ce-car-number">#${team.number}</div>
              <div class="ce-car-team">${team.name}</div>
            </div>
            <input type="text" class="ce-driver-name" data-idx="${i}" value="${name}" placeholder="Driver name">
            <div class="ce-section-label">Car Performance</div>
          `;

          for (const f of this.setupFields) {
            const val = f.display ? f.display(setup[f.key]) : setup[f.key];
            html += `<div class="ce-field">
              <label>${f.label}</label>
              <input type="number" data-idx="${i}" data-key="${f.key}" data-field="setup"
                     value="${val}" step="${f.display ? 1 : f.step}" min="${f.display ? f.display(f.min) : f.min}" max="${f.display ? f.display(f.max) : f.max}">
              <span class="ce-unit">${f.unit}</span>
            </div>`;
          }

          html += `<div class="ce-section-label">Driver Skills</div>`;
          for (const sf of this.skillFields) {
            const val = skills[sf.key];
            html += `<div class="ce-skill-row">
              <label>${sf.label}</label>
              <input type="range" data-idx="${i}" data-key="${sf.key}" data-field="skill"
                     min="40" max="100" value="${val}">
              <span class="ce-skill-val" id="ceSkill_${i}_${sf.key}">${val}</span>
            </div>`;
          }

          card.innerHTML = html;

          card.querySelectorAll('input[type=range]').forEach(inp => {
            inp.addEventListener('input', () => {
              const valEl = document.getElementById(`ceSkill_${inp.dataset.idx}_${inp.dataset.key}`);
              if (valEl) valEl.textContent = inp.value;
            });
          });

          grid.appendChild(card);
        }
      },

      saveAll() {
        const grid = document.getElementById('ceGrid');
        const cards = grid.querySelectorAll('.ce-card');

        cards.forEach(card => {
          const idx = parseInt(card.dataset.idx);

          const nameInput = card.querySelector('.ce-driver-name');
          if (nameInput) driverNames[idx] = nameInput.value.trim() || `Driver ${idx+1}`;

          card.querySelectorAll('input[data-field="setup"]').forEach(inp => {
            const key = inp.dataset.key;
            const fieldDef = this.setupFields.find(f => f.key === key);
            const rawVal = parseFloat(inp.value);
            const val = fieldDef && fieldDef.parse ? fieldDef.parse(inp.value) : rawVal;
            if (!isNaN(val)) RaceUI.teamSetups[idx][key] = val;
          });

          card.querySelectorAll('input[data-field="skill"]').forEach(inp => {
            const key = inp.dataset.key;
            const val = parseInt(inp.value);
            if (!isNaN(val)) driverSkillProfiles[idx][key] = val;
          });
        });
      },

      resetAllEqual() {
        for (let i = 0; i < RaceUI.teamSetups.length; i++) {
          Object.assign(RaceUI.teamSetups[i], this.defaultSetup);
        }
        for (let i = 0; i < driverSkillProfiles.length; i++) {
          Object.assign(driverSkillProfiles[i], this.defaultSkills);
        }
      }
    };

    // ═══════════════════════════════════════════════════════════════
    // TRACK EDITOR — Table-based segment editor
    // ═══════════════════════════════════════════════════════════════
    const TrackEditor = {
      overlay: null,
      tbody: null,
      previewCanvas: null,
      previewCtx: null,

      init() {
        this.overlay       = document.getElementById('trackEditorOverlay');
        this.tbody         = document.getElementById('teTableBody');
        this.previewCanvas = document.getElementById('tePreviewCanvas');
        this.previewCtx    = this.previewCanvas.getContext('2d');

        document.getElementById('teBackToMenu').addEventListener('click', () => {
          this.overlay.classList.add('hidden');
          document.getElementById('mainMenu').classList.remove('hidden');
        });
        document.getElementById('teGenCustom').addEventListener('click',   () => this.generateCustom());
        document.getElementById('teAddRow').addEventListener('click',      () => this.addRow());

        // Weather schedule controls (in track editor)
        const addBtn = document.getElementById('wsAddBtn');
        const clearBtn = document.getElementById('wsClearBtn');
        if (addBtn) addBtn.addEventListener('click', () => WeatherUI.addScheduleWaypoint());
        if (clearBtn) clearBtn.addEventListener('click', () => {
          Weather.clearTimeline();
          WeatherUI.renderSchedule();
        });

        // Populate table from current Track.segments
        this.populateTable(Track.segments);

        // Sync track property fields
        document.getElementById('teTrackLaps').value = Track.totalLaps || 8;
        document.getElementById('teTrackName').value = Track.name || 'Speed Oval';

        // Render any existing weather schedule
        WeatherUI.renderSchedule();
      },

      // ── Fill table from segment array ──
      populateTable(segs) {
        this.tbody.innerHTML = '';
        for (let i = 0; i < segs.length; i++) {
          this.insertRow(segs[i], i);
        }
        this.updateInfo();
        this.drawPreview();
      },

      insertRow(seg, idx) {
        const tr = document.createElement('tr');
        const isCorner = seg.kind === 'corner';

        tr.innerHTML = `
          <td class="te-row-num">${idx + 1}</td>
          <td><select class="te-kind">
                <option value="straight" ${!isCorner ? 'selected' : ''}>Straight</option>
                <option value="corner"   ${ isCorner ? 'selected' : ''}>Corner</option>
              </select></td>
          <td><input type="number" class="te-length" value="${isCorner ? '' : (seg.length || 200)}" step="10" min="10" placeholder="—"
                     ${isCorner ? 'disabled' : ''}></td>
          <td><input type="number" class="te-angle" value="${isCorner ? (seg.angleDeg || 90) : ''}" step="5" min="1" max="270" placeholder="—"
                     ${!isCorner ? 'disabled' : ''}></td>
          <td><input type="number" class="te-radius" value="${isCorner ? (seg.radius || 80) : ''}" step="5" min="15" max="500" placeholder="—"
                     ${!isCorner ? 'disabled' : ''}></td>
          <td><select class="te-dir" ${!isCorner ? 'disabled' : ''}>
                <option value="1"  ${(seg.direction ||  1) ===  1 ? 'selected' : ''}>Left</option>
                <option value="-1" ${(seg.direction || -1) === -1 ? 'selected' : ''}>Right</option>
              </select></td>
          <td><input type="text" class="te-name" value="${seg.name || ''}" placeholder="Name"></td>
          <td><button class="te-del-btn" title="Delete segment">✕</button></td>
        `;

        // Event: kind changed → enable/disable fields
        const kindSel = tr.querySelector('.te-kind');
        kindSel.addEventListener('change', () => {
          const isC = kindSel.value === 'corner';
          tr.querySelector('.te-length').disabled = isC;
          tr.querySelector('.te-angle').disabled  = !isC;
          tr.querySelector('.te-radius').disabled  = !isC;
          tr.querySelector('.te-dir').disabled     = !isC;
          if (isC) {
            tr.querySelector('.te-length').value = '';
            tr.querySelector('.te-angle').value  = tr.querySelector('.te-angle').value || '90';
            tr.querySelector('.te-radius').value = tr.querySelector('.te-radius').value || '80';
          } else {
            tr.querySelector('.te-length').value = '200';
            tr.querySelector('.te-angle').value  = '';
            tr.querySelector('.te-radius').value = '';
          }
          this.updateInfo();
          this.drawPreview();
        });

        // Events: any value change → re-draw
        for (const inp of tr.querySelectorAll('input, select')) {
          inp.addEventListener('input', () => { this.updateInfo(); this.drawPreview(); });
        }

        // Delete button
        tr.querySelector('.te-del-btn').addEventListener('click', () => {
          tr.remove();
          this.renumber();
          this.updateInfo();
          this.drawPreview();
        });

        this.tbody.appendChild(tr);
      },

      addRow() {
        const seg = { kind: 'straight', length: 200, name: '', roughAmp: 0.001, roughLambda: 3.5 };
        this.insertRow(seg, this.tbody.children.length);
        this.renumber();
        this.updateInfo();
        this.drawPreview();
        // Scroll to bottom
        this.tbody.parentElement.scrollTop = this.tbody.parentElement.scrollHeight;
      },

      renumber() {
        const rows = this.tbody.querySelectorAll('tr');
        rows.forEach((tr, i) => { tr.querySelector('.te-row-num').textContent = i + 1; });
      },

      // ── Read segments from table ──
      readSegments() {
        const segs = [];
        const rows = this.tbody.querySelectorAll('tr');
        for (const tr of rows) {
          const kind   = tr.querySelector('.te-kind').value;
          const name   = tr.querySelector('.te-name').value.trim();
          if (kind === 'straight') {
            const length = parseFloat(tr.querySelector('.te-length').value) || 200;
            segs.push({ kind: 'straight', length, name: name || `Straight ${segs.length + 1}`,
                         roughAmp: 0.001, roughLambda: 3.5 });
          } else {
            const angleDeg  = parseFloat(tr.querySelector('.te-angle').value) || 90;
            const radius    = parseFloat(tr.querySelector('.te-radius').value) || 80;
            const direction = parseInt(tr.querySelector('.te-dir').value) || 1;
            segs.push({ kind: 'corner', angleDeg, radius, direction,
                         name: name || `T${segs.filter(s => s.kind === 'corner').length + 1}`,
                         roughAmp: 0.003, roughLambda: 2.5, roughPhase: Math.random() * 3 });
          }
        }
        return segs;
      },

      // ── Trace segments into x/y polyline ──
      traceSegments(segs) {
        const pts = [];
        let x = 0, y = 0, heading = 0;
        const step = 3;
        for (let si = 0; si < segs.length; si++) {
          const seg = segs[si];
          const segLen = seg.kind === 'corner'
            ? Math.abs(seg.radius) * (seg.angleDeg || 0) * Math.PI / 180
            : seg.length;
          const nSteps = Math.max(1, Math.ceil(segLen / step));
          const ds = segLen / nSteps;
          for (let j = 0; j < nSteps; j++) {
            pts.push({ x, y, heading, segIdx: si, kind: seg.kind });
            if (seg.kind === 'straight') {
              x += Math.cos(heading) * ds;
              y += Math.sin(heading) * ds;
            } else {
              const r = seg.radius, dir = seg.direction || 1;
              const dAngle = (ds / r) * dir;
              const perp = heading + (Math.PI / 2) * dir;
              const cx = x + Math.cos(perp) * r;
              const cy = y + Math.sin(perp) * r;
              const sa = heading - (Math.PI / 2) * dir;
              x = cx + Math.cos(sa + dAngle) * r;
              y = cy + Math.sin(sa + dAngle) * r;
              heading += dAngle;
            }
          }
        }
        pts.push({ x, y, heading, segIdx: -1, kind: 'end' });
        return pts;
      },

      // ── Update info bar ──
      updateInfo() {
        const segs = this.readSegments();
        document.getElementById('teSegCount').textContent = `Segments: ${segs.length}`;

        let totalLen = 0, netAngle = 0;
        for (const s of segs) {
          if (s.kind === 'corner') {
            totalLen += Math.abs(s.radius) * (s.angleDeg || 0) * Math.PI / 180;
            netAngle += (s.angleDeg || 0) * (s.direction || 1);
          } else {
            totalLen += s.length;
          }
        }
        document.getElementById('teLapLen').textContent = `Lap length: ${Math.round(totalLen)} m`;
        document.getElementById('teNetAngle').textContent = `Net angle: ${Math.round(netAngle)}°`;

        // Closure error
        const pts = segs.length > 0 ? this.traceSegments(segs) : [];
        if (pts.length > 1) {
          const end = pts[pts.length - 1];
          const gap = Math.sqrt(end.x * end.x + end.y * end.y);
          const el = document.getElementById('teClosure');
          if (gap < 15) {
            el.textContent = `Closure: ✓ ${gap.toFixed(0)} m`;
            el.className = 'te-stat ok';
          } else {
            el.textContent = `Closure: ⚠ ${gap.toFixed(0)} m`;
            el.className = 'te-stat warn';
          }
        }
      },

      // ── Draw preview ──
      drawPreview() {
        const segs = this.readSegments();
        const pts  = this.traceSegments(segs);
        const cvs  = this.previewCanvas;
        const ctx  = this.previewCtx;
        const W = cvs.width, H = cvs.height;

        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = '#0a0d13';
        ctx.fillRect(0, 0, W, H);

        if (pts.length < 2) return;

        // Compute bounds
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const p of pts) {
          minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
          minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
        }
        const rangeX = (maxX - minX) || 1, rangeY = (maxY - minY) || 1;
        const margin = 40;
        const scale = Math.min((W - 2 * margin) / rangeX, (H - 2 * margin) / rangeY);
        const cx = W / 2 - ((minX + maxX) / 2) * scale;
        const cy = H / 2 + ((minY + maxY) / 2) * scale;

        const toSx = (px) => cx + px * scale;
        const toSy = (py) => cy - py * scale;

        // Draw track surface
        ctx.strokeStyle = '#1e2230';
        ctx.lineWidth = Math.max(8, 28 * scale);
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(toSx(pts[0].x), toSy(pts[0].y));
        for (let i = 1; i < pts.length; i++) {
          ctx.lineTo(toSx(pts[i].x), toSy(pts[i].y));
        }
        ctx.stroke();

        // Draw centre line, coloured by segment type
        for (let i = 1; i < pts.length; i++) {
          const pp = pts[i - 1], pt = pts[i];
          if (pt.kind === 'corner') {
            const seg = segs[pt.segIdx];
            ctx.strokeStyle = seg && seg.direction === 1
              ? 'rgba(255,80,80,0.7)' : 'rgba(80,150,255,0.7)';
          } else {
            ctx.strokeStyle = 'rgba(255,255,255,0.35)';
          }
          ctx.lineWidth = Math.max(1.5, 3 * scale);
          ctx.beginPath();
          ctx.moveTo(toSx(pp.x), toSy(pp.y));
          ctx.lineTo(toSx(pt.x), toSy(pt.y));
          ctx.stroke();
        }

        // Start / finish marker
        ctx.fillStyle = '#00ff88';
        ctx.beginPath();
        ctx.arc(toSx(pts[0].x), toSy(pts[0].y), 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = '10px sans-serif'; ctx.textAlign = 'left';
        ctx.fillText('S/F', toSx(pts[0].x) + 8, toSy(pts[0].y) + 4);

        // Closure gap dashed line
        const end = pts[pts.length - 1];
        const gap = Math.sqrt(end.x * end.x + end.y * end.y);
        if (gap > 5) {
          ctx.strokeStyle = '#ff6b6b'; ctx.lineWidth = 1.5;
          ctx.setLineDash([5, 4]);
          ctx.beginPath();
          ctx.moveTo(toSx(end.x), toSy(end.y));
          ctx.lineTo(toSx(0), toSy(0));
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.fillStyle = '#ff6b6b'; ctx.font = '10px sans-serif';
          ctx.fillText(`gap: ${gap.toFixed(0)} m`, toSx((end.x) / 2) + 6, toSy((end.y) / 2));
        }
      },

      // ── Apply segments and start simulation ──
      applySegments(segs) {
        Track.segments.length = 0;
        for (const s of segs) Track.segments.push(s);
        Track._segmentsInitialized = false;
        Track._lapLength = null;
        Track._segmentStarts = null;
        Track._points = null;
        Track._closureError = null;
        Track._trackRotation = null;
        Track._initSegments();
      },

      startSim() {
        _debugLog('startSim() called');
        // Hide all menus
        this.overlay.classList.add('hidden');
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('carEditorOverlay').classList.add('hidden');
        document.getElementById('mainApp').style.display = '';

        // Apply track properties from editor fields
        const lapsInput = document.getElementById('teTrackLaps');
        const nameInput = document.getElementById('teTrackName');
        const gripSelect = document.getElementById('teTrackGrip');
        if (lapsInput) Track.totalLaps = Math.max(1, parseInt(lapsInput.value) || 8);
        if (nameInput) Track.name = nameInput.value || 'Speed Oval';
        if (gripSelect) Track.gripMultiplier = parseFloat(gripSelect.value) || 1.0;

        // Apply weather from track editor
        const teWeatherCond = document.getElementById('teWeatherCondition');
        const teWeatherTemp = document.getElementById('teWeatherTemp');
        if (teWeatherCond) Weather.setCondition(teWeatherCond.value);
        if (teWeatherTemp) {
          Weather.airTemp = parseFloat(teWeatherTemp.value) || 25;
          Weather.computeAirDensity();
          Weather.computeTrackTemp();
          Weather.computeTrackGrip();
          AIR_DENSITY = Weather.airDensity;
        }
        // Sync footer weather controls
        const footerWS = document.getElementById('weatherSelect');
        const footerWT = document.getElementById('weatherTemp');
        if (footerWS) footerWS.value = Weather.condition;
        if (footerWT) footerWT.value = Weather.airTemp;

        _debugSetRacing();
        _watchOverlay();
        _startHeartbeat();
        _debugLog('Overlay hidden, mainApp visible. Initializing modules...');
        TrackRenderer.invalidate();
        Renderer.init();
        Simulation.reset();
        TelemetryUI.init();
        DataUI.init();
        SetupUI.init();
        TireUI.init();
        CamberUI.init();
        AeroUI.init();
        PlatformUI.init();
        WeatherUI.init();
        PartsUI.init();
        SensitivityAnalysis.init();
        RaceUI.initRace();
        this._wireUI();
        _debugLog('All modules initialized. Starting gameLoop...');
        // Only start one gameLoop chain — prevent duplicates on re-init
        if (!_gameLoopRunning) {
          _gameLoopRunning = true;
          _debugLog('gameLoop chain started (first time)');
          requestAnimationFrame(gameLoop);
        } else {
          _debugLog('gameLoop already running — not spawning duplicate');
        }
      },

      loadDefault() {
        // Show loading overlay while track builds
        const ls = document.getElementById('raceLoadingOverlay');
        if (ls) { ls.style.display = 'flex'; ls.style.opacity = '1'; }

        // Defer heavy work so the loading overlay actually paints
        requestAnimationFrame(() => { setTimeout(() => {
          Track._segmentsInitialized = false;
          Track._lapLength = null;
          Track._segmentStarts = null;
          Track._points = null;
          Track._initSegments();
          // Sync editor table with default track
          this.populateTable(Track.segments);
          document.getElementById('teTrackLaps').value = Track.totalLaps || 8;
          document.getElementById('teTrackName').value = Track.name || 'Speed Oval';
          this.startSim();

          // Fade out loading overlay
          if (ls) {
            ls.style.opacity = '0';
            setTimeout(() => { ls.style.display = 'none'; }, 500);
          }
        }, 60); });
      },

      generateCustom() {
        const segs = this.readSegments();
        if (segs.length < 2) { alert('Add at least 2 segments.'); return; }
        const ls = document.getElementById('raceLoadingOverlay');
        if (ls) { ls.style.display = 'flex'; ls.style.opacity = '1'; }
        requestAnimationFrame(() => { setTimeout(() => {
          this.applySegments(segs);
          this.startSim();
          if (ls) {
            ls.style.opacity = '0';
            setTimeout(() => { ls.style.display = 'none'; }, 500);
          }
        }, 60); });
      },

      _timingIntervalId: null,  // Guard against duplicate setInterval timers
      _uiWired: false,          // Guard against duplicate event listener binding
      
      _wireUI() {
        // Timing interval: always clear and re-create (needs to work with new race data)
        if (this._timingIntervalId) {
          clearInterval(this._timingIntervalId);
        }
        this._timingIntervalId = setInterval(() => {
          try {
            RaceUI.updateLiveTiming();
            RaceUI.updateCurrentSectors();
            const modal = document.getElementById('f1TimingModal');
            if (modal && modal.classList.contains('open')) RaceUI.updateFullTiming();
          } catch (err) {
            console.warn('[TimingInterval] Error:', err.message);
          }
        }, 500);
        
        // Button listeners: only bind once
        if (this._uiWired) return;
        this._uiWired = true;
        
        const followBtn = document.getElementById('followBtn');
        if (followBtn) {
          followBtn.addEventListener('click', () => {
            Renderer.followMode = !Renderer.followMode;
            followBtn.textContent = Renderer.followMode ? '📷 Following' : '📷 Follow';
            followBtn.style.background = Renderer.followMode ? '#0066cc' : '#444';
            if (!Renderer.followMode) Renderer.centerTrack();
          });
        }
        const openTimingBtn = document.getElementById('openFullTiming');
        const closeTimingBtn = document.getElementById('closeFullTiming');
        if (openTimingBtn) openTimingBtn.addEventListener('click', () => RaceUI.openFullTiming());
        if (closeTimingBtn) closeTimingBtn.addEventListener('click', () => RaceUI.closeFullTiming());
        
        // ── Weather controls ──
        const weatherSelect = document.getElementById('weatherSelect');
        const weatherTemp = document.getElementById('weatherTemp');
        if (weatherSelect) {
          weatherSelect.value = Weather.condition;
          weatherSelect.addEventListener('change', () => {
            if (Simulation.running) return; // No weather changes during race
            Weather.setCondition(weatherSelect.value);
          });
        }
        if (weatherTemp) {
          weatherTemp.value = Weather.airTemp;
          weatherTemp.addEventListener('change', () => {
            if (Simulation.running) return; // No weather changes during race
            Weather.airTemp = parseFloat(weatherTemp.value) || 25;
            Weather.trackTemp = Weather.computeTrackTemp();
            Weather.airDensity = Weather.computeAirDensity();
            AIR_DENSITY = Weather.airDensity;
          });
        }
        
        // ── Lap times toggle ──
        const lapTimesToggle = document.getElementById('lapTimesToggle');
        const lapTimesList = document.getElementById('lapTimesList');
        if (lapTimesToggle && lapTimesList) {
          lapTimesToggle.addEventListener('click', () => {
            const isVisible = lapTimesList.style.display !== 'none';
            lapTimesList.style.display = isVisible ? 'none' : 'block';
            lapTimesToggle.textContent = isVisible ? '⏱ Lap Times ▸' : '⏱ Lap Times ▾';
          });
        }
        
        // ── Driving Mode buttons ──
        document.querySelectorAll('[data-mode]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const mode = btn.dataset.mode;
            DrivingMode.set(mode);
            document.querySelectorAll('[data-mode]').forEach(b => {
              b.classList.remove('active');
              b.style.border = 'none';
            });
            btn.classList.add('active');
            btn.style.border = '2px solid #fff';
          });
        });
        // Initialize default mode button style
        const defaultModeBtn = document.querySelector('[data-mode="normal"]');
        if (defaultModeBtn) defaultModeBtn.style.border = '2px solid #fff';
      }
    };

    // ═══════════════════════════════════════════════════════════════
    // MOTORSPORT MANAGER BRIDGE — Import/Export race configs via localStorage
    // ═══════════════════════════════════════════════════════════════
    const MotorsportManagerBridge = {
      _config: null,
      _active: false,
      _driverIdMap: [],  // maps car index (0-19) → MM driverId string

      hasConfig() {
        try {
          const raw = localStorage.getItem('MM_raceConfig');
          if (!raw) return false;
          const cfg = JSON.parse(raw);
          if (cfg && cfg.source === 'MotorsportManager' && cfg.grid && cfg.grid.length > 0) {
            this._config = cfg;
            return true;
          }
        } catch (e) { console.warn('MM Bridge: config parse error', e); }
        return false;
      },

      applyConfig() {
        const cfg = this._config;
        if (!cfg) return;
        this._active = true;
        console.log('[MM Bridge] Applying race config:', cfg.seriesName, cfg.circuit.name);

        // 1. Set laps
        Track.totalLaps = cfg.circuit.laps || 8;
        Track.name = cfg.circuit.name || 'MM Circuit';

        // 2. Apply weather
        if (cfg.weather) {
          const weatherMap = {
            'sunny': 'sunny', 'cloudy': 'cloudy',
            'light_rain': 'light_rain', 'heavy_rain': 'heavy_rain',
            'rain': 'light_rain'
          };
          Weather.setCondition(weatherMap[cfg.weather] || 'sunny');
        }

        // 3. Map grid to teamSetups, driverNames, driverSkillProfiles
        const gridSize = Math.min(cfg.grid.length, 20); // max 20 cars
        this._driverIdMap = new Array(20).fill(null);
        for (let i = 0; i < gridSize; i++) {
          const entry = cfg.grid[i];
          if (!entry) continue;

          // Driver ID mapping (MM string ID → car index)
          this._driverIdMap[i] = entry.driverId || null;

          // Driver name
          driverNames[i] = entry.driverName || `Driver ${i + 1}`;

          // Driver skills (map MM skills to RaceModule format)
          if (entry.skills) {
            driverSkillProfiles[i] = {
              braking:       entry.skills.braking       || 70,
              cornering:     entry.skills.cornering     || 70,
              accelerating:  entry.skills.accelerating  || 70,
              tyre_mgmt:     entry.skills.tyre_mgmt     || 70,
              fuel_mgmt:     entry.skills.fuel_mgmt     || 70,
              consistency:   entry.skills.consistency   || 70,
              wet_pace:      entry.skills.wet_pace      || 60,
            };
          }

          // Car setup
          if (entry.car) {
            RaceUI.teamSetups[i] = {
              power:       entry.car.power       || CarDefaults.power,
              cLWing:      entry.car.cLWing      || CarDefaults.cLWing,
              cLDiffuser:  entry.car.cLDiffuser  || CarDefaults.cLDiffuser,
              cDBody:      entry.car.cDBody      || CarDefaults.cDBody,
              cDWing:      entry.car.cDWing      || CarDefaults.cDWing,
              mass:        entry.car.mass        || CarDefaults.mass,
              tireGrip:    entry.car.tireGrip    || CarDefaults.tireGrip,
              brakeForce:  entry.car.brakeForce  || CarDefaults.brakeForce,
              frontalArea: entry.car.frontalArea || CarDefaults.frontalArea,
            };
          }

          // Team name & color
          if (entry.teamName && RaceUI.teams[i]) {
            RaceUI.teams[i].name = entry.teamName;
          }
          if (entry.color && RaceUI.teams[i]) {
            RaceUI.teams[i].color = entry.color;
          }
        }

        // Fill remaining slots with defaults if grid < 20
        for (let i = gridSize; i < 20; i++) {
          // Keep existing defaults — they'll be AI opponents
        }

        // 4. Clear the config so reloading doesn't re-trigger
        localStorage.removeItem('MM_raceConfig');

        // 5. Auto-start race (skip main menu)
        console.log('[MM Bridge] Auto-starting race with', gridSize, 'cars');
        TrackEditor.loadDefault();
      },

      sendResult(finishOrder) {
        if (!this._active) return;
        try {
          const ranking = finishOrder.map((entry, idx) => ({
            position: idx + 1,
            driverId: this._driverIdMap[entry.car.id - 1] || entry.car.id,
            id: entry.car.id,
            driverName: entry.car.name,
            totalTime: entry.finishTime,
            time: entry.finishTime,
            bestLapTime: entry.car.bestLapTime < Infinity ? entry.car.bestLapTime : null,
            dnf: entry.dnf || false,
          }));

          const result = {
            source: 'RaceModuleV1',
            timestamp: Date.now(),
            ranking,
          };

          localStorage.setItem('MM_raceResult', JSON.stringify(result));
          console.log('[MM Bridge] Race result written to localStorage');
        } catch (e) { console.error('[MM Bridge] Failed to write result:', e); }
      },
    };

    document.addEventListener('DOMContentLoaded', () => {
      _debugLog('DOMContentLoaded → Loading screen + menu init');
      
      // Physics toggle
      const phToggle = document.getElementById('physicsToggle');
      const phBreakdown = document.getElementById('physicsBreakdown');
      if (phToggle && phBreakdown) {
        phToggle.addEventListener('click', () => {
          const hidden = phBreakdown.style.display === 'none';
          phBreakdown.style.display = hidden ? '' : 'none';
          phToggle.textContent = hidden ? '─ Physics ▾ ─' : '─ Physics ▸ ─';
        });
      }
      
      TrackEditor.init();
      MainMenu.init();
      LoadingScreen.start();

      // ── Init AudioContext on first user interaction (browser policy) ──
      const _initAudioOnce = () => {
        SoundEngine.init();
        SoundEngine.resume();
        document.removeEventListener('click', _initAudioOnce);
        document.removeEventListener('keydown', _initAudioOnce);
      };
      document.addEventListener('click', _initAudioOnce);
      document.addEventListener('keydown', _initAudioOnce);
    });
  </script>
</body>
</html>
